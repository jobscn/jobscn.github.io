<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="linux,"><meta name="description" content="一、绪论操作系统基本概念计算机系统所必须的一系列基本程序集合，称为操作系统。其中，最重要的程序称为内核(kernel)，当操作系统启动时，将内核装入RAM中，内核中包含了操作系统运行所必须的核心过程。 操作系统必须完成两个主要目标  与硬件交互 为用户程序提供执行环境  一些操作系统，允许用户程序直接与硬件进行交互，如MS-DOS。相反的是，类Unix操作系统把与计算机物理组织相关的所有底层细节对"><meta name="keywords" content="linux"><meta property="og:type" content="article"><meta property="og:title" content="【操作系统】Linux内核基础篇"><meta property="og:url" content="https://jobscn.github.io/linux/linux-core-base.html"><meta property="og:site_name" content="Jobscn&#39;s blog"><meta property="og:description" content="一、绪论操作系统基本概念计算机系统所必须的一系列基本程序集合，称为操作系统。其中，最重要的程序称为内核(kernel)，当操作系统启动时，将内核装入RAM中，内核中包含了操作系统运行所必须的核心过程。 操作系统必须完成两个主要目标  与硬件交互 为用户程序提供执行环境  一些操作系统，允许用户程序直接与硬件进行交互，如MS-DOS。相反的是，类Unix操作系统把与计算机物理组织相关的所有底层细节对"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://tinypng.com/web/output/znfb9mfm5gx5c1xtda55rneq1wg0kr2k/786852A8-8858-45FD-945B-155D23CCD292.png"><meta property="og:updated_time" content="2019-07-08T03:04:53.960Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【操作系统】Linux内核基础篇"><meta name="twitter:description" content="一、绪论操作系统基本概念计算机系统所必须的一系列基本程序集合，称为操作系统。其中，最重要的程序称为内核(kernel)，当操作系统启动时，将内核装入RAM中，内核中包含了操作系统运行所必须的核心过程。 操作系统必须完成两个主要目标  与硬件交互 为用户程序提供执行环境  一些操作系统，允许用户程序直接与硬件进行交互，如MS-DOS。相反的是，类Unix操作系统把与计算机物理组织相关的所有底层细节对"><meta name="twitter:image" content="https://tinypng.com/web/output/znfb9mfm5gx5c1xtda55rneq1wg0kr2k/786852A8-8858-45FD-945B-155D23CCD292.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://jobscn.github.io/linux/linux-core-base.html"><title>【操作系统】Linux内核基础篇 | Jobscn's blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Jobscn's blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">嚯嚯嚯哈哈哈</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jobscn.github.io/linux/linux-core-base.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jobscn"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jobscn's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">【操作系统】Linux内核基础篇</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-01T21:36:00+08:00">2019-03-01 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>计算机系统所必须的一系列基本程序集合，称为操作系统。其中，最重要的程序称为内核(kernel)，当操作系统启动时，将内核装入RAM中，内核中包含了操作系统运行所必须的核心过程。</p><p>操作系统必须完成两个主要目标</p><ul><li>与硬件交互</li><li>为用户程序提供执行环境</li></ul><p>一些操作系统，允许用户程序直接与硬件进行交互，如<code>MS-DOS</code>。相反的是，类Unix操作系统把与计算机物理组织相关的所有底层细节对用户程序隐藏。当用户程序想要使用硬件资源时，需要向操作系统发出一个请求，内核对该请求进行评估，如果允许使用这个资源，那么，内核代表用户程序，对相关硬件进行交互。</p><p>为了实施这种机制，现代操作系统依靠特殊的硬件特性来禁止用户程序直接与底层硬件部分进行交互，或禁止直接访问任何物理地址。因此，硬件为CPU引入了两种不同的执行模式：用户程序的非特权模式、内核的特权模式。在Unix中，被称为<code>用户态(User Mode)</code>以及<code>内核态(Kernel Mode)</code>。</p><h3 id="多用户系统"><a href="#多用户系统" class="headerlink" title="多用户系统"></a>多用户系统</h3><p>即指一个能并发和独立地运行两个以至多个用户的若干应用程序的计算机。Unix便是实施系统资源硬件保护的多用户系统。</p><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>在多用户系统中，每个用户在机器上都有私有空间。用户之间，不能互相对私有内容进行访问，操作系统必须保证私有的用户空间仅对拥有者可见。用户使用一个唯一数字来标识，称为<code>UID(User ID)</code></p><p>为了与其他用户有选择的共享资料，每个用户都可以是一个或多个用户组中的成员，组由唯一的标识符表示，称为<code>GID(User Group ID)</code>。</p><p>任何类Unix操作系统都有一个特殊的用户，叫做<code>root</code>，即<code>超级用户(superuser)</code>。系统不对该用户使用常见的保护机制，其能够访问系统中的每一个文件，干涉每一个正在执行的用户程序的活动。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>所有的操作系统都使用这样的一个基本抽象：<code>进程(Process)</code>。一个进程可以定义为<code>程序执行时的一个示例</code>或<code>一个运行程序的&quot;执行上下文&quot;</code>。</p><p>多用户系统必须实施一种执行环境，这种环境允许并发、竞争系统资源(主要是CPU)。这种允许进程并发活动的系统称为<code>多道程序系统(multiprogramming)</code>或<code>多处理系统(multiprocessing)</code>。</p><p>Unix是具有抢占式进程的多处理操作系统。永远有几个系统进程在监视外围设备以及监听系统终端并等待用户登陆。</p><p>类Unix操作系统采用进程/内核模式。每个进程都认为自己是系统的唯一进程，可以独占操作系统所提供的服务。只要进程发出系统调用，硬件就会将特权模式从用户态变为内核态，然后进程开始一个内核过程的执行。这样，操作系统在进程的执行上下文中就起了一定作用，仪满足进程所需。随后，内核将迫使硬件返回用户态，进程继续下一步指令。</p><h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><p>大部分Unix内核是单块结构，每一个内核层都被集成到整个内核程序中，并代表当前进程在内核态下运行。而微内核则相反，通常它的内核只包含很小的一部分函数集，可能只包含几个同步原语、一个简单的调度程序、进程间的通信机制。运行于微内核之上的系统进程，再实现操作系统级的功能，如内存分配程序、设备驱动程序、系统调用处理程序等。</p><p>为了达到微内核理论的许多优点又不至于影响性能，Linux内核提供了模块(module)，模块是一个目标文件，其代码可以在运行时链接到内核或解除链接。通常是一组函数组成，用以实现如文件系统、驱动程序或其他内核上层功能。模块同其他内核函数一样，它代表当前进程在内核态下执行。</p><p>模块有如下几个优点：</p><ul><li>模块化方法</li><li>平台无关性</li><li>节省内存使用（当需要时，链接到内核中）</li><li>无性能损失（目标代码一旦被链入内核，其作用与静态链接的内核目标代码完全等价，当模块被调用时，无需显式的进行消息传递）</li></ul><h2 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Unix文件是以字节序列组成的信息载体，内核不解释文件的内容。从用户的方向上看，文件被组织在一颗树结构的命名空间中。</p><p>除了叶节点，其他的节点都表示目录名。目录节点包含它下面的文件及目录的所有信息。</p><p>Unix的每个进程，都有一个当前工作目录，它属于进程执行上下文，标识出进程所用的当前目录。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Unix的文件内容是由字符序列组成，不包含任何控制信息，如文件长度或文件结束符。</p><p>文件系统处理文件需要的所有信息包含在一个名为<code>索引节点(inode)</code>的数据结构中，每个文件都有自己的索引节点，文件系统用索引节点来标识文件。</p><p>不同的文件系统，都必须至少满足POSIX标准中指定的如下属性：</p><ul><li>文件类型</li><li>与文件相关的硬连接个数</li><li>以字节为单位的文件长度</li><li>设备标识符(即包含文件的设备的标识符)</li><li>在文件系统中标识文件的索引节点号</li><li>文件拥有者的UID</li><li>文件的用户组ID</li><li>几个时间戳（索引节点状态改变的时间、最后访问时间、最后修改时间）</li><li>访问权限与文件模式</li></ul><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><h4 id="1-suid"><a href="#1-suid" class="headerlink" title="1.suid"></a>1.suid</h4><p>进程执行一个文件时，通常保持进程拥有者的UID，也就是执行该可执行文件的用户的UID。当可执行文件设置suid标志位时，进程就获得了该文件拥有者的UID。</p><p>如cat程序，本身属主为root、属组也为root，默认情况下被user1执行，那么该cat进程获得user1的uid及gid。若cat程序设置了suid标志位，那么cat程序被执行后的属主便是cat程序文件的属主，即root。而属组不变，为user1。</p><h4 id="2-sgid"><a href="#2-sgid" class="headerlink" title="2.sgid"></a>2.sgid</h4><p>同上，进程将获得该文件的组id</p><h4 id="3-sticky"><a href="#3-sticky" class="headerlink" title="3.sticky"></a>3.sticky</h4><p>设置该标志位的可执行文件，被执行时将向内核发出一个请求，在程序执行结束后，进程依然被保留在内存中。(这个标志已经过时，现在使用基于代码页共享的其他方法)</p><h2 id="Unix内核概述"><a href="#Unix内核概述" class="headerlink" title="Unix内核概述"></a>Unix内核概述</h2><p>Unix内核提供了应用程序可以运行的执行环境。因此，内核必须实现一组服务及响应接口。应用程序使用这些接口时，通常不会与硬件资源直接交互</p><h3 id="进程-内核模式"><a href="#进程-内核模式" class="headerlink" title="进程/内核模式"></a>进程/内核模式</h3><p>内核本身不是一个进程，而是进程的管理者。进程/内核模式假定：请求内核服务的进程使用所谓系统调用的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户态到内核态的转换。</p><p>Unix其实还包括了几个所谓内核线程的特权进程，被赋予特殊权限的进程。它们有以下几个特点</p><ul><li>运行在内核地址空间</li><li>不与用户直接交互，因此不需要终端设备</li><li>通常随系统启动而被创建，并一直活跃直到系统关闭</li></ul><p>Unix内核所做的并不只是处理系统调用，它包括了以下几种方式激活内核：</p><ul><li>进程调用系统调用</li><li>执行进程的CPU发出异常信号，内核代表异常的进程处理异常。</li><li>外围设备向CPU发出一个中断信号以通知一个事件的发生。(每个中断信号都是由内核中的中断处理程序来处理的，因为外围设备与CPU是异步的，因此中断的发生是不可预知的)</li><li>内核线程被执行(内核线程运行在内核态)</li></ul><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>每个进程由进程描述符表示，该描述符包含进程的当前状态等信息。</p><p><strong><em>当内核暂停一个进程的执行时，会将相关处理器寄存器的内容保存于进程描述符中</em></strong>，这些寄存器包括：</p><ul><li>程序计数器(PC)、栈指针(SP)寄存器</li><li>通用寄存器</li><li>浮点寄存器</li><li>包含CPU状态信息的处理器控制寄存器(处理器状态字)</li><li>用于跟踪进程对RAM访问的内存管理寄存器</li></ul><p>当内核决定恢复执行一个进程时，它将用进程描述符中合适的字段来装载CPU寄存器。因为程序计数器所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。</p><p>当一个进程不在CPU上执行时，它正在等待某一事件。Unix内核可以区分很多等待状态，通常由进程描述符队列实现，每个队列表示等待某一个特定事件的一组进程。</p><h3 id="可重入内核"><a href="#可重入内核" class="headerlink" title="可重入内核"></a>可重入内核</h3><p>所有的Unix内核都是可重入的，若干进程可以同时运行在内核态下。</p><p>对于单处理器系统而言，可能有许多进程在等待CPU或某个IO操作的完成中被阻塞于内核态中。例如，一个进程向内核发出读磁盘请求，进入内核态后，内核代替进程发出读磁盘请求，读磁盘过程交由磁盘控制器完成，并恢复其他进程的执行，而这时，上一个进程进入阻塞状态，直到磁盘控制器的读磁盘操作完成，发出中断通知内核，从而让之前阻塞的进程可以继续。</p><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>通常每个进程运行在它的私有地址空间。用户态下运行的进程涉及到私有栈、数据区、代码区。而当内核态运行时，进程访问内核的数据区和代码区，使用另外的私有栈。</p><p>进程虽然看起来都访问一个私有地址空间，但有时进程间也共享部分地址空间。有时，内核会自动完成使得程序执行时共享部分地址空间，比如一个程序被多次执行时。</p><p>Linux支持mmap()系统调用，允许存放在块设备上的文件或信息的一部分映射到进程的部分地址空间。如果同一个文件被多个进程共享，那么每个共享它的进程的地址空间都将包含它的内存映射。</p><h3 id="信号量与自旋锁"><a href="#信号量与自旋锁" class="headerlink" title="信号量与自旋锁"></a>信号量与自旋锁</h3><p>信号量可以被看作一个对象，组成如下：</p><ul><li>一个整数变量</li><li>一个等待进程的链表</li><li>两个原子方法<code>up()</code>与<code>down()</code></li></ul><p>每个需要被保护的数据结构都有它自己的信号量，初值为1.当内核控制路径想要访问这个数据结构时，他在对应的信号量上执行down()方法，随后判断信号量的值，若不是负数，则允许访问该数据结构。否则，将内核控制路径的进程加入到信号量链表并阻塞该进程。当另一个进程执行up()方法时，允许信号量连标上的一个进程继续执行。</p><p>但信号量并不一定是最佳的解决同步问题的方案，如果修改数据结构所需的时间比较短，信号量可能是抵消的，因为内核必须将进程插入到信号量链表中，然后刮起它。这两种 操作比较费时，在完成这些操作时，其他内核控制路径可能已经释放信号量。</p><p>因此，多处理器操作系统有时使用自旋锁(spin lock)。自旋锁与信号量非常相似，但没有进程链表，但一个进程发现锁被另一个进程锁住时，他就不停的“旋转”，执行一个进程的循环指令，直到锁被打开。</p><p>当然，自旋锁在当处理器环境下时无效的，因为当内核控制路径试图访问一个上锁的数据结构时，他可能开始无休止的循环，最终甚至可能导致系统刮起。</p><h3 id="信号与进程间通信"><a href="#信号与进程间通信" class="headerlink" title="信号与进程间通信"></a>信号与进程间通信</h3><p>Unix信号(signal)提供了将系统事件报告给进程的一种机制，每个事件都有自己的信号编号。有两种系统事件：</p><ul><li>异步通告<br><br>例如，当用户在终端按下中断键(Ctrl-C)时，即向前台进程发出中断信号(SIGINT)</li><li>同步错误或异常<br><br>例如，当进程访问内存非法地址时，内核向这个进程发送一个SIGSEGV信号</li></ul><p>POSIX标准定义了大约20种不同的信号，其中，有两种时允许用户自定义的，可以当作用户态下进程通信和同步的原语机制。一般来说，进程可以对收到的信号作出两种反应：</p><ol><li>忽略信号</li><li>异步的执行一个指定过程(信号处理程序)</li></ol><p>如果不指定某种方式，那么内核就根据信号的编号执行一个默认操作，五种可能的默认操作是：</p><ol><li>终止进程</li><li>将执行上下文和进程地址空间的内容写入一个文件(<code>核心转储(core dump)</code>，并终止进程</li><li>忽略信号</li><li>挂起进程</li><li>如果进程曾被暂停，则恢复执行</li></ol><p>此外，SIGKILL与SIGSTOP信号不能由进程直接处理，也不能被进程忽略。</p><p>大部分Unix内核都采用了这些进程间通信机制：信号量、消息队列、共享内存，它们统称为System V IPC。</p><h1 id="二、内存寻址"><a href="#二、内存寻址" class="headerlink" title="二、内存寻址"></a>二、内存寻址</h1><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>包含在机器语言指令中，用来指定一个操作数或一条指令的地址。每个逻辑地址都由一个段和偏移量组成。</p><h3 id="线性地址-虚拟地址"><a href="#线性地址-虚拟地址" class="headerlink" title="线性地址(虚拟地址)"></a>线性地址(虚拟地址)</h3><p>是一个32位无符号整数，可以用来表示高达4G的内存地址。</p><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>内存单元寻址，物理地址由32位或36位无符号整数表示。</p><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>内存控制单元(MMU)通过一种被称为分段单元的硬件电路把一个逻辑地址转换成线性地址；接着，第二个被称为分页单元的硬件电路把线性单元转换成物理地址。</p><p>[逻辑地址]-&gt;分段单元-&gt;[线性地址]-&gt;分页单元-&gt;[物理地址]</p><p>在多处理器系统中，所有CPU允许共享一片内存，因此，RAM芯片可以被并发访问，但RAM芯片上的读写操作必须串行执行，因此，一种叫做内存仲裁器的硬件电路被放置在总线和每个RAM芯片之间，其作用是，若一个RAM芯片空闲，就允许一个CPU访问、否则延迟这个CPU访问。即使在单处理器上，也存在内存仲裁器，因为单处理器系统中可能包含一种叫做DMA控制器的特殊处理器，CPU与DMA属于并发的关系，因此内存仲裁器在其中也不可缺少。</p><h2 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h2><p>Intel微处理器以两种不同方式执行地址转换，一种称为实模式(real mode)，另一种是保护模式(protected model)。实模式主要用于维持处理器与早起模型的兼容，下面主要描述的是保护模式下的地址转换。</p><h3 id="段选择符与段寄存器"><a href="#段选择符与段寄存器" class="headerlink" title="段选择符与段寄存器"></a>段选择符与段寄存器</h3><p>段的地址通常通过段描述符来获取，其中，指向段描述符的结构称为段选择符。</p><h4 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h4><p>段选择符是一个16位长的字段，构成如下<br>|bit|15 ~ 3|2|1 0|<br>|—|—|—|—|<br>|内容|索引号|TI(表表示器)|RPL(请求者特权级)|</p><p>为了快速方便地找到段选择符，处理器提供了段寄存器，段寄存器的唯一目的就是存放段选择符。寄存器一共6个，同一个段寄存器可用于不同目的，方法是将其值临时保存在内存中，稍后再恢复。</p><blockquote><p>TI表示0:GDT, 1:LDT</p></blockquote><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><table><thead><tr><th>寄存器<br>Segment Registers</th><th>作用</th></tr></thead><tbody><tr><td>cs</td><td>代码段寄存器</td></tr><tr><td>ss</td><td>栈段寄存器</td></tr><tr><td>ds</td><td>数据段寄存器</td></tr><tr><td>es、fs、gs</td><td>普通段寄存器，可以指向任意数据段</td></tr></tbody></table><p>cs寄存器还包含了一个两位的字段，用来表明CPU当前的特权级别，0级表示最高优先级、3级表示最低优先级。对于Linux而言，只有0和3两个级别，即内核态和用户态。</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>每个段由一个8字节的段描述符表示，它描述了段的特征。段描述符放在全局描述符表(Global Descriptor Table, GDT)中或局部描述符表(Local Descriptor Table, LDT)中。</p><p>通常只定义一个GDT、进程还可以自己创建附加的LDT段。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小存放在ldtr控制寄存器中。</p><p>段描述符可以描述一个段的线性地址首字节地址、粒度、段最后一个单元的偏移量、是否为系统段标志、段的类型特征和存取权限、描述符特权级、段存储位置标志(1表示在主存中)、D或B标志(代码/数据段标志)、AVL标志(被Linux忽略)。</p><p>有多不同类型及对应的段描述符，Linux广泛采用的类型是：</p><ul><li>代码段描述符<br><br>它可以放在GDT或LDT中，S标志为1（非系统段）</li><li>数据段描述符<br><br>它可以放在GDT或LDT中，S标志为1（非系统段）。栈段通过一般的数据段实现。</li><li>任务状态段描述符(TSSD)<br><br>该段只用于保存处理器寄存器的内容。只能出现在GDT中，根据相应的进程是否正在CPU上运行，其Type字段的只分别为11或9，S标志置为0。</li><li>局部描述符表描述符(LDTD)<br><br>表示这个段描述符代表一个包含LDT的短，它只出现在GDT中。相应的Type字段的值为2，S标志为0。</li></ul><h3 id="快速访问段描述符"><a href="#快速访问段描述符" class="headerlink" title="快速访问段描述符"></a>快速访问段描述符</h3><p>之前说过，逻辑地址由16位的段选择符和32位的偏移量组成，而段寄存器仅仅存放段选择符，由段选择符指向段描述符。</p><p>为了加速逻辑地址到线性地址的转换，8086处理器提供一种附加的非编程寄存器，提供6个可编程的段寄存器使用，每一个非编程的寄存器含有8字节的段描述符，由相应的段寄存器中的段选择符来制定。当段选择符蓓装入段寄存器时，相应的段描述符就由内存装入对应的非编程CPU寄存器中。处理器就不需要从GDT或LDT中读取，只需要直接引用存放段描述的CPU寄存器即可。晋档段寄存器的内容改变时，才可能重新访问GDT或LDT。</p><blockquote><p><strong><em>读者要点总结</em></strong></p><ol><li>段寄存器存放着段选择符</li><li>段选择符可以方便在GDT/LDT中中定位到指定的段描述表。</li><li>而8086提供额外的非编程寄存器，存放着对应段寄存器所需的段描述符内容。</li><li>段+偏移是逻辑地址，通过段选择符转为到线性地址</li></ol><p>有了非编程寄存器，对应的段寄存器所指向的段线性地址，可直接从非编程寄存器从取出的段描述符中得到。反之，需要从段寄存器中取出段描述符-&gt;访问主存中的段描述表(gdtr/ldtr寄存器)+索引得到指定段描述符-&gt;得到段线性地址。（注：一个段描述符长8字节，因此GDT/LDT的基址+索引*8 = 目标段描述符地址）</p></blockquote><p>GDT的第一项总是设为0，因此空段选择符(索引为0)是会引起处理器异常的，段选择符的长度是13bit，因此最多可存储的段描述符数量为2^13-1 = 8191个。</p><h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>分段单元用于将逻辑地址转换为相应线性地址，具体执行以下操作：</p><ul><li>检查TI字段，判断描述符处在GDT或LDT中(决定下一步使用gdtr还是ldtr中的值)。</li><li>计算段描述符地址(基址+索引)</li><li>使用逻辑地址偏移量+段描述符Base字段的值相加获得线性地址</li></ul><h2 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h2><p>前面讲述的8086中的分段，鼓励程序用将程序划分为逻辑上相关的实体，但Linux只使用比较有限的方式进行分段。分段可以给进程分配不同的线性地址空间，而分页可以将同一个线性地址空间映射到不同的物理空间。与分段相比，Linux更喜欢采用分页方式：</p><ul><li>当所有进程使用相同的段寄存器时，内存管理变得更简单，它们能共享同样的一组线性地址。</li><li>Linux的设计目标之一，是可以移植到绝大多数流行的处理器平台上，而RISC体系结构对分段的支持比较有限。</li></ul><p>2.6版的Linux只有在80x86结构下才需要使用分段。</p><p>所有的Linux进程都使用两对相同的段对指令和数据寻址,一对运行在用户态、一对运行在内核态。</p><p>四个主要的Linux段的段描述符的值<br>|段|Base|G|Limit|S|Type|DPL|D/B|P|<br>|—|—|—|—|—|—|—|—|—|—|<br>|用户代码段|0x00000000|1|0xfffff|1|10|3|1|1||<br>|用户数据段|0x00000000|1|0xfffff|1|2|3|1|1|<br>|内核代码段|0x00000000|1|0xfffff|1|10|0|1|1|<br>|内核数据段|0x00000000|1|0xfffff|1|2|0|1|1|</p><p>相应段选择符由<code>__USER_CS</code>、<code>__USER_DS</code>、<code>__KERNEL_CS</code>、<code>__KERNEL_DS</code>这四个宏分别定义。例如，为了对用户代码段寻址，只需要将<code>__USER_CS</code>产生的值装入cs寄存器即可。</p><p>所有的段都从0x00000000开始，因此，Linux下的逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p><p><strong><em>CPL指当前特权级，反映了进程当前实在用户态还是内核态下，由cs寄存器中的段选择符的RPL字段指定。</em></strong> 特权级改变时，段寄存器需要作出相应的更新。</p><p>例如，CPL=3时，ds寄存器必须含有用户数据段的段选择符、ss寄存器指向用户数据段中的用户栈，而CPL=0时，ds寄存器必须含有内核数据段的段选择符、ss寄存器指向内核数据段中的内核栈。</p><blockquote><p>RPL说明的是进程对段访问的请求权限,意思是当前进程想要的请求权限。</p></blockquote><h3 id="Linux-GDT"><a href="#Linux-GDT" class="headerlink" title="Linux GDT"></a>Linux GDT</h3><p>在单处理器系统下只有一个GDT，在多处理系统中每个CPU对应一个GDT。而所有的GDT放在<code>cpu_gdt_table</code>数组中，所有的GDT的地址和它们的大小都放在<code>cpu_gdt_descr</code>数组中。</p><p>每一个GDT中包含的18个段描述符指向下列的段：</p><ul><li>用户态和内核态下的代码段和数据段共4个。</li><li>任务状态段(TSS)，每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有任务状态段都顺序地放在init_tss数组中。第n个CPU的TSS描述符的Base字段指向init_tss数组中的第n个元素。DPL为0，不允许用户态的进程访问。详细在第三章有说明。</li><li>1个缺省局部描述符表字段，通常被所有进程共享。</li><li>3个局部县城存储(Thread-Local Storage, TLS)段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。</li><li>高级电源管理(AMP)相关的3个段。</li><li>支持即插即用(PnP)功能的BIOS服务程序相关的5个段。</li><li>内核用于处理双重错误异常的特殊TSS段。</li></ul><p>每个处理器都有这样的一个GDT副本。除少数几种情况外，每个GDT副本都放着相同的表项。其中，每个处理器都有它自己的TSS段，因此对应的GDT项不同。LDT和TLS段描述符项可能依赖于CPU正在执行的进程而不同。CPU可能临时修改GDT副本里的某个项，例如调用APM的BIOS例程时可能会出现这种情况。</p><h3 id="Linux-LDT"><a href="#Linux-LDT" class="headerlink" title="Linux LDT"></a>Linux LDT</h3><p>大多数用户态程序不使用局部描述符表，内核定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。wine在执行面向段的Windows应用程序时，通常需要创建自己的局部描述符表。</p><h2 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h2><h3 id="分页的概念"><a href="#分页的概念" class="headerlink" title="分页的概念"></a>分页的概念</h3><p>了解硬件分页前，需要先了解几个概念</p><ol><li>页<br><br>线性地址被分成固定长度为单位的组，这个组就称为页。页内部连续的线性地址呗映射到连续的物理地址中。这样，内核就可以以页为单位指定其物理地址和对应的存取权限。通常，页既指一组线性地址，又指包含在这组地址中的数据。</li><li>页框(页帧)<br><br>分页单元把所有的RAM分成固定长度的页框(page frame, 也翻译做’页帧’， 有时也叫物理页)，每一个页框包含一个页，页框长度与页一致。不同的是，页框是主存的一部分，而页只是一个数据块，可以在页框或者磁盘中。</li><li>页表<br><br>把线性地址映射到物理地址的数据结构称为页表(page table)。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。（从80386开始，x86处理器都支持了分页，设置cr0寄存器的PG标志为0，就不使用分页）</li></ol><blockquote><p>实模式下，CPU的分页功能没有被启用。</p></blockquote><h3 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h3><blockquote><p>从80386开始，Intel处理器分页单元处理4KB的页。</p></blockquote><p>32位的线性地址被分成3个域：</p><ul><li>Directory(目录): 高10位</li><li>Table(页表): 中间10位</li><li>Offset(偏移): 低12位</li></ul><p>线性地址转换分两步，分别使用两种转换表</p><ol><li>页目录表</li><li>页表</li></ol><p>每个活动进程必须由一个分配给它的页目录，但并不需要马上为进程的所有页表分配RAM，只在进程需要时才给页表分配RAM。</p><blockquote><p>在页表上增加一个页目录的目的在于减少每个进程的页表所需的RAM数量，如果只单纯使用页表，那将有2<sup>20</sup>个表项，每项需要4字节，则需要4MB RAM。</p></blockquote><p>由于Offset是12位长，因此每一页可含有2<sup>12</sup> = 4096字节的数据。</p><h4 id="线性地址转换为物理地址的流程"><a href="#线性地址转换为物理地址的流程" class="headerlink" title="线性地址转换为物理地址的流程"></a>线性地址转换为物理地址的流程</h4><ol><li>正在使用的页目录的物理地址存放在控制寄存器cr3中</li><li>线性地址中的Directory字段决定使用页目录中的哪一个目录项</li><li>得到了目录项再由Table字段选择使用哪一个表项(页)</li><li>而表项(页)中含有所在页框的物理地址</li><li>最后由Offset决定在这个页框内的相对位置。</li></ol><p>页目录与页表都是10位长，各有1024项。因此，一个页目录可以寻址到1024*1024*4096=2<sup>32</sup>个存储单元，这和32位地址的要求刚好符合。</p><h4 id="页目录项与页表项的结构"><a href="#页目录项与页表项的结构" class="headerlink" title="页目录项与页表项的结构"></a>页目录项与页表项的结构</h4><p>页目录项与页表项由相同的结构。<br>|字段|解释|<br>|—|—|<br>|Present标志|若为1，则表示该页表或页在主存中。若执行一个地址转换所需要的页表或页中Present标志为0，分页单元则将该地址放入控制寄存器cr2中，产生14号异常：缺页异常。|<br>|包含页框物理地址最高20位的字段|该字段表示一个页框或页的物理地址|<br>|Accessed标志|分页单元对相应页框进行寻址时就设置该标志。分页单元从不重置该标志，而是交由操作系统去做。|<br>|Dirty|只应用于页表的项中，每当对页框进行写操作时，设置这个标志。与Accessed标志一样，当选中的页被交换出去时，该标志就可以由操作系统使用，分页单元从不重置该标志，由操作系统去做。|<br>|R/W标志|表示页表或页的存取权限|<br>|User/Supervisor标志|含有访问页或页表所需的特权级|<br>|PCD/PWT标志|控制硬件告诉缓存处理页或页表的方式|<br>|Page Size标志|应用于页目录项，设置为1表示页目录项指2MB或4MB的页框|<br>|Global标志|应用于页表，防止常用页从TLB告诉缓存中刷新出去，只有在cr4寄存器的页全局启用标志置位时这个标志才起作用。|</p><h3 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h3><p>从Pentium模型开始，x86引入了扩展分页(extended paging)，它永续页框大小为4MB而不是4KB。可用于大段连续的线性地址转换成相应的物理地址</p><p>扩展分页通过设置页目录项的Page Size标志启用，这种情况下，分页单元将线性地址分为以下2个字段：</p><ol><li>Directory(高10位)</li><li>Offset(剩下22位)</li></ol><p>通过设置cr4寄存器的PSE标志，使得常规分页与扩展分页能够共存。</p><h3 id="硬件保护方案"><a href="#硬件保护方案" class="headerlink" title="硬件保护方案"></a>硬件保护方案</h3><p>有2个级别，User/Supervisor标志控制，0则CPL小于3才能对页寻址；若为1，则任何权限都能对页寻址。</p><p>对存取权限而言，段有三种(读、写、执行)，而页的存取权限只有两种(读、写)，Read/Write标志等于0时，表示只读，否则是可读可写的。</p><blockquote><p>假设进程分配的线性地址范围0x20000000到0x2003ffff之间，若访问范围之外的线性地址，都将产生一个缺页异常，因为范围之外的页表项都为0，因此Present标志都被清0。而范围之内的项，若Present标志为0，则产生一个缺页异常。</p></blockquote><h3 id="物理地址扩展分页机制"><a href="#物理地址扩展分页机制" class="headerlink" title="物理地址扩展分页机制"></a>物理地址扩展分页机制</h3><p>Intel从Pentium Pro开始，将管脚数从32个增加到36个，使得寻址能力能达到2<sup>36</sup>=64GB。</p><blockquote><p>注：详见《深入理解Linux内核》第三版 第二章 - 硬件中的分页</p></blockquote><h3 id="64位下的分页机制"><a href="#64位下的分页机制" class="headerlink" title="64位下的分页机制"></a>64位下的分页机制</h3><p>32位普遍采用两级分页，而两级分页并不适用于64位系统的计算机。</p><p>x86_64的页大小依然是4kb，因此低位依然是12位，但只使用48位进行寻址，采用四级分页，线性地址分级为9+9+9+9+12。</p><h3 id="TLB-转换后援缓冲器、快表"><a href="#TLB-转换后援缓冲器、快表" class="headerlink" title="TLB(转换后援缓冲器、快表)"></a>TLB(转换后援缓冲器、快表)</h3><p>用于加速线性地址转换，当一个线性地址被第一次使用时，从RAM中的页表计算出相应的物理地址。同时，该地址就被放入一个TLB表项中，以便以后对同一个线性地址的引用可以快速地得到转换。</p><p>每个CPU都有自己的TLB，当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都失效。</p><h2 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h2><p>Linux采用了一种适用于32位和64位系统的普通分页模型。2.6.11版本开始，采用了四级分页模型</p><ul><li>页全局目录(Page Global Directory)</li><li>页上级目录(Page Upper Directory)</li><li>页中间目录(Page Middle Directory)</li><li>页表(Page Table)</li></ul><p>在这里并被没有明确指明每一部分的大小，因为不同的计算机体系结构不同。比如，在没有启用物理地址扩展的32位系统中，两级页表足够使用，因此页上级目录与页中间目录位全为0，但序列中仍然存在这两个项，以便同样的代码在32位和64位下都能使用。</p><p><img src="https://tinypng.com/web/output/znfb9mfm5gx5c1xtda55rneq1wg0kr2k/786852A8-8858-45FD-945B-155D23CCD292.png" alt="image"></p><p>启用了物理地址扩展的32位系统，使用三级页表。页全局目录对应x86的目录指针表(PDPT)，取消页上级目录，页中间目录对应x86的页目录。</p><p>最后，64位系统使用三级还是四级分页，取决于硬件对线性地址的位的划分。</p><p>关于Linux分页的详细实现与相关宏见《深入理解Linux内核》第三版</p><h3 id="进程页表"><a href="#进程页表" class="headerlink" title="进程页表"></a>进程页表</h3><p>进程的线性地址空间分成两个部分：</p><ul><li>0x00000000到0xbfffffff的线性地址，无论进程运行在用户态还是内核态都可以寻址</li><li>0xc0000000到0xffffffff的线性地址，只有内核态的进程才能寻址</li></ul><p>用户态所产生的线性地址小于0xc0000000，内核态所产生的地址大于等于0xc0000000。</p><h1 id="三、进程"><a href="#三、进程" class="headerlink" title="三、进程"></a>三、进程</h1><p>Linux中常把进程称为任务(task)或线程(thread)。</p><h2 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p>进程是程序执行时的一个实例，从内核观点来看，进程就是担当分配系统资源(CPU时间、内存等)的实体。</p><p>当一个进程创建时，它几乎与父进程相同。它接受父进程地址空间的一个(逻辑)拷贝，与父进程拥有相同的代码。<strong><em>子进程在被进程创建的下一条指令开始执行与父进程相同的代码</em></strong>。并且，<strong><em>它们各自有独立的数据拷贝(栈和堆)</em></strong>，因此子进程对一个内存单元的修改对父进程是相互不可见的。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>现代Unix系统通常支持多线程应用程序，因此一个进程是由几个用户线程组成，每个线程都代表了进程的一个执行流。</p><h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p>Unix System V和Sun Solaris将线程称作为轻量级进程(LWP-Light-weight process),在这些系统中, 相比较重量级进程, 线程被抽象成一种耗费较少资源, 运行迅速的执行单元。</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><blockquote><p>进程描述符是linux下的pcb</p></blockquote><p>一般来说，能被独立调度的每个执行上下文，都必须拥有它自己的进程描述符；因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的task_struct结构。</p><p>它存储的主要信息如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">标识符:唯一标识符</span><br><span class="line">状态:state字段，在下面详解</span><br><span class="line">优先级:进程优先级</span><br><span class="line">程序计数器:程序的下一条待执行指令地址</span><br><span class="line">内存指针:程序代码和进程相关数据的指针</span><br><span class="line">上下文数据:进程执行时处理器的寄存器中的数据</span><br><span class="line">I/O状态信息:分配给进程的IO设备及文件等。</span><br><span class="line">记账信息:包括处理器时间总和等。</span><br></pre></td></tr></table></figure><p></p><p>进程标识符PID存放在进程描述符的<code>pid</code>字段中，PID被顺序编号，第一个进程的PID值为1。当PID值达到上限值(缺省最大PID号为32767)后，必须循环使用闲置的pid号。</p><p>内核使用进程描述符表示进程的优先级、是否阻塞、地址空间、访问权限等。进程描述符是一个task_struct类型结构体。这里主要介绍其中的两个字段。</p><h4 id="进程状态-state字段"><a href="#进程状态-state字段" class="headerlink" title="进程状态(state字段)"></a>进程状态(state字段)</h4><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>可运行状态(TASK_RUNNING)</td><td>进程要么在CPU上执行，要么准备执行</td></tr><tr><td>可中断的等待状态(TASK_INTERRUPTIBLE)</td><td>进程被挂起(睡眠)，直到某个条件变为真。产生一个硬件中断，释放进程正在等古代的系统资源，或传递一个信号唤醒进程(回到TASK_RUNNING)</td></tr><tr><td>不可中断的等待状态(TASK_UNINTERRUPTIBLE</td><td>该状态一般很少被用到，表示进程一直等待直到一个不能被中断的事件发生。</td></tr><tr><td>暂停状态(TASK_STOPPED)</td><td>进程的执行被暂停，进程收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后进入暂停状态。</td></tr><tr><td>跟踪状态(TASK_TRACED)</td><td>表示进程的执行已被debugger程序暂停，当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态</td></tr></tbody></table><p>还有2个进程状态，既可以被放置在state字段中，也可以放置在exit_state字段中。</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>僵尸状态</td><td>进程的执行被终止，但父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃已死进程描述符中的数据，因为父进程可能还需要它</td></tr><tr><td>僵尸撤销状态</td><td>在wait4()或waitpid()系统调用刚刚被发出时，为防止其他执行线程也执行wait()类系统调用，而将进程状态暂时的改为僵尸撤销状态</td></tr></tbody></table><blockquote><p>如何避免僵尸进程<br></p><ol><li>父进程调用wait()或wait4()<br></li><li>父进程结束，子进程托管给init进程，由init释放僵尸进程的资源<br></li><li>利用两次fork，使得第一次fork创建得到子进程，让子进程创建孙子进程后结束自己。孙子进程失去父进程，自动由init进程托管，这样父进程与孙子进程都由init进程托管，同2。</li></ol></blockquote><h4 id="进程链表-tasks字段"><a href="#进程链表-tasks字段" class="headerlink" title="进程链表(tasks字段)"></a>进程链表(tasks字段)</h4><p>tasks字段是一个<code>list_head</code>类型双向循环链表节点，指向上一个<code>task_struct</code>结构，next指向下一个<code>task_struct</code>结构。因此tasks字段将进程描述符以双向链表形式连接起来。</p><p>进程链表头是<code>init_task</code>描述符，它是所谓的0进程或swapper进程的进程描述符，它的prev指向描述符链表的最后一个元素(循环链表)。</p><h4 id="TASK-RUNNING状态的进程链表-run-list链表"><a href="#TASK-RUNNING状态的进程链表-run-list链表" class="headerlink" title="TASK_RUNNING状态的进程链表(run_list链表)"></a>TASK_RUNNING状态的进程链表(run_list链表)</h4><p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程(即TASK_RUNNING状态的进程)。</p><p>该队列通过一定的调度算法，使得可运行进程按一定权重排列。</p><h4 id="进程间关系相关字段"><a href="#进程间关系相关字段" class="headerlink" title="进程间关系相关字段"></a>进程间关系相关字段</h4><p>进程0和1是由内核创建，进程1(init)时所有进程的祖先。</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>real_parent</td><td>指向创建了p的进程的描述符，若父进程不再存在，指向init进程。</td></tr><tr><td>parent</td><td>指向p当前父进程，通常与real_parent一致，偶尔不同，比如当另一个进程使用监控p的ptrace()时</td></tr><tr><td>children</td><td>链表头部，链表中的所有元素都是P创建的子进程</td></tr><tr><td>sibling</td><td>指向兄弟进程链表中的下一个或前一个，这些兄弟的父进程都是real_parent所指定的进程</td></tr></tbody></table><h4 id="pidhash表以及链表"><a href="#pidhash表以及链表" class="headerlink" title="pidhash表以及链表"></a>pidhash表以及链表</h4><p>有时，内核必须支持从PID得到进程描述符，因此内核维护一个散列表pidhash，其取值范围时0~2<sup>11</sup>-1=2047，当遇到冲突时，使用双向链表解决冲突。</p><h3 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h3><p>除了TASK_RUNNING状态的所有进程被组织在一起，其他状态的进程在被分组处理时，有不同的处理方式，其中</p><ul><li><code>TASK_STOPPED</code>、<code>EXIT_ZOMBIE</code>、<code>EXIT_DEAD</code>状态的进程没有专门建立链表，因为这三种状态的进程访问比较简单，没有被专门分组</li><li><code>TASK_INTERRUPTIBLE</code>、<code>TASK_UNINTERRUPTIBLE</code>状态使用等待队列实现。</li></ul><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待对垒表示一组睡眠的进程，当某一条件变为真，内核将唤醒它。</p><h4 id="进程资源限制"><a href="#进程资源限制" class="headerlink" title="进程资源限制"></a>进程资源限制</h4><p>每个进程都有一组相关的资源限制，指定了进程可使用的系统资源数量。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程。这种行为就是进程切换、任务切换或上下文切换。</p><h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>进程恢复执行前必须装入寄存器的一组数称为硬件上下文。</p><p><strong><em>进程切换只发生在内核态，在执行进程切换前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上。</em></strong></p><h4 id="任务状态段"><a href="#任务状态段" class="headerlink" title="任务状态段"></a>任务状态段</h4><p>x86体系结构中包含了一个特殊的段类型，称为任务状态段(Task State Segment, TSS)。TSS段就是用来存放硬件上下文的，Linux强制为每个CPU创建了一个TSS。</p><p>TSS反应了CPU上的当前进程的特权级，不必要为没有在运行的进程保留TSS。</p><h4 id="执行进程切换的步骤"><a href="#执行进程切换的步骤" class="headerlink" title="执行进程切换的步骤"></a>执行进程切换的步骤</h4><ol><li>切换页全局目录以安装一个新的地址空间(比如，更新cr3寄存器,cr3寄存器的内容是一个物理地址，若是虚拟地址，就有鬼打墙的问题了)</li><li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</li></ol><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>传统Unix操作系统：子进程复制父进程所拥有的资源。</p><p>现代Unix内核：</p><ol><li>写时复制技术(Copy-On-Write)：运行父子进程读相同的物理页，只要两者中一个试图写一个屋里也，内核将该页内容拷贝到信的物理页，并分配给正在写的进程。（详解见第九章）</li><li>轻量级进程：允许父子进程共享进程在内核的很多数据结构，如页表(整个用户态地址空间)、打开文件表及信号处理。</li><li>vfork()系统调用：创建的进程能共享父进程的内存地址空间，防止父进程重写子进程需要的数据，阻塞父进程的执行，一直到子进程退出或执行一个新的程序为止。</li></ol><h4 id="clone-、fork-、vfork-系统调用"><a href="#clone-、fork-、vfork-系统调用" class="headerlink" title="clone()、fork()、vfork()系统调用"></a>clone()、fork()、vfork()系统调用</h4><p>在Linux中，用clone()函数创建轻量级进程，通过参数fn指定新进程所执行的函数，以及指定传递给fn()的数据、flags指定信息、child_stack指定为子进程分配的堆栈等。</p><p>Linux下的fork()调用是使用clone()实现的，flags指定为<code>SIGCHILD</code>信号及所有清0的clone标志，<code>child_stack</code>指定为父进程当前的堆栈指针。因此，父进程和子进程暂时共享同一个用户态堆栈，但是由于存在写时复制机制，通常只要父子进程其中一个试图去写栈，则每个进程的用户态堆栈都将得到各自的一份拷贝。</p><p>vfork()也是clone()实现的，其中flags指定为<code>SIGCHILD</code>以及<code>CLONE_VM</code>和<code>CLONE_VFORK</code>、<code>child_stack</code>等于父进程当前的栈指针。</p><h3 id="撤销进程"><a href="#撤销进程" class="headerlink" title="撤销进程"></a>撤销进程</h3><p>当进程被终止时，通知内核释放进程所拥有的所有资源，包括内存、打开的文件等等。</p><h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>是一种特殊的自旋锁，一种读可重复，写不可重复的锁。读和写操作是互斥的。</p><h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><p>是一种类似读写锁的锁，但是写时依然可以读，读时也可以写，使用一种顺序计数器，写时顺序计数器会自增，读需要重复进行，当计数值相等，则读值操作成功。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>不同于自旋锁，等待时会挂起进程。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>CPU时间被分为片，为每个可运行进程分配一片。</p><p>设计调度时，传统上将进程分为</p><ul><li>I/O受限(频繁使用I/O设备)</li><li>CPU受限(大量使用CPU做计算)</li></ul><p>也有将进程分为</p><ul><li>交互式进程(经常与用户进行交互)</li><li>批处理进程(不需要与用户交互，常在后台运行)</li><li>实时进程(有很强的调度需要)</li></ul><h4 id="进程的抢占"><a href="#进程的抢占" class="headerlink" title="进程的抢占"></a>进程的抢占</h4><p>当一个进程被抢占时，其时间片未使用完，进程状态仍在TASK_RUNNING，当抢占进程结束后，该进程继续恢复执行，并不会挂起。</p><h4 id="时间片长短"><a href="#时间片长短" class="headerlink" title="时间片长短"></a>时间片长短</h4><p>时间片太长会导致系统对其他进程的反应迟钝，使得使用者感受到操作阻碍。</p><p>时间片太短，则系统将花费大量时间在进程切换上。</p><p>Linux选择尽可能长，同时能保持良好响应时间的一个时间片。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>Linux总是按照以下调度算法进行调度</p><ol><li>FIFO(先进先出)<br><br>先进先出的实时进程。当调度程序把CPU分配给进程的时候，进程描述符放在运行队列链表的当前位置。</li><li>RR(时间片轮转)<br><br>当调度程序将CPU分配给进程时，它把该进程的描述符放在运行队列链表的末尾，公平分配CPU时间。</li><li>NORMAL(普通分时进程)</li></ol><h4 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h4><p>普通进程的调度算法可以总结为程序为自己设定一个静态优先级，该静态优先级通过一定算法决定所拥有的时间片，同时，调度程序根据进程的平均睡眠时间结合静态优先级计算得出动态优先级，用以选出下一个交给CPU去执行的进程的优先级。</p><h5 id="静态优先级与基本时间片"><a href="#静态优先级与基本时间片" class="headerlink" title="静态优先级与基本时间片"></a>静态优先级与基本时间片</h5><p>普通进程都有属于自己的静态优先级，数值从100到139，值越大，静态优先级越低。</p><p>基本时间片单位为ms</p><p>当静态优先级&lt;120时，基本时间片=(140-静态优先级)*20</p><p>当静态优先级&gt;=120时，基本时间片=(140-静态优先级)*5</p><p>静态优先级越高，基本时间片就越长。</p><blockquote><p>系统提供接口设置nice值，值为-20~19默认为0，通过计算得出静态优先级，静态优先级对用户不可见。对实时进程来说，直接使用静态优先级。对普通进程来说则使用动态优先级。nice值越大，优先级越低。</p></blockquote><h5 id="动态优先级与平均睡眠时间"><a href="#动态优先级与平均睡眠时间" class="headerlink" title="动态优先级与平均睡眠时间"></a>动态优先级与平均睡眠时间</h5><p>普通进程除了静态优先级还有动态优先级，范围100~139。动态优先级是用于调度程序选择新进程来运行时使用的，它与静态优先级的经验公式如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态优先级=max(100, min(静态优先级 - bonus+5, 139)</span><br></pre></td></tr></table></figure><p></p><p>bonus的值依赖于进程过去的运行情况(平均睡眠时间情况)，范围0~10，值小于5表示降低动态优先级，大于5表示增加动态优先级。</p><p>平均睡眠时间表示进程睡眠状态所消耗的平均纳秒数，平均睡眠时间永远不会大于1s。</p><blockquote><p><a href="https://blog.csdn.net/liuxiaowu19911121/article/details/47070111" target="_blank" rel="noopener">CFS调度算法</a>，使得Linux不需要使用固定的时间片，而灵活的采用<strong><em>实际运行时间</em></strong>来控制进程的运行周期，每一个nice值对应一个权重，根据以下公式计算得出运行时间「分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和」</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.什么是CFS</span><br><span class="line">CFS(Completely Fair Scheduler)是Linux 2.6.23中引入的，针对普通进程（linux中除了普通进程之外还有实时进程，实时进程有专门的实时调度器，其实现在kernel/sched_rt.c）的一个调度器。它的实现在kernel/sched_fair.c。</span><br><span class="line"></span><br><span class="line">CFS的设计原则是，尽力保证CPU资源在所有可运行进程之间平均划分——假如系统中一共有n个可运行进程，那么在任何时刻，每个可执行进程刚好使用了1/n的CPU资源。注意，红色字体意味着这只能是一个理想化的模型，在某一时刻（甚至可以说在每一时刻）肯定会有人超过1/n，有人不足1/n，但是CFS会以此模型为目标尽力去做到。</span><br><span class="line"> </span><br><span class="line">2. vruntime</span><br><span class="line">CFS通过为每个可运行进程维护一个虚拟运行时间vruntime来实现它的目标。vruntime记录了一个可执行进程到当前时刻为止执行的总时间（需要以进程总数n进行归一化，并且根据进程的优先级进行加权）。CFS每次挑选新进程投入运行的时候，采用的策略超级简单：挑选vruntime最小的可运行进程p投入运行，当运行了一段时间dt之后，进程p的vruntime相应增加Dt(vruntime+=Dt)，然后CFS重新选择拥有最小vruntime的进程p&apos;投入运行。</span><br><span class="line"></span><br><span class="line">需要注意的是，上文中vruntime的增加值Dt并不一定等于dt，Dt的计算需要根据进程的优先级也就是nice值进行加权，并对可执行进程总数n进行归一化。例如对同样的dt，高优先级进程的Dt比低优先级进程的Dt小。也就是说高优先级进程的vruntime增加较慢，所以就有更多的机会获得CPU。</span><br><span class="line"></span><br><span class="line">在理想的情况下，CFS应该把时间粒度划分的无限小。当一个可运行进程投入运行时，只运行无限小的时间就交出CPU。这样就可以满足任意时刻每个可运行进程的vruntime都相等的理想目标。实际中当然不可能做到无限小，每个进程的运行时间的最小粒度默认是1ms，再小的话，上下文切换的开销就相当巨大了。</span><br><span class="line"> </span><br><span class="line">3. 可运行进程的维护</span><br><span class="line">CFS如何快速挑选最小vruntime的可运行进程呢？答案是红黑树。红黑树是一种准平衡二叉排序树，也是一种自平衡二叉树，它的search/insert/delete操作的时间复杂度都是O(log(n))，并具有良好地动态特性（相比AVL树）。CFS将所有可运行进程组织成一个红黑树(rbtree)，红黑树的key就是进程的vruntime。通过这个rbtree，CFS可以在O(log(n))时间内找到最小vruntime的进程——也就是最左边的树节点(leftmost)。并且，CFS会将leftmost节点cache起来，以便加速下一次查找。</span><br><span class="line"> </span><br><span class="line">在每一次调度中，CFS从rbtree中挑中leftmost进程投入运行，运行完之后增加这个进程的vruntime值，并将其重新insert到rbtree里（如果这个进程没有被阻塞，即仍然是可运行的）。随着系统不断运行，可运行进程会不断地从rbtree的最左边delete，再被insert到右边，是一个很有趣的过程。</span><br></pre></td></tr></table></figure><h5 id="活动进程与过期进程"><a href="#活动进程与过期进程" class="headerlink" title="活动进程与过期进程"></a>活动进程与过期进程</h5><p>较高静态优先级的普通进程获得了较大的CPU时间片，</p><p>活动进程表示还没有用完时间片的进程，运行被运行</p><p>过期进程表示已经用完时间片，被禁止运行，直到所有活动进程都过期。</p><h4 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h4><p>实时进程与实时优先级相关，值范围1~99，优先级为1则为最高优先级，调度程序总是让优先级高的进程运行。与普通进程不同，实时进程总是被当做活动进程。</p><h3 id="调度所使用的数据结构"><a href="#调度所使用的数据结构" class="headerlink" title="调度所使用的数据结构"></a>调度所使用的数据结构</h3><p>首先，需要知道第三章所提到的进程链表以及运行队列链表，进程链表链接所有进程描述符，运行队列链表链接所有的可运行进程的进程描述符(idle进程除外)。</p><p>每个CPU都拥有一个属于自己的runqueue数据结构，存放运行的进程。</p><p>每个进程描述符内也包括调度相关字段，包括进程的动态优先级、静态优先级、当前状态、平均睡眠时间、最近插入运行队列时间或进程最近一次切换时间、最近一次替换笨进程的进程切换时间、调度类型(FIFO、RR、NORMAL)、时间片还剩的街拍书、实时优先级等。</p><p>父进程剩余的节拍数，会被分成两等份，一份给父进程，一份给子进程。因此，一个进程不能通过创建多个后代来霸占资源，除非它有给自己实时策略的特权。</p><h4 id="常见的批处理作业调度算法"><a href="#常见的批处理作业调度算法" class="headerlink" title="常见的批处理作业调度算法(*)"></a>常见的批处理作业调度算法(*)</h4><h5 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h5><p>按照各个作业进入系统的次序决定调度顺序。</p><h5 id="SJF-短作业优先"><a href="#SJF-短作业优先" class="headerlink" title="SJF(短作业优先)"></a>SJF(短作业优先)</h5><p>优先处理运行时间段的作业，需要用户在提交作业时提交作业运行时间的估计值。</p><h5 id="SRT-最短剩余时间优先"><a href="#SRT-最短剩余时间优先" class="headerlink" title="SRT(最短剩余时间优先)"></a>SRT(最短剩余时间优先)</h5><p>是针对SJF增加了抢占机制的调度算法，若到来的新任务剩余时间片小于当前正在执行的进程，则优先执行。</p><h5 id="RR-时间片轮转"><a href="#RR-时间片轮转" class="headerlink" title="RR(时间片轮转)"></a>RR(时间片轮转)</h5><p>轮转算法一个时间片长度为一个周期产生中断，中断发生时，将当前进程置于就绪队列链尾，基于FCFS选择下一个就绪作业运行。</p><h5 id="HRN-最高响应比优先"><a href="#HRN-最高响应比优先" class="headerlink" title="HRN(最高响应比优先)"></a>HRN(最高响应比优先)</h5><p>该算法是对FCFS以及SJF调度算法的综合平衡<br>响应比=(等待时间+服务时间)/服务时间</p><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><p>RAM一部分被永久分配给内核使用，用来存放内核代码及静态内核数据结构。其余部分，称为动态内存，本章将重点放在如何将主存分配给进程。</p><h2 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h2><p>按X86体系的CPU来说，处理器操作一个页时，会先访问一级缓存，未命中时访问二级缓存，仍未命中时访问主存，主存缺页则访问外存。</p><p>其中，一二级缓存相对透明，因为它完全由MMU负责。</p><h2 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h2><p>Intel的Pentium处理器可以采用两种不同的页框: 4KB和4MB(PAE激活则为2MB)</p><h3 id="页描述符"><a href="#页描述符" class="headerlink" title="页描述符"></a>页描述符</h3><p>内核必须记录每个页框的当前状态，确定页框属于进程或是内核、包含代码或是数据、空闲或是被使用等，就需要借助页描述符这一数据结构。</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>lru</td><td>包含页的最近最少使用的双向链表指针</td></tr><tr><td>flags</td><td>一组标志，也对页框所在的管理区进行编号</td><td>_mapcount</td><td>页框中的页表项数目</td></tr><tr><td>_count</td><td>页框的引用计数</td></tr></tbody></table><ul><li>_count<br><br>如果该字段为-1，则表示相应页框空闲，可悲分配给任一进程或内核本身。大于或等于0则表示被分配给了一个或多个进程。<code>page_count()</code>函数返回<code>_count</code>加1的结果，表示该页的使用者数目。</li></ul><h2 id="内核内存分区"><a href="#内核内存分区" class="headerlink" title="内核内存分区"></a>内核内存分区</h2><p>内核空间的逻辑地址从0xc0000000到0xffffffff,但内核要求能访问所有物理内存。是如何做到的，下面来看内核的内存分区。</p><p>Linux内核在x86 UMA体系结构中分为三个区段</p><ol><li>ZONE_DMA: 低于16Mb内存页框</li><li>ZONE_NORMAL: 16MB~896MB内存页框</li><li>ZONE_HIGHMEM: 包含896MB开始的所有内存页框(896MB~1024MB)</li></ol><p>这三个管理区都映射到线性地址的第4个GB上，前2个区都可以直接访问，而高端内存不可以被内核直接访问，尽管它的线性地址也映射在线性地址的第4个GB上，后面的高端内存一节会详细说明。</p><blockquote><p>64位体系上的<code>ZONE_HIGHMEM</code>区总是空着的</p></blockquote><p>管理区描述符的数据结构保存了管理区中的空闲页数目(<code>free_pages</code>)、保留页数目(<code>pages_min</code>)、该描述符的自旋锁(<code>lock</code>)、活动及非活动链表使用的自旋锁(<code>lru_lock</code>)、以页为单位的管理区总大小(<code>spanned_pages</code>、<code>present_pages</code>)等。</p><h3 id="高端内存"><a href="#高端内存" class="headerlink" title="高端内存"></a>高端内存</h3><p>高端内存的页框有三种不同机制的映射方式</p><ol><li>永久内核映射</li><li>临时内核映射</li><li>非连续内存分配</li></ol><h4 id="永久内核映射"><a href="#永久内核映射" class="headerlink" title="永久内核映射"></a>永久内核映射</h4><p>允许内核建立高端页框到内核地址空间的长期映射，使用主内核页表中一个专门的页表。</p><h4 id="临时内核映射"><a href="#临时内核映射" class="headerlink" title="临时内核映射"></a>临时内核映射</h4><p>每个CPU都有自己的包含13个窗口的集合，在高端内存的任一页框都可以通过一个窗口(保留的页表项)映射到内核地址空间。</p><p>发生一个临时映射时(页表值修改)，以前的映射就被覆盖掉。</p><blockquote><p><a href="https://www.cnblogs.com/wuchanming/p/4360277.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuchanming/p/4360277.html</a></p></blockquote><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li>用户空间(进程)是否有高端内存的概念<br><br>只有内核空间此案有高端内存，用户最多可以访问3G物理内存，而内核进程可以访问所有物理内存。</li><li>64位内核空间有高端内存吗<br><br>64位linux不存在高端内存，因为64位内核空间可以支持超过512G内存。</li><li>用户进程能访问多少物理内存？内核代码能访问多少物理内存？<br><br>32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。</li></ol><h2 id="连续内存区管理"><a href="#连续内存区管理" class="headerlink" title="连续内存区管理"></a>连续内存区管理</h2><p>把内存映射到一组连续的页框，这样会充分利用高速缓存，并获得较低的平均访问时间。详见《深入理解Linux内核(第三版)》</p><p>这里主要讨论操作系统意义上的连续内存管理，并不特指Linux内核所采用的方式</p><p>可能导致两种内存碎片问题</p><ol><li>外碎片(外部不能被使用的空闲内存)</li><li>内碎片(分配的连续内存中未被使用的内存)</li></ol><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>连续内存区管理采用动态分区分配</p><p>这种方式需要内核维护2个数据结构<br></p><ol><li>进程已分配分区情况</li><li>空闲分区情况</li></ol><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>通过对空闲分区的排序来决策下一个进程分配的位置<br></p><ol><li>最先匹配(第一个可以放下的): 按地址排序</li><li>最佳匹配(大小最合适): 顺序查找</li><li>最差匹配(使用最大的区块): 空闲分区从大到小</li></ol><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><ol><li>紧凑: 对等待队列中的进程内存进行紧凑</li><li>分区对换: 抢占处于等待状态进程的分区</li></ol><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>伙伴系统是一个对连续内存分配以及碎片整理的一个的实现。</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p>首先，一个伙伴系统的可分配分区的大小一定为2^n。</p><p>当需要的分区大小为2<sup>n-1</sup>&lt;s&lt;=2<sup>n</sup>时，把大小为2<sup>n</sup>的空闲分区分配给该进程。</p><p>系统将所有空闲块大小和起始地址组织成二位数组，初始状态只有一个大小为2<sup>U</sup>的空闲块。</p><p>分配时，每次在这个二维数组中，从小到大在空闲块中找到最小的可用空闲块。若块过大(s&lt;=2<sup>i-1</sup>)则进行二等分<strong><em>并将2个等分块放入空闲块列表中</em></strong>，直到得到合适大小。</p><p>合并时，两块大小一样并且相邻，且起始地址较低的块地址必须是2<sup>i+1</sup>的整数倍。</p><p>linux中使用到Buddy System的情况，正是在内核的内存分配中。</p><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li>在使能分页机制的情况下，更合适的外碎片整理方法是什么?<br>A.紧凑 B.分区对换 C.都不是<br><br>答案C: 使能分页机制后，粒度较细，每一物理页都可以被使用，不存在外碎片。</li><li>描述伙伴系统(Buddy System)特征正确的是()<br><br>A.多个小空闲空间可合并为大的空闲空间 B.会产生外碎片 C.会产生内碎片 D.都不对<br><br>答案ABC: 伙伴系统依然会存在外碎片。</li><li>如何回收伙伴系统产生的内存块<br><br>回收时，寻找该内存块的伙伴，也就是寻找相邻的空闲内存块，并且低地址的块起始地址满足2^(n+1)且大小相同，则两者为伙伴，可以合并。</li></ol><h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p>其中就有几种方式，如段式、页式、段页式等，非连续内存使得内存的外碎片减少，内存得以被高效率利用。</p><p>详见《深入理解Linux内核(第三版)》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可有效应对大地址空间可采用的页表手段是()</span><br><span class="line">A. 多级页表 B. 反置页表 C. 页寄存器方案 D. 单级页表</span><br><span class="line"></span><br><span class="line">前两个是对的。至于为什么页寄存器不行，老师在Piazza上给出了回复：</span><br><span class="line"></span><br><span class="line">页寄存器和反置页表很像，但它们的一个区别是进程ID在地址转换中的使用。没有进程ID（也就是说页寄存器方案）时，页表占用的空间仍然是与进程数相关的（也就是每个进程对应一组页寄存器？）。反置页表的大小只与物理内存大小，与并发进程数无关。</span><br><span class="line">采用页寄存器的硬件开销会很大。所以现在的通用CPU（包括64位的CPU）没有采用这种方式，大部分还是多级页表。由于有TLB作为缓存，效率还不错。</span><br></pre></td></tr></table></figure><h3 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h3><p>为扩大主存容量，采用虚拟存储技术，将暂时不用的内存移到外存中。</p><p>同时，虚拟存储技术希望由操作系统完成，无需程序员干涉。</p><p>覆盖技术，则需要程序员去实现。</p><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><blockquote><p><strong><em>覆盖操作发生在程序内部</em></strong></p></blockquote><p>将程序划分为若干功能相对独立的模块</p><ul><li>必要部分: 代码和数据常驻内存</li><li>不必要部分: 放在其他程序模块中，用到时装入内存。</li><li>不存在调用关系的模块可相互覆盖，共用同一块内存区域。</li></ul><p>假定模块A和模块B共用了一块内存中，B已经装在入内存，这时程序需要使用A模块，这时需要将模块B从这块共享内存中换出，载入模块A。</p><p>覆盖技术使得编程难度增加，需要划分模块，同时增加了执行时间。</p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><blockquote><p><strong><em>交换操作发生在程序之间</em></strong></p></blockquote><p>增加正在运行或需要运行的程序的内存，也就是将暂时不需要执行的程序放到外存中。</p><p>需要换入和换出两种操作，两种操作的基本单位都是整个进程的地址空间，在后面会讲到以页为单位的交换技术。</p><blockquote><p>何时需要发生交换：内存空间不够或有可能不够时。</p></blockquote><blockquote><p>交换区大小：存放所有用户仅此的所有内存映像拷贝。</p></blockquote><blockquote><p>地址映射重定位：需要采用动态地址映射方式。</p></blockquote><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol><li>时间局部性: 一条指令的一次执行和第二次执行、数据的一次访问和第二次访问，发生在较短时间内。</li><li>空间局部性: 当前指令或数据和即将要访问的指令和数据通常在一个小范围区域内。</li><li>分支局部性: 一条跳转指令的两次执行通常跳到相同的内存位置。</li></ol><p>因此，当一个程序被加载到内存时，只需要将当前指令的对应页或者对应段装入内存。<br><br>若需要的指令或数据不在内存，则产生缺页异常。<br><br>同时，操作系统需要监视内存中暂时不用的页面或段将其移到外存中。</p><h3 id="虚拟页式交换技术"><a href="#虚拟页式交换技术" class="headerlink" title="虚拟页式交换技术"></a>虚拟页式交换技术</h3><p>在页式管理基础上，在程序的逻辑地址空间到物理地址空间转换的过程中，增加了页表的请求和置换操作，做系统则需要增加一个缺页异常处理程序。</p><blockquote><p>当访问页表时，虚拟标志位标志页表项为f时，则表示该页表项不再物理内存上，产生缺页异常。</p></blockquote><p>主要的虚拟存储的页标志位有</p><ol><li>驻留位: 表示该页是否在内存中(1在0不在)</li><li>修改位: 表示在内存中的该页是否被修改过，若修改过，则需要更新外存中相应内容的值(重新将该页写回外存)</li><li>访问位: 表示该页是否被访问过，用于页面置换算法</li><li>保护位: 该页的访问权限(读写)</li></ol><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>缺页异常时的具体处理流程如下：</p><ol><li>读取指定页，指定页表项内的驻留位为0</li><li>触发缺页异常</li><li>查找外存中对应的页</li><li>页面换入空闲页帧，若不存在空闲页帧，通过页面置换算法置换出某一页，驻留位设置为0，并判断对应页是否修改过，若修改过，写回外存。</li><li>页表项驻留位修改为1</li><li>重新执行导致异常的指令</li></ol><p>需要注意的是，操作系统在哪里保存未被映射的页？</p><p>在Linux和Unix中使用一个叫交换区的空间专门用来保存未被映射的页面。其中，有一些页面不需要被放入交换区中，如代码段、共享库。</p><p>有效存储访问时间(EAT)<br><br>EAT = 访存时间*(1-p) + 缺页异常处理时间*缺页率p(1+页修改概率q)</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li>局部页面置换算法: 针对当前进程的页面置换(最优算法、先进先出算法、最近最久未使用算法、时钟算法、最不常用算法)</li><li>全局页面置换算法: 针对所有进程的页面置换(工作集算法、缺页率算法)</li></ul><blockquote><p>页面锁定(frame locking): 必须放置在内存的逻辑页面(操作系统关键代码)、要求响应速度的页面</p></blockquote><h4 id="最优页面置换算法-OPT-optimal"><a href="#最优页面置换算法-OPT-optimal" class="headerlink" title="最优页面置换算法(OPT, optimal)"></a>最优页面置换算法(OPT, optimal)</h4><p><strong><em>基本思路</em></strong><br></p><ul><li>置换在未来最长时间不访问的页面</li></ul><p><strong><em>算法实现</em></strong><br></p><ul><li>缺页时，计算内存中每个逻辑页面的下一次访问时间。</li><li>选择最长时间不访问的页面</li></ul><p><strong><em>算法特征</em></strong><br></p><ul><li>缺页最少，最理想</li><li>实际环境无法实现，因为无法预知每个页面下次访问前的等待时间。</li><li>这种算法虽然不可以实际使用，但可以作为置换算法的性能评价依据</li></ul><h4 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h4><p><strong><em>基本思路</em></strong><br></p><ul><li>选择在内存驻留时间最长的页面进行置换</li></ul><p><strong><em>算法实现</em></strong><br></p><ul><li>维护一个记录所有内存中的逻辑页面的链表</li><li>按驻留内存的事件排序，链首时间最长。</li><li>选择链首的页进行缺页替换。</li></ul><p><strong><em>算法特征</em></strong><br></p><ul><li>实现简单</li><li>性能较差</li><li>进程分配的物理页增加时，缺页更多(Belady现象)</li></ul><h4 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h4><p><strong><em>基本思路</em></strong><br></p><ul><li>选择最长时间没有被使用的页面进行置换</li><li>利用过去预测未来</li></ul><p><strong><em>算法实现</em></strong><br></p><ul><li>将上一次最久未使用的页面进行替换</li></ul><p><strong><em>算法实现方法</em></strong><br></p><ol><li>构造页面链表，维护一个按最近访问顺序排序的页面链表，链首刚被使用过，链尾时最久未使用的页面。访问时，找到相应页面，移到链首。缺页时，置换掉链尾的页面，换入新的页面于链首。</li><li>构造活动页面栈，将页号压入栈顶，并把栈内相同页号抽出，缺页时，置换栈底的页面。</li></ol><h4 id="时钟置换算法-clock"><a href="#时钟置换算法-clock" class="headerlink" title="时钟置换算法(clock)"></a>时钟置换算法(clock)</h4><p><strong><em>基本思路</em></strong><br><br>对页面访问的情况进行大致统计</p><p><strong><em>数据结构</em></strong></p><ul><li>页表项增加一个访问位，描述页面过去一段时间是否访问过。</li><li>各个页面组织成环形链表，指针指向最先调入的页面。</li></ul><p><strong><em>算法</em></strong><br>访问页面时，在页表项记录页面访问情况，缺页时，从指针处开始顺序查找未被访问的页面(第一个)进行置换。</p><p><strong><em>特征</em></strong><br>LRU和FIFO的折中方案, 由于使用环形链表，搜索的过程类似一个时钟的指针在旋转查找可置换项。</p><p><strong><em>实现</em></strong></p><ol><li>页面装入内存，访问位置为0</li><li>访问页面时(读/写)，访问位置为1</li><li>缺页时，从指针当前位置循环检查环形链表。<br>1) 访问位为0，置换该页<br>2) 访问位为1，设置访问位为0，并继续循环搜索直到遇到第一个访问位为0。</li></ol><h4 id="改进的Clock算法"><a href="#改进的Clock算法" class="headerlink" title="改进的Clock算法"></a>改进的Clock算法</h4><p><strong><em>基本思路</em></strong><br>普通时钟算法只考虑了读的情况，如果页面内容有修改，每次必须将被修改的页内容写到外存，处理时间较长。改进的clock算法目标减少修改页的缺页处理开销。</p><p><strong><em>算法</em></strong></p><ul><li>在页面上增加一个修改位，并在访问时进行相应设置(修改过则设置为1，未修改设置为0)。</li><li>缺页时，置换指针所指向的页处理方式有以下几种情况</li></ul><table><thead><tr><th>访问位</th><th>修改位</th><th>处理方式</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>设置访问位为0</td></tr><tr><td>1</td><td>0</td><td>设置访问位为0</td></tr><tr><td>0</td><td>0</td><td>置换该页</td></tr><tr><td>0</td><td>1</td><td>将值写回外存(并不直接开始做，交由系统其他程序去处理)，修改位设为0，不置换该页，指针继续移动</td></tr></tbody></table><h4 id="最不常用置换算法-LFU"><a href="#最不常用置换算法-LFU" class="headerlink" title="最不常用置换算法(LFU)"></a>最不常用置换算法(LFU)</h4><p>对LRU的简化，统计开销较大<br><strong><em>基本思路</em></strong><br>缺页时，置换访问次数最少的页面。</p><p><strong><em>实现</em></strong></p><ol><li>每个页面设置一个访问计数</li><li>访问页面时，访问计数+1</li><li>缺页时，置换计数最小的页面</li></ol><p><strong><em>特征</em></strong></p><ul><li>算法开销大</li><li>开始时频繁使用的页面，在后期很难被置换掉: 计数定期右移</li></ul><p><strong><em>LRU与LFU区别</em></strong><br>一个关注多久未访问、一个关注访问次数。</p><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>采用FIFO等算法时，可能出现可分配的物理页面数增加，缺页次数反而升高的现象。</p><p>原因时，FIFO算法的置换特征与进程访问内存的动态特征矛盾。被置换出去的页面并不一定时进程近期不会访问的。</p><p>例如访问序列：1,2,3,4,1,2,5,1,2,3,4,5<br>|物理页面数|缺页次数|<br>|—|—|<br>|3|9|<br>|4|10|</p><p>Q: 哪些算法不会出现Belady现象？<br><br>LRU<br>例如访问序列：1,2,3,4,1,2,5,1,2,3,4,5<br>|物理页面数|缺页次数|<br>|—|—|<br>|3|10|<br>|4|8|</p><h4 id="LRU、FIFO、Clock算法比较"><a href="#LRU、FIFO、Clock算法比较" class="headerlink" title="LRU、FIFO、Clock算法比较"></a>LRU、FIFO、Clock算法比较</h4><ol><li>两者都是先入先出的思路<br><ul><li>LRU依据页面的最近访问时间排序、需要动态调整顺序。</li><li>FIFO依据进入内存的时间排序，时间固定不变。</li></ul></li><li>LRU可退化成FIFO<br><br>如页面进入内存后没有被访问过，最近访问时间与进入内存的时间相同，退化成了FIFO</li><li>clock是两者的折中<br><ol><li>由于LRU性能好但维护LRU栈开销大，FIFO开销小，但会发生Belady现象。</li><li>Clock在访问页面时，不动态调整页面在链表中的顺序，仅做标记。</li><li>缺页时，clock指针跳过访问过的页面(相当于移到链尾了)</li><li>对于未被访问的页面，clock和LRU(退化为FIFO)算法的表现一样好</li><li>对于被访问过的页面，clock不能记录准确顺序，而LRU算法可以。</li></ol></li></ol></div><footer class="post-footer"><div class="post-tags"><a href="/tags/linux/" rel="tag"># linux</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/dbms/database-indexing.html" rel="next" title="【数据库】索引详解"><i class="fa fa-chevron-left"></i> 【数据库】索引详解</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/network/tcp-ip/network-congestion-control.html" rel="prev" title="【计算机网络】拥塞控制">【计算机网络】拥塞控制 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Jobscn</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:jobscn@foxmail.com" target="_blank" title="邮箱"><i class="fa fa-fw fa-envelope"></i>邮箱</a> </span><span class="links-of-author-item"><a href="https://weibo.com/jobsch" target="_blank" title="微博"><i class="fa fa-fw fa-globe"></i>微博</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、绪论"><span class="nav-number">1.</span> <span class="nav-text">一、绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用户系统"><span class="nav-number">1.1.2.</span> <span class="nav-text">多用户系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户和组"><span class="nav-number">1.1.3.</span> <span class="nav-text">用户和组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">1.1.4.</span> <span class="nav-text">进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微内核"><span class="nav-number">1.2.</span> <span class="nav-text">微内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unix文件系统"><span class="nav-number">1.3.</span> <span class="nav-text">Unix文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">1.3.2.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件模式"><span class="nav-number">1.3.3.</span> <span class="nav-text">文件模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-suid"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1.suid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-sgid"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2.sgid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-sticky"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.sticky</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unix内核概述"><span class="nav-number">1.4.</span> <span class="nav-text">Unix内核概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-内核模式"><span class="nav-number">1.4.1.</span> <span class="nav-text">进程/内核模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程实现"><span class="nav-number">1.4.2.</span> <span class="nav-text">进程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入内核"><span class="nav-number">1.4.3.</span> <span class="nav-text">可重入内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程地址空间"><span class="nav-number">1.4.4.</span> <span class="nav-text">进程地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量与自旋锁"><span class="nav-number">1.4.5.</span> <span class="nav-text">信号量与自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号与进程间通信"><span class="nav-number">1.4.6.</span> <span class="nav-text">信号与进程间通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、内存寻址"><span class="nav-number">2.</span> <span class="nav-text">二、内存寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存地址"><span class="nav-number">2.1.</span> <span class="nav-text">内存地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑地址"><span class="nav-number">2.1.1.</span> <span class="nav-text">逻辑地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性地址-虚拟地址"><span class="nav-number">2.1.2.</span> <span class="nav-text">线性地址(虚拟地址)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理地址"><span class="nav-number">2.1.3.</span> <span class="nav-text">物理地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址转换"><span class="nav-number">2.1.4.</span> <span class="nav-text">地址转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件中的分段"><span class="nav-number">2.2.</span> <span class="nav-text">硬件中的分段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#段选择符与段寄存器"><span class="nav-number">2.2.1.</span> <span class="nav-text">段选择符与段寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#段选择符"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">段选择符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段寄存器"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">段寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段描述符"><span class="nav-number">2.2.2.</span> <span class="nav-text">段描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速访问段描述符"><span class="nav-number">2.2.3.</span> <span class="nav-text">快速访问段描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段单元"><span class="nav-number">2.2.4.</span> <span class="nav-text">分段单元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux中的分段"><span class="nav-number">2.3.</span> <span class="nav-text">Linux中的分段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-GDT"><span class="nav-number">2.3.1.</span> <span class="nav-text">Linux GDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-LDT"><span class="nav-number">2.3.2.</span> <span class="nav-text">Linux LDT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件中的分页"><span class="nav-number">2.4.</span> <span class="nav-text">硬件中的分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分页的概念"><span class="nav-number">2.4.1.</span> <span class="nav-text">分页的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常规分页"><span class="nav-number">2.4.2.</span> <span class="nav-text">常规分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性地址转换为物理地址的流程"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">线性地址转换为物理地址的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页目录项与页表项的结构"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">页目录项与页表项的结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展分页"><span class="nav-number">2.4.3.</span> <span class="nav-text">扩展分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件保护方案"><span class="nav-number">2.4.4.</span> <span class="nav-text">硬件保护方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理地址扩展分页机制"><span class="nav-number">2.4.5.</span> <span class="nav-text">物理地址扩展分页机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64位下的分页机制"><span class="nav-number">2.4.6.</span> <span class="nav-text">64位下的分页机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB-转换后援缓冲器、快表"><span class="nav-number">2.4.7.</span> <span class="nav-text">TLB(转换后援缓冲器、快表)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux中的分页"><span class="nav-number">2.5.</span> <span class="nav-text">Linux中的分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程页表"><span class="nav-number">2.5.1.</span> <span class="nav-text">进程页表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、进程"><span class="nav-number">3.</span> <span class="nav-text">三、进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念详解"><span class="nav-number">3.1.</span> <span class="nav-text">概念详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">3.1.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级进程"><span class="nav-number">3.1.3.</span> <span class="nav-text">轻量级进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程描述符"><span class="nav-number">3.1.4.</span> <span class="nav-text">进程描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程状态-state字段"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">进程状态(state字段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程链表-tasks字段"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">进程链表(tasks字段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TASK-RUNNING状态的进程链表-run-list链表"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">TASK_RUNNING状态的进程链表(run_list链表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间关系相关字段"><span class="nav-number">3.1.4.4.</span> <span class="nav-text">进程间关系相关字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pidhash表以及链表"><span class="nav-number">3.1.4.5.</span> <span class="nav-text">pidhash表以及链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何组织进程"><span class="nav-number">3.1.5.</span> <span class="nav-text">如何组织进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等待队列"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程资源限制"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">进程资源限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程切换"><span class="nav-number">3.1.6.</span> <span class="nav-text">进程切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件上下文"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">硬件上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务状态段"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">任务状态段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行进程切换的步骤"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">执行进程切换的步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建进程"><span class="nav-number">3.1.7.</span> <span class="nav-text">创建进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clone-、fork-、vfork-系统调用"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">clone()、fork()、vfork()系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#撤销进程"><span class="nav-number">3.1.8.</span> <span class="nav-text">撤销进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核同步"><span class="nav-number">3.2.</span> <span class="nav-text">内核同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">3.2.1.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序锁"><span class="nav-number">3.2.2.</span> <span class="nav-text">顺序锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">3.2.3.</span> <span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度"><span class="nav-number">3.3.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度策略"><span class="nav-number">3.3.1.</span> <span class="nav-text">调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的抢占"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">进程的抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间片长短"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">时间片长短</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度算法"><span class="nav-number">3.3.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普通进程的调度"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">普通进程的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态优先级与基本时间片"><span class="nav-number">3.3.2.1.1.</span> <span class="nav-text">静态优先级与基本时间片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态优先级与平均睡眠时间"><span class="nav-number">3.3.2.1.2.</span> <span class="nav-text">动态优先级与平均睡眠时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#活动进程与过期进程"><span class="nav-number">3.3.2.1.3.</span> <span class="nav-text">活动进程与过期进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时进程的调度"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">实时进程的调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度所使用的数据结构"><span class="nav-number">3.3.3.</span> <span class="nav-text">调度所使用的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的批处理作业调度算法"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">常见的批处理作业调度算法(*)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FCFS-先来先服务"><span class="nav-number">3.3.3.1.1.</span> <span class="nav-text">FCFS(先来先服务)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SJF-短作业优先"><span class="nav-number">3.3.3.1.2.</span> <span class="nav-text">SJF(短作业优先)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SRT-最短剩余时间优先"><span class="nav-number">3.3.3.1.3.</span> <span class="nav-text">SRT(最短剩余时间优先)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RR-时间片轮转"><span class="nav-number">3.3.3.1.4.</span> <span class="nav-text">RR(时间片轮转)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HRN-最高响应比优先"><span class="nav-number">3.3.3.1.5.</span> <span class="nav-text">HRN(最高响应比优先)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、内存管理"><span class="nav-number">4.</span> <span class="nav-text">四、内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存层次"><span class="nav-number">4.1.</span> <span class="nav-text">内存层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页框管理"><span class="nav-number">4.2.</span> <span class="nav-text">页框管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#页描述符"><span class="nav-number">4.2.1.</span> <span class="nav-text">页描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核内存分区"><span class="nav-number">4.3.</span> <span class="nav-text">内核内存分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高端内存"><span class="nav-number">4.3.1.</span> <span class="nav-text">高端内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#永久内核映射"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">永久内核映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临时内核映射"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">临时内核映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见问题"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">常见问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续内存区管理"><span class="nav-number">4.4.</span> <span class="nav-text">连续内存区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分区分配"><span class="nav-number">4.4.1.</span> <span class="nav-text">动态分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配策略"><span class="nav-number">4.4.2.</span> <span class="nav-text">分配策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#碎片整理"><span class="nav-number">4.4.3.</span> <span class="nav-text">碎片整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伙伴系统"><span class="nav-number">4.4.4.</span> <span class="nav-text">伙伴系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伙伴系统的实现"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">伙伴系统的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见问题-1"><span class="nav-number">4.4.4.2.</span> <span class="nav-text">常见问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非连续内存区管理"><span class="nav-number">4.5.</span> <span class="nav-text">非连续内存区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储"><span class="nav-number">4.5.1.</span> <span class="nav-text">虚拟存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖技术"><span class="nav-number">4.5.2.</span> <span class="nav-text">覆盖技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换技术"><span class="nav-number">4.5.3.</span> <span class="nav-text">交换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部性原理"><span class="nav-number">4.5.4.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟页式交换技术"><span class="nav-number">4.5.5.</span> <span class="nav-text">虚拟页式交换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺页异常"><span class="nav-number">4.5.6.</span> <span class="nav-text">缺页异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法"><span class="nav-number">4.5.7.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最优页面置换算法-OPT-optimal"><span class="nav-number">4.5.7.1.</span> <span class="nav-text">最优页面置换算法(OPT, optimal)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先进先出算法-FIFO"><span class="nav-number">4.5.7.2.</span> <span class="nav-text">先进先出算法(FIFO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近最久未使用算法-LRU"><span class="nav-number">4.5.7.3.</span> <span class="nav-text">最近最久未使用算法(LRU)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟置换算法-clock"><span class="nav-number">4.5.7.4.</span> <span class="nav-text">时钟置换算法(clock)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进的Clock算法"><span class="nav-number">4.5.7.5.</span> <span class="nav-text">改进的Clock算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最不常用置换算法-LFU"><span class="nav-number">4.5.7.6.</span> <span class="nav-text">最不常用置换算法(LFU)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Belady现象"><span class="nav-number">4.5.7.7.</span> <span class="nav-text">Belady现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU、FIFO、Clock算法比较"><span class="nav-number">4.5.7.8.</span> <span class="nav-text">LRU、FIFO、Clock算法比较</span></a></li></ol></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jobscn</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>