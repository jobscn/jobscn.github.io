<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jobscn&#39;s blog</title>
  
  <subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jobscn.github.io/"/>
  <updated>2019-07-09T03:49:29.727Z</updated>
  <id>https://jobscn.github.io/</id>
  
  <author>
    <name>Jobscn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Golang】学会使用gRPC</title>
    <link href="https://jobscn.github.io/golang/golang-grpc-demo.html"/>
    <id>https://jobscn.github.io/golang/golang-grpc-demo.html</id>
    <published>2019-07-09T03:47:48.000Z</published>
    <updated>2019-07-09T03:49:29.727Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC是由谷歌开源的高性能RPC框架，使用protobuf来定义Service，在使用gRPC之前，需要了解并会使用protobuf。</p><h1 id="使用protobuf定义消息"><a href="#使用protobuf定义消息" class="headerlink" title="使用protobuf定义消息"></a>使用protobuf定义消息</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用brew进行安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure></p><p>protobuf自带了多种语言的生成器，但并没有golang，如果想要在go中使用，还需要安装对应的golang的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#simple" target="_blank" rel="noopener">Protocol Buffers 官方指南</a></p></blockquote><p>具体的定义在官方文件中已经清楚写明，本文就demo进行分析。</p><p>新建一个名为<code>number_work.proto</code>的文件，实现一个除法的gRPC应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package protobuf;</span><br><span class="line"></span><br><span class="line">service NumberWorker &#123;</span><br><span class="line">    rpc div(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    double a = 1;</span><br><span class="line">    double b = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    double result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>第一行指定了使用的语法，新版本的protoc要求必须注明proto的版本号</li><li>使用message定义一个消息，为每个变量指定类型和名字，并分配标识号。</li><li>每个字段都有唯一的标识号，用于在消息的二进制格式中识别各个字段。</li></ul><p>根据官方文档描述的service定义</p><blockquote><p><strong>Defining Services</strong><br>If you want to use your message types with an RPC (Remote Procedure Call) system, you can define an RPC service interface in a .proto file and the protocol buffer compiler will generate service interface code and stubs in your chosen language. So, for example, if you want to define an RPC service with a method that takes your SearchRequest and returns a SearchResponse, you can define it in your .proto file as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service SearchService &#123;</span><br><span class="line">rpc Search (SearchRequest) returns (SearchResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>我们可以类似的定义出需要的service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service NumberWorker &#123;</span><br><span class="line">rpc div(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生成go文件"><a href="#生成go文件" class="headerlink" title="生成go文件"></a>生成go文件</h2><p>在终端键入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. number_work.proto</span><br></pre></td></tr></table></figure></p><p>就可以看到在当前目录下生成了对应的number_work.go</p><p>在生成的go文件中，为我们编写好了go所需要的类型，以及对应的service接口以及一些必要的api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Request struct &#123;</span><br><span class="line">A float64 `protobuf:&quot;varint,1,opt,name=a,proto3&quot; json:&quot;a,omitempty&quot;`</span><br><span class="line">B float64 `protobuf:&quot;varint,2,opt,name=b,proto3&quot; json:&quot;b,omitempty&quot;`</span><br><span class="line">XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;`</span><br><span class="line">XXX_unrecognized []byte `json:&quot;-&quot;`</span><br><span class="line">XXX_sizecache int32 `json:&quot;-&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Response struct &#123;</span><br><span class="line">Result float64 `protobuf:&quot;varint,1,opt,name=result,proto3&quot; json:&quot;result,omitempty&quot;`</span><br><span class="line">XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;`</span><br><span class="line">XXX_unrecognized []byte `json:&quot;-&quot;`</span><br><span class="line">XXX_sizecache int32 `json:&quot;-&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type NumberWorkerClient interface &#123;</span><br><span class="line">Div(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type NumberWorkerServer interface &#123;</span><br><span class="line">Div(context.Context, *Request) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意这里的<code>NumberWorkerServer</code>接口，将在下一节的服务端编写中，为其编写接口实现使其具备功能。</p><h1 id="使用gRPC"><a href="#使用gRPC" class="headerlink" title="使用gRPC"></a>使用gRPC</h1><h2 id="编写服务端"><a href="#编写服务端" class="headerlink" title="编写服务端"></a>编写服务端</h2><p>第一步，服务端同其他服务器网络编程一样，需要使用net.listen监听端口。</p><p>第二步，创建一个grpc server，并使用protobuf生成的go文件中所提供的<code>RegisterNumberWorkerServer</code>方法，将具体的NumberWork实现注册到grpc server中。</p><p>第三步，由grpc server接管刚刚创建的端口监听conn<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/codes"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/status"</span></span><br><span class="line"><span class="string">"jobscn/learn-go/grpc/rpctest/rpcdemo"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumberWork <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(NumberWork)</span> <span class="title">Div</span><span class="params">(ctx context.Context, request *protobuf.Request)</span> <span class="params">(*protobuf.Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> request.B == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.InvalidArgument, <span class="string">"B can't be set to zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;protobuf.Response&#123;</span><br><span class="line">Result: request.A / request.B,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">port := flag.Int(<span class="string">"p"</span>, <span class="number">8088</span>, <span class="string">"set a port for server"</span>)</span><br><span class="line"></span><br><span class="line">conn, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Server running on :%d\n"</span>, *port)</span><br><span class="line"></span><br><span class="line">server := grpc.NewServer()</span><br><span class="line">protobuf.RegisterNumberWorkerServer(server, &amp;NumberWork&#123;&#125;)</span><br><span class="line"></span><br><span class="line">server.Serve(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完成编写后，直接运行服务端程序，等待客户端连接</p><h2 id="编写客户端"><a href="#编写客户端" class="headerlink" title="编写客户端"></a>编写客户端</h2><p>客户端编写比较简单，直接通过grpc.Dial进行连接，并创建对应的rpc client，直接使用client发起rpc调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/gpmgo/gopm/modules/log&quot;</span><br><span class="line">&quot;google.golang.org/grpc&quot;</span><br><span class="line">&quot;jobscn/learn-go/grpc/rpctest/rpcdemo&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">address := flag.String(&quot;h&quot;, &quot;:8088&quot;, &quot;the host to be connected&quot;)</span><br><span class="line">conn, err := grpc.Dial(*address, grpc.WithInsecure())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer conn.Close()</span><br><span class="line"></span><br><span class="line">client := protobuf.NewNumberWorkerClient(conn)</span><br><span class="line"></span><br><span class="line">result, err := client.Div(context.Background(), &amp;protobuf.Request&#123;</span><br><span class="line">A: 5,</span><br><span class="line">B: 0,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;%s&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于服务端已经启动，运行客户端可以直接得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/07/09 11:41:25 rpc error: code = InvalidArgument desc = B can&apos;t be set to zero%!(EXTRA protobuf.Request=&#123;5 0 &#123;&#125; [] 0&#125;)</span><br></pre></td></tr></table></figure><p>发现运行报错，这是由于入参中B为0，我们在编写Div方法时做了错误处理，并使用了grpc提供的<strong>status</strong>包进行错误返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (NumberWork) Div(ctx context.Context, request *protobuf.Request) (*protobuf.Response, error) &#123;</span><br><span class="line">if request.B == 0 &#123;</span><br><span class="line">return nil, status.Errorf(codes.InvalidArgument, &quot;B can&apos;t be set to zero&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &amp;protobuf.Response&#123;</span><br><span class="line">Result: request.A / request.B,</span><br><span class="line">&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改B为2，结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result:2.5</span><br></pre></td></tr></table></figure></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>protobuf与grpc的能力强大，本节只是做一个简单demo以便入门，具体可以参考官方文档</p><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">protocol buffers官方文档</a></p><p><a href="https://grpc.io/docs/guides/concepts/" target="_blank" rel="noopener">grpc 官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gRPC是由谷歌开源的高性能RPC框架，使用protobuf来定义Service，在使用gRPC之前，需要了解并会使用protobuf。&lt;/p&gt;
&lt;h1 id=&quot;使用protobuf定义消息&quot;&gt;&lt;a href=&quot;#使用protobuf定义消息&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="golang" scheme="https://jobscn.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://jobscn.github.io/tags/golang/"/>
    
      <category term="grpc" scheme="https://jobscn.github.io/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>【音视频处理】ffmpeg基础</title>
    <link href="https://jobscn.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/ffmpeg/av-ffmpeg-base.html"/>
    <id>https://jobscn.github.io/音视频技术/ffmpeg/av-ffmpeg-base.html</id>
    <published>2019-03-14T03:20:55.000Z</published>
    <updated>2019-07-08T04:14:52.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、FFMpeg基础内容"><a href="#一、FFMpeg基础内容" class="headerlink" title="一、FFMpeg基础内容"></a>一、FFMpeg基础内容</h1><h2 id="1-1-FFmpeg处理音视频的流程"><a href="#1-1-FFmpeg处理音视频的流程" class="headerlink" title="1.1 FFmpeg处理音视频的流程"></a>1.1 FFmpeg处理音视频的流程</h2><p>FFmpeg对于音视频的处理一共有五个步骤</p><ol><li>输入文件<br>输入文件是具有封装格式的文件，比如flv、mp4等等，需要先将其做demuxer</li><li>编码数据包<br>将输入文件demuxer后，就会得到一系列压缩后的编码数据(包含音频、视频)</li><li>解码后数据帧<br>对编码数据做decoder后就会得到解码后数据帧，是输入文件所封装的原始数据(注: 这里所指的不是真正意义上的原始数据，真正意义所说的原始数据其实指的是直接由mic采集而来的)</li><li>编码数据包<br>对解码后数据帧做一系列处理后，重新编码数据</li><li>输出文件<br>对完成编码的数据，重新封装为目标的格式</li></ol><h2 id="1-2-基本信息查询命令"><a href="#1-2-基本信息查询命令" class="headerlink" title="1.2 基本信息查询命令"></a>1.2 基本信息查询命令</h2><table><thead><tr><th>编号</th><th>命令</th><th>意义</th></tr></thead><tbody><tr><td>1</td><td>-version</td><td>显示版本</td></tr><tr><td>2</td><td>-demuxers</td><td>显示可用的demuxers</td></tr><tr><td>3</td><td>muxers</td><td>显示可用的muxers</td></tr><tr><td>4</td><td>-devices</td><td>显示可用的设备</td></tr><tr><td>5</td><td>-codecs</td><td>显示所有编解码器</td></tr><tr><td>6</td><td>-decoders</td><td>显示可用的解码器</td></tr><tr><td>7</td><td>-encoders</td><td>显示可用的编码器</td></tr><tr><td>8</td><td>-bsfs</td><td>显示比特流filter</td></tr><tr><td>9</td><td>-formats</td><td>显示可用的格式</td></tr><tr><td>10</td><td>-protocols</td><td>显示可用的协议</td></tr><tr><td>11</td><td>-filters</td><td>显示可用的过滤器</td></tr><tr><td>12</td><td>-pix_fmts</td><td>显示可用的像素格式</td></tr><tr><td>13</td><td>-sample_fmts</td><td>显示可用的采样格式</td></tr><tr><td>14</td><td>-layouts</td><td>显示channel名称</td></tr><tr><td>15</td><td>-colors</td><td>显示识别的颜色名称</td></tr></tbody></table><h2 id="1-3-录制命令"><a href="#1-3-录制命令" class="headerlink" title="1.3 录制命令"></a>1.3 录制命令</h2><p>屏幕录制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure></p><ul><li>-f: 指定使用avfoundation采集数据</li><li>-i: 指定从哪儿采集数据, 表示一个文件索引号(1表示屏幕)</li><li>-r: 帧率(实时互动15帧以上、25帧以上比较连续、高清电影60帧)</li></ul><p>声音录制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure></p><ul><li>-i指定索引时, 索引前加<code>:</code>表示音频录制。</li></ul><h2 id="1-4-分解与复用命令"><a href="#1-4-分解与复用命令" class="headerlink" title="1.4 分解与复用命令"></a>1.4 分解与复用命令</h2><p>转换格式命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span><br><span class="line">// 不对编码做处理，仅修改格式</span><br></pre></td></tr></table></figure></p><ul><li>-i: 输入文件</li><li>-vcodec copy: 视频编码处理方式</li><li>-acodec copy: 音频编码处理方式</li></ul><p>抽取视频<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -an -vcodec copy out.h264</span><br></pre></td></tr></table></figure></p><p>抽取音频<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -an -vn copy out.aac</span><br></pre></td></tr></table></figure></p><h2 id="1-5-原始数据处理命令"><a href="#1-5-原始数据处理命令" class="headerlink" title="1.5 原始数据处理命令"></a>1.5 原始数据处理命令</h2><p>这里所指的原始数据指ffmpeg解码后的数据，音频指pcm数据、视频指yuv数据</p><p>使用FFmpeg提取YUV数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br></pre></td></tr></table></figure></p><ul><li>-c:v rawvideo 表示使用原始数据编码</li><li>-pix_fmt yuv420p 表示原始数据采用的像素格式为yuv420p</li></ul><p>使用FFmpeg提取PCM数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vn -ar 44100 -ac2 -f s16le out.pcm</span><br></pre></td></tr></table></figure></p><ul><li>-ar: 表示指定采样率</li><li>-ac: channel 表示声道数</li><li>-f s16le: 表示数据存储格式，s16le表示有符号16bit小端编码</li></ul><h2 id="1-6-滤镜命令"><a href="#1-6-滤镜命令" class="headerlink" title="1.6 滤镜命令"></a>1.6 滤镜命令</h2><p>滤镜是对解码后的数据帧进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A(Decoded Frames) --filter--&gt; B(Filtered Frames) </span><br><span class="line">    B --encoder--&gt; C(Encoded Data)</span><br></pre></td></tr></table></figure></p><p>一条滤镜命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.mov -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy out.mp4</span><br></pre></td></tr></table></figure></p><ul><li>-vf crop: 对视频做crop滤镜, 使用参数<code>in_w-200:in_h-200</code>(宽高各减200)</li></ul><h2 id="1-7-裁剪与合并命令"><a href="#1-7-裁剪与合并命令" class="headerlink" title="1.7 裁剪与合并命令"></a>1.7 裁剪与合并命令</h2><p>视频裁剪命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -ss 00:00:00 -t 10 out.ts</span><br></pre></td></tr></table></figure></p><ul><li>-ss: 开始时间</li><li>-t: 持续时长</li></ul><p>视频合并命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i inputs.txt out.flv</span><br></pre></td></tr></table></figure></p><ul><li>-f concat: 表示进行拼接</li><li>-i inputs.txt: 一个要被合并的文件列表(注:<br>inputs.txt内容格式为 file ‘filename’)</li></ul><h2 id="1-8-图片-视频互转命令"><a href="#1-8-图片-视频互转命令" class="headerlink" title="1.8 图片/视频互转命令"></a>1.8 图片/视频互转命令</h2><p>视频转图片命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure></p><ul><li>-r 1: 转换的帧率，每秒1帧图片</li><li>-f image2: 图片格式为image2</li><li>image-%3d.jpeg: 表示输出格式为image-xxx.jpeg</li></ul><p>图片转视频<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i image-%3d.jpeg out.mp4</span><br></pre></td></tr></table></figure></p><h2 id="1-9-直播相关命令"><a href="#1-9-直播相关命令" class="headerlink" title="1.9 直播相关命令"></a>1.9 直播相关命令</h2><p>直播推流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span><br></pre></td></tr></table></figure></p><ul><li>-c: 推送音视频</li><li>-v: 只推送视频</li><li>-a: 只推送音频</li><li>-f: 推出flv格式</li><li>-re: 减慢帧率速度，让帧率与推流速度保持同步。</li></ul><p>拉流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span><br></pre></td></tr></table></figure></p><ul><li>-c copy: 音视频不做编码(编码直接拷贝)</li></ul><h1 id="二、FFmpeg中的常用函数"><a href="#二、FFmpeg中的常用函数" class="headerlink" title="二、FFmpeg中的常用函数"></a>二、FFmpeg中的常用函数</h1><h2 id="2-1-日志系统"><a href="#2-1-日志系统" class="headerlink" title="2.1 日志系统"></a>2.1 日志系统</h2><p>日志系统需要添加以下头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;libavutil/log.h&gt;</span><br></pre></td></tr></table></figure></p><p>日志的相关函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line">av_log(NULL,AV_LOG_INFO, &quot;%s\n&quot;, op);</span><br></pre></td></tr></table></figure></p><p>常用日志级别</p><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li></ul><h2 id="2-2-文件操作"><a href="#2-2-文件操作" class="headerlink" title="2.2 文件操作"></a>2.2 文件操作</h2><p>删除文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avpriv_io_delete()</span><br></pre></td></tr></table></figure></p><p>重命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avpriv_io_move()</span><br></pre></td></tr></table></figure></p><h2 id="2-3-目录操作"><a href="#2-3-目录操作" class="headerlink" title="2.3 目录操作"></a>2.3 目录操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avio_open_dir()</span><br><span class="line">avio_read_dir()</span><br><span class="line">avio_close_dir()</span><br><span class="line"></span><br><span class="line">avio_free_directory_entry(&amp;entry);</span><br></pre></td></tr></table></figure><p>结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVIODirContext 操作目录上下文</span><br><span class="line">AVIODirEntry 目录项，用于存放文件名，文件大小等信息</span><br></pre></td></tr></table></figure></p><h1 id="三、FFmpeg中的多媒体处理"><a href="#三、FFmpeg中的多媒体处理" class="headerlink" title="三、FFmpeg中的多媒体处理"></a>三、FFmpeg中的多媒体处理</h1><h2 id="3-1-多媒体文件的概念"><a href="#3-1-多媒体文件的概念" class="headerlink" title="3.1 多媒体文件的概念"></a>3.1 多媒体文件的概念</h2><p>多媒体文件是一个容器，在容器中有许多流(Stream/Track)，每种流是由不同的编码器编码的，从流中读出的数据称之为包，一个包中包含着一个或多个帧。</p><p>所有的ffmpeg程序开始前，需要调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_register_all();</span><br></pre></td></tr></table></figure></p><p>将所有常见的协议、编解码库等注册到程序中，<a href="https://blog.csdn.net/leixiaohua1020/article/details/12677129" target="_blank" rel="noopener">源码解析</a></p><h2 id="3-2-多媒体文件的结构体"><a href="#3-2-多媒体文件的结构体" class="headerlink" title="3.2 多媒体文件的结构体"></a>3.2 多媒体文件的结构体</h2><p>多媒体文件上下文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext</span><br></pre></td></tr></table></figure></p><p>流/轨<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVStream</span><br></pre></td></tr></table></figure></p><p>包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVPacket</span><br></pre></td></tr></table></figure></p><p>一个基本的流程就是: 解复用-&gt;获取流-&gt;读数据包-&gt;释放资源</p><p>打开/关闭多媒体文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avformat_open_input(AVForamtContext, filepath, format, options);</span><br><span class="line">avformat_close_input()</span><br></pre></td></tr></table></figure></p><p>输出多媒体信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_dump_format();</span><br></pre></td></tr></table></figure></p><p>一个读取多媒体文件信息的完整示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line">av_register_all();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = avformat_open_input(&amp;fmt_ctx, argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Can't open file: %s\n"</span>, av_err2str(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">av_dump_format(fmt_ctx, <span class="number">0</span>, argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">avformat_close_input(&amp;fmt_ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-3-抽取音频数据"><a href="#3-3-抽取音频数据" class="headerlink" title="3.3 抽取音频数据"></a>3.3 抽取音频数据</h2><p>初始化数据包结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVPacket pkt;</span><br><span class="line">av_init_packet(&amp;pkt)</span><br></pre></td></tr></table></figure></p><p>找到最好的一路流<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_find_best_stream()</span><br></pre></td></tr></table></figure></p><p>从流中读取包时，会增加引用计数，需要成对的调用av_packet_unref<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">av_read_frame() // 读取包</span><br><span class="line">av_packet_unref()</span><br></pre></td></tr></table></figure></p><hr><p>未完待更新</p><h2 id="3-4-…"><a href="#3-4-…" class="headerlink" title="3.4 …"></a>3.4 …</h2><h1 id="四、ffmpeg编解码器"><a href="#四、ffmpeg编解码器" class="headerlink" title="四、ffmpeg编解码器"></a>四、ffmpeg编解码器</h1><h2 id="4-1-H264编码"><a href="#4-1-H264编码" class="headerlink" title="4.1 H264编码"></a>4.1 H264编码</h2><ol><li>查找编码器(<code>avcodec_find_encoder_by_name</code>)</li><li>设置编码参数，并打开编码器(<code>avcodec_open</code>)</li><li>编码(<code>avcodec_encode_video2</code>)</li></ol><h2 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、FFMpeg基础内容&quot;&gt;&lt;a href=&quot;#一、FFMpeg基础内容&quot; class=&quot;headerlink&quot; title=&quot;一、FFMpeg基础内容&quot;&gt;&lt;/a&gt;一、FFMpeg基础内容&lt;/h1&gt;&lt;h2 id=&quot;1-1-FFmpeg处理音视频的流程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="音视频技术" scheme="https://jobscn.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="ffmpeg" scheme="https://jobscn.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/ffmpeg/"/>
    
    
      <category term="音视频技术" scheme="https://jobscn.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="ffmpeg" scheme="https://jobscn.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>【音视频处理】音视频技术基础</title>
    <link href="https://jobscn.github.io/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/av-base.html"/>
    <id>https://jobscn.github.io/音视频技术/av-base.html</id>
    <published>2019-03-11T03:19:26.000Z</published>
    <updated>2019-07-08T04:14:32.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、直播架构"><a href="#一、直播架构" class="headerlink" title="一、直播架构"></a>一、直播架构</h1><p>直播可分为两大类别</p><ol><li>泛娱乐化直播</li><li>实时互动直播</li></ol><h2 id="1-1-泛娱乐化直播"><a href="#1-1-泛娱乐化直播" class="headerlink" title="1.1 泛娱乐化直播"></a>1.1 泛娱乐化直播</h2><p>由泛娱乐化直播通常指对实时性要求不高的直播形式，以娱乐为主，由于对实时性的要求较低，它的架构就相对简单。</p><p>由共享端(主播端)、信令服务器端、流媒体云(CDN网络)、观众端组成。</p><p>假设推拉流采用rtmp流，那么一个主播共享画面到观众的流程基本如下:</p><ol><li>主播端发起创建房间的信令后，在信令服务器中创建房间并返回一个流媒体云地址。</li><li>主播采集音视频数据形成rtmp流，推送到CDN网络中。</li><li>观众从在信令服务器中查看房间某个房间，信令服务器返回一个rtmp流媒体云地址。</li><li>观众从cdn网络拉流得到视频。</li></ol><h2 id="1-2-实时互动直播"><a href="#1-2-实时互动直播" class="headerlink" title="1.2 实时互动直播"></a>1.2 实时互动直播</h2><p>实时互动直播相较于泛娱乐化直播，对信息的实时性要求较高，因此网络延迟要求更小，响应速度更快。因此，它的架构就更加复杂。</p><p>在泛娱乐化直播基础上，在推拉流以及信令服务器与用户之间增加一层自有网络。</p><p>自有网络与用户之间通常采用UDP协议，UDP协议不要求数据必须经过重传重组等等一系列子协议来保证信息准确的到达，用户收到与收不到服务器都按顺序发数据包不做重传，这可以极大的提高信息的实时性。</p><p>使用一个控制中心，控制多个<code>信令/流媒体节点</code>进行负载均衡，使得实时信息的传输具有高可用高容错性。</p><h2 id="1-3-CDN网络"><a href="#1-3-CDN网络" class="headerlink" title="1.3 CDN网络"></a>1.3 CDN网络</h2><p>为解决用户访问资源慢而诞生的技术</p><ol><li>边缘节点: 用户直接从距离最近的边缘节点获取数据</li><li>主干节点(二级节点): 主干节点缓存大量数据，如果边缘节点不存在数据，会从主干节点获取数据。</li><li>源站: CP(内容提供方)将内容放在源站</li></ol><p>如果用户在边缘节点没有获取到数据，将会向上级请求(主干节点)，仍然获取不到时，就会从源站直接请求。</p><p>通常，会使用至少两个主干节点将两个不同ISP的网络连接在一起。例如，一个网络是电信，另一个网络是网通，通过这个方式可以使得电信、网通用户互通。</p><h1 id="二、音频基础"><a href="#二、音频基础" class="headerlink" title="二、音频基础"></a>二、音频基础</h1><p>自然界的一切音频满足三大要素，称为声音的三要素</p><ol><li>频率: 频率也就是音频，儿童 &gt; 女生 &gt; 男生</li><li>振幅: 振动的幅度，表示声音的大小</li><li>波形: 波形代表音色，与材质相关，本质是谐波。</li></ol><h2 id="2-1-声音三要素"><a href="#2-1-声音三要素" class="headerlink" title="2.1 声音三要素"></a>2.1 声音三要素</h2><p>音量也就是振幅，振幅不同表现音量的大小不同，具体波形图如下:<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sapb3scpj31700cedgv.jpg" alt="波形1"></p><p>当振幅相同时，频率的不同使得声音听起来有音调的区别，频率高音调高，也就是越发像儿童和女生，频率低音调低，就更像男生的声音。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g0yn1vy08yj30pi07uwfr.jpg" alt="波形2"></p><p>声音传播正弦波实际上并不是非常平滑的，在波形上可能会有些许畸变，使得每个人的音色听起来都稍许不同。<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4saq6szhbj30pi07u3zo.jpg" alt="谐波"></p><h2 id="2-2-心理声学原理"><a href="#2-2-心理声学原理" class="headerlink" title="2.2 心理声学原理"></a>2.2 心理声学原理</h2><p>人类通常可听到的声波就是20Hz ~ 20kHz, 因此，当我们需要对一个音频做压缩时，就可以根据人类可听声波的范围去相对应的做裁剪， 下面是人类的听觉范围。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4saqir87sj311e05s3yz.jpg" alt="人类听觉范围"></p><p>其他动物听觉/发声范围与人类的比较:<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4saqv4e4kj30x40eajt3.jpg" alt="动物听觉范围"></p><p>可以看得出，比如人类正常的说话声音蝙蝠是听不到的，狗狗能听到更低频率的声音能更快的发现例如地震的灾害等。</p><h2 id="2-3-音频量化"><a href="#2-3-音频量化" class="headerlink" title="2.3 音频量化"></a>2.3 音频量化</h2><p>为了将模拟信号数字化，需要对采集到的模拟信号数字化，具体分为采样、量化和编码三个步骤。下面来看音频量化的过程:<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4sar8vmooj30mo0ms764.jpg" alt="音频量化的过程"></p><p>这里需要讲解几个量化的基本概念:</p><ul><li>采样大小: 一个采样用多少bit存放，常用的是16bit，它所能满足的最大振幅大小是2^16=65535，例如上图，所描述的采用大小就是3bit，可采集的最大振幅是2^3 = 8</li><li>采样率: 指每秒钟的采样频率，通常有8K、16K、32K、44.1K、48K。例如，20KHz的声音使用40K采样率进行采样，声音每次振动被采样40/20=2次。因此，在相同的采样率下，越高频的声音采样次数就会越少，声音的信息就会越不详细。</li><li>声道数: 单声道、双声道、多声道</li></ul><p>有了这几个量化的概念，我们就可以轻松的算出码率， 计算一个PCM音频流的码率，只需要使用<code>采样率×采样大小×声道数</code>即可。</p><p>例如，一个双声道的PCM编码的WAV文件，采样率为44.1KHz、采样大小16bit，那么它的码率就是<code>44.1K*16*2=1411.2Kb/s</code>，对其再做例如AC这种编码压缩后，最终的码率大概是128Kb/s。</p><h2 id="2-4-音频压缩技术"><a href="#2-4-音频压缩技术" class="headerlink" title="2.4 音频压缩技术"></a>2.4 音频压缩技术</h2><p>音频采集后会有大量的冗余信息导致不必要的空间浪费，使用一定程度的压缩是非常有必要的，音频的压缩技术主要有两种。</p><ol><li>消除冗余数据: 将人类不能识别的数据直接删除掉，是有损的。</li><li>哈夫曼无损编码: 是一种无损压缩技术，在消除冗余的基础上再做。</li></ol><p>冗余信息包括如上述说到的人的听觉范围之外的声音，以及被掩蔽掉的音频信号。</p><p>音频信号的掩蔽可分为频域掩蔽和时域掩蔽。</p><ol><li>频域掩蔽效应<br> 1) 实际上20Hz~20KHz之间的频率也不是所有都能被人类听到，还跟其振幅大小有关，例如图上的Threshold in Quiet曲线。<br> 2) 同时当一个突然的大振幅的采样出现时，周围的一些小振幅采样就会被掩蔽，如图中标记的红色矩形和被遮蔽的紫色矩形。  </li></ol><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sarkg5a3j30qs0mm409.jpg" alt="频域遮蔽"></p><ol start="2"><li>时域遮蔽效应<br> 1) 在相同时段内，有一个振幅更大的声音和一个振幅更小的声音，那么振幅更大的声音将遮蔽振幅更小的声音<br> 2) 在一个连续的大振幅声波出现之前50ms左右，和之后100ms~200ms的声音也会被遮蔽，如图的pre和post-marking所示。</li></ol><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4sartbtdmj30x60g6dh7.jpg" alt="时域遮蔽"></p><h3 id="2-4-2-音频编码"><a href="#2-4-2-音频编码" class="headerlink" title="2.4.2 音频编码"></a>2.4.2 音频编码</h3><p>音频编码的过程大体上可以使用下面的图片来表示，量化的编码依赖于心理声学模型、时域到频域转换而来，随后结合辅助数据转化为比特流格式化。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4sasapmugj314k09yaav.jpg" alt="音频编码过程"></p><h2 id="2-5-音频编解码器"><a href="#2-5-音频编解码器" class="headerlink" title="2.5 音频编解码器"></a>2.5 音频编解码器</h2><p>常见的音频编解码器包括OPUS、AAC、Vorbis、Speex、iLBC、AMR、G.711等。</p><p>如下是常见的音频编解码器性能对比图<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sasj8b4cj30pm0jowge.jpg" alt="音频编解码器"></p><p>具体的评测结果显示，各个编解码器的能力中，OPUS &gt; AAC &gt; Vorbis</p><p>通常来说，现代的直播系统里，对实时性要求高时，就会采用Opus。对于泛娱乐化直播、对音质要求高时，采用AAC编码，因为通常采用的是RTMP流，它并不支持Opus。如果需要两个编码器融合，则需要在中间层做互转。如果与电话系统互联，则还需要融合G.722、G.711编码器等等。</p><h3 id="2-5-1-AAC编码"><a href="#2-5-1-AAC编码" class="headerlink" title="2.5.1 AAC编码"></a>2.5.1 AAC编码</h3><p>市面上大量的直播系统都采用AAC编码，同时RTMP流也对AAC有较好的支持，但并不支持Opus编码。</p><p>AAC(Advanced Audio Coding)目的是取代MP3格式，MP3压缩后会产生比较多的损耗。<code>MPEG-4</code>标准诞生后，AAC结合SBR技术与PS技术，编码后所产生的损耗较小但压缩比更高。</p><p>目前常用的规格有AAC LC、AAC HE V1、AAC HE V2三种<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sast4frvj30mg0esabn.jpg" alt="AAC编码版本图1"></p><p>由上图可知，AAC版本间的关系:</p><ol><li>AAC HE V1 = AAC LC + SBR</li><li>AAC HE V2 = AAC HE V1 + PS</li></ol><p>下面来具体看这三个规格的具体描述:</p><ul><li>AAC LC: (Low Complexity) 低复杂度, 码流128k</li><li>AAC HE: AAC LC + SBR(Spectral Band Replication) ，SBR技术将频谱切分开，低频与高频采用不同的手段处理，不但减少了文件大小又很好的保存了音质，码流64k</li><li>AAC HE V2: 增加了PS(Parametric Stereo)技术，双声道分别保存，一个声道保存完整声音、一个声道保存差异。使得两个声道不需要完全相同，更大减少了体积，码流32k;</li></ul><h3 id="2-5-2-AAC编码的主要格式"><a href="#2-5-2-AAC编码的主要格式" class="headerlink" title="2.5.2 AAC编码的主要格式"></a>2.5.2 AAC编码的主要格式</h3><ul><li>ADIF: 这种格式将码流相关信息存储在头部，每次解码从头部获取信息。</li><li>ADTS: 每一个帧加一个同步字，可以在音频流的任何位置开始解码，它类似于数据流格式。使得流式传输的时候，可以实时解析流媒体。</li></ul><h3 id="2-5-3-AAC编解码库"><a href="#2-5-3-AAC编解码库" class="headerlink" title="2.5.3 AAC编解码库"></a>2.5.3 AAC编解码库</h3><p>AAC常见的编解码库，根据编码效率排序如下 Libfdk_AAC &gt; ffmpeg AAC &gt; libfaac &gt; libvo_aacenc</p><h1 id="三、视频基础"><a href="#三、视频基础" class="headerlink" title="三、视频基础"></a>三、视频基础</h1><h2 id="3-1-H264基本概念"><a href="#3-1-H264基本概念" class="headerlink" title="3.1 H264基本概念"></a>3.1 H264基本概念</h2><ul><li>I帧: 关键帧，采用帧内压缩技术</li><li>P帧: 向前参考帧，压缩时只保存差异，差异参考前一个帧，解码时与前一帧相关，属于帧间压缩技术。</li><li>B帧: 双向参考帧，压缩时既参考前一帧也参考后一帧，压缩比率更高，不太适用于实时互动的直播，属于帧间压缩技术。</li></ul><p>下面来看一组帧的构成, 一组帧通常写作GOF(Group of Frame)或称为GOP(Group of Picture)<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4sat41g7sj30xa0d8jta.jpg" alt="GOF"></p><p>GOF有2个需要参考的重要参数集SPS与PPS</p><ul><li>SPS: (Sequence Parameter Set) 序列参数集，存放帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标识等。</li><li>PPS: (Picture Parameter Set) 图像参数集，存放图像相关参数。</li></ul><p>知道了GOF的概念，就可以分析视频花屏或卡帧的原因</p><ol><li>GOP分组的P帧丢失，造成解码端图像发生错误</li><li>为了避免花屏问题的发生，在丢失了P帧或I帧时，就不显示整组GOP的所有帧，直到下一个I帧的到来，这就造成了卡屏。</li></ol><h2 id="3-2-常用的视频编解码器"><a href="#3-2-常用的视频编解码器" class="headerlink" title="3.2 常用的视频编解码器"></a>3.2 常用的视频编解码器</h2><ul><li>x264/x265: 性能比较强，x265的压缩比率更高，直播系统中如果采用x265，解码端CPU的消耗也会更大。</li><li>openH264: 支持SVC技术传输，将图像分层，每加一层图像就更加清晰。这个技术使用软件解码，不使用硬件解码。</li><li>vp8/vp9: vp8对应x264，vp9对应x265</li></ul><h2 id="3-3-H264编码原理"><a href="#3-3-H264编码原理" class="headerlink" title="3.3 H264编码原理"></a>3.3 H264编码原理</h2><h3 id="3-3-1-H264压缩技术"><a href="#3-3-1-H264压缩技术" class="headerlink" title="3.3.1 H264压缩技术"></a>3.3.1 H264压缩技术</h3><p>H264主要的压缩方式有以下几个大类</p><ul><li>帧内预测压缩，解决的是空域数据冗余问题，比如一些人不敏感的色彩、亮度等数据，可以被删除。</li><li>帧间预测压缩，两个帧之间大量数据是相同的，只需要保留差异而不需要每一帧都存放完整内容。</li><li>整数离散余弦变换(DCT)，将空间上的相关性变为频域上无关的数据然后进行量化。将一个复杂的波形图变为多个正弦波，使得数据可以进行量化处理。</li><li>CABAC压缩，类似于哈夫曼编码，但压缩率更高。</li></ul><h4 id="3-3-1-1-宏块划分"><a href="#3-3-1-1-宏块划分" class="headerlink" title="3.3.1.1 宏块划分"></a>3.3.1.1 宏块划分</h4><p>在压缩之前，需要知道如何对图像做一个宏块划分， 比如如图划分一个8x8的宏块<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4satj6qrxj31ae0d4q48.jpg" alt="宏块划分"><br>将图进行划分后，图像变为<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4satxe3g4j30wq0iegnl.jpg" alt="宏块划分结果"><br>划分出了宏块后，还需要再对宏块做子块划分，如下图所示<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4saucgowcj31800cuq4v.jpg" alt="子块划分"><br>如图，子块划分将颜色分开，例如图中的纯蓝色部分，和带黑色部分，纯蓝色部分颜色单一只需要用很小的数据来表示即可，使得压缩比率更大。</p><p>知道了宏块划分和子块划分后，还需要知道帧的分组，比如下图所示<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4sav3uxxwj30v40higmj.jpg" alt="帧分组"><br>一个白色小球在平面内移动，每一帧的移动范围都很小，图像块的变化不大，这样的一组数据就可以划分到一组。</p><h4 id="3-3-1-2-帧间预测压缩技术-组内宏块查找"><a href="#3-3-1-2-帧间预测压缩技术-组内宏块查找" class="headerlink" title="3.3.1.2 帧间预测压缩技术(组内宏块查找)"></a>3.3.1.2 帧间预测压缩技术(组内宏块查找)</h4><p>对划分出来的一个帧分组，做组内宏块查找，如图<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4savdf2anj30v80hw75f.jpg" alt="组内宏块查找"><br>对一张图查找小球出现的位置，相邻图片从该小球附近位置开始查找，对整组图片做相同操作，可以得到小球的运动轨迹的估算。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4saxaexxlj31700cedgv.jpg" alt="运动估算"><br>随后对小球做运动矢量与补偿压缩，即可用很小的数据来表示小球的运动，这就属于帧间预测压缩技术。</p><h4 id="3-3-1-3-帧内压缩技术"><a href="#3-3-1-3-帧内压缩技术" class="headerlink" title="3.3.1.3 帧内压缩技术"></a>3.3.1.3 帧内压缩技术</h4><p>帧内压缩技术对同一张图片内的各个块做划分，将每一种图形用编号表示<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4saxipsffj318k0csmyy.jpg" alt="帧内压缩技术"><br>使用这种方式，预测还原出的图像，带有一定损失<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4saxpcj6bj315c0bwtaq.jpg" alt="预测图像"><br>随后，对预测图像和原图图像做差异计算，最后使用预测的模式信息和残差值来表示一张图。计算机通过预测模式信息还原图像，再使用残差值将图像还原到近似原图，是一种非常高效的压缩方式。</p><h4 id="3-3-1-4-DCT压缩"><a href="#3-3-1-4-DCT压缩" class="headerlink" title="3.3.1.4 DCT压缩"></a>3.3.1.4 DCT压缩</h4><p>通过DCT算法，将数据进行压缩。</p><h4 id="3-3-1-5-VLC压缩"><a href="#3-3-1-5-VLC压缩" class="headerlink" title="3.3.1.5 VLC压缩"></a>3.3.1.5 VLC压缩</h4><p>使用类似哈夫曼编码的技术，将频率高的编码为短码，频率低的编码为长码。<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4saxx5g14j317i0cgdhh.jpg" alt="VLC压缩"></p><p>同时，H264使用的Context Adaptive技术，使得编码能够实时的通过上下文适应进行压缩比更强的压缩。</p><h3 id="3-3-2-H264结构图与码流"><a href="#3-3-2-H264结构图与码流" class="headerlink" title="3.3.2 H264结构图与码流"></a>3.3.2 H264结构图与码流</h3><p>每一帧图像由多个片组成，每个片由多个宏块组成，而宏块又由子块组成。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4say4gb09j30rq0hat9f.jpg" alt="H264结构图"></p><p>H264编码可分层为NAL层、VCL层。</p><ul><li>NAL层: Network Abstraction Layer， 视频数据抽象层，完成视频传输的拆包租包等。</li><li>VCL层: Video Coding Layer，视频数据编码层。</li></ul><p>码流的概念有SODB、RBSP、EBSP、NALU</p><ul><li>SODB: String of Data Bits 原始数据流，长度不一定是8的倍数，它是由VCL层产生的。</li><li>RBSP: Raw Byte Sequence 该算法在SODB末尾位补1，如果字节数不足8，补0。</li><li>EBSP: Encapsulate Byte Sequence Payload 压缩流的开头增加起始位, 比如0x0001、0x000001，如果数据中包含连续的0x00 00则增加一个0x03以防止被当做起始位来处理。</li><li>NALU: NAL Unit, 在EBSP基础上增加一个1字节的头.<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4sayd3f3mj30q40d6abc.jpg" alt="NALU"><br>表示NAL层中一个H264帧是由多个切片组成的，一次传输不能全部完整的传完，需要做切片，<strong>每个H264帧至少包含一个切片</strong></li></ul><p>切片(Slice)与宏块(MarckBlock, MB)的关系<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4sayk6707j30vs0gajsh.jpg" alt="切片与宏块"></p><p>一帧对应切片的关系<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4sayr0niqj30o40himy1.jpg" alt="帧与切片"></p><p>H264码流分层结构图<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sayyla5pj30wr0u0761.jpg" alt="码流分层结构"></p><h3 id="3-3-3-NAL-Unit详解"><a href="#3-3-3-NAL-Unit详解" class="headerlink" title="3.3.3 NAL Unit详解"></a>3.3.3 NAL Unit详解</h3><p>一个NALU头由1个字节组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|0|1|2|3|4|5|6|7|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|F|NRI|  Type   |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure></p><ol><li>F: <code>forbidden_zero_bit</code> 在H264协议中规定该位必须为0</li><li>NRI: <code>nal_ref_idc</code> 2bit, 取00~11表示这个NALU的重要程度，值越大则越重要。如果当前NAL是参考帧的片或是序列参数集、图像参数集这些不可被忽视的重要数据，那么NRI值必须大于0。(一般都不使用这个参数)</li><li>Type: <code>nal_unit_type</code> 表示一个NALU单元的类型 1~12由H264使用、24~31由H264以外的协议使用。  </li></ol><table><thead><tr><th>Type值</th><th>意义</th></tr></thead><tbody><tr><td>0</td><td>没有定义</td></tr><tr><td>1-23</td><td>NAL单元 单个NAL单元包</td></tr><tr><td>1</td><td>不分区，非IDR图像的片</td></tr><tr><td>2</td><td>片分区A</td></tr><tr><td>3</td><td>片分区B</td></tr><tr><td>4</td><td>片分区C</td></tr><tr><td>5</td><td>IDR图像中的片(I帧的片)</td></tr><tr><td>6</td><td>补充增强信息单元（SEI）</td></tr><tr><td>7</td><td>SPS 序列参数集</td></tr><tr><td>8</td><td>PPS 图像参数集</td></tr><tr><td>9</td><td>序列结束</td></tr><tr><td>10</td><td>序列结束</td></tr><tr><td>11</td><td>码流借宿</td></tr><tr><td>12</td><td>填充</td></tr><tr><td>13-23</td><td>保留</td></tr><tr><td>24</td><td>STAP-A, 单一时间的组合包</td></tr><tr><td>25</td><td>STAP-B, 单一时间的组合包</td></tr><tr><td>26</td><td>MTAP16, 多个时间的组合包</td></tr><tr><td>27</td><td>MTAP24, 多个时间的组合包</td></tr><tr><td>28</td><td>FU-A, 分片的单元</td></tr><tr><td>29</td><td>FU-B, 分片的单元</td></tr><tr><td>30-31</td><td>没有定义</td></tr></tbody></table><p>NAL的类型还可分为单一类型、组合类型、分片类型</p><ul><li><p>单一类型: 一个RTP包只包含一个NALU(P帧、B帧)<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sazc8x1xj311u0gm3zv.jpg" alt="单一类型RTP包"></p></li><li><p>组合类型: 一个RTP包包含了多个NALU，类型是24~27，SPS、PPS通常放在一个NALU中，因为字节较小。<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4sazlnowuj30xw0l076g.jpg" alt="组合类型RTP包"></p></li><li><p>分片类型: 一个NALU单元分为多个RTP包，类型是28、29.<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4saztj4d7j311u0gojsy.jpg" alt="分片类型"></p></li></ul><p>可以看出，分片NALU的RTP包头部明显不同，FU indicator表示分片指示符，下面来看看FU Header<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4sb01ban6j30cm07u3yp.jpg" alt="FU Header"></p><ul><li>S: start bit 指明一个分片的开始</li><li>E: end bit 指明一个分片的结束</li><li>R: 未使用，设置为0</li><li>Type 指明分片NAL类型<br>接收数据时，根据分片的RTP包序号进行重组</li></ul><h2 id="3-4-色彩空间"><a href="#3-4-色彩空间" class="headerlink" title="3.4 色彩空间"></a>3.4 色彩空间</h2><h3 id="3-4-1-RGB"><a href="#3-4-1-RGB" class="headerlink" title="3.4.1 RGB"></a>3.4.1 RGB</h3><h3 id="3-4-2-YUV"><a href="#3-4-2-YUV" class="headerlink" title="3.4.2 YUV"></a>3.4.2 YUV</h3><p>YUV(YCbCr)是电视系统采用的一种颜色编码方式</p><ul><li>Y是灰阶，也就是明亮度。</li><li>U和V表示色度，UV用来描述影像色彩及饱和度，它们用于指定像素的颜色。</li></ul><p>常见的YUV格式，比例分别表示Y、U、V所需要的bit数</p><ul><li>YUV4:2:0</li><li>YUV4:2:2</li><li>YUV4:4:4</li></ul><p>现在主要采用的是YUV4:2:0，它并不表示该编码只有Y、Cb两种分量，而没有Cr分量。而是表示，对每行扫描线而言，只有一种色度分量，相邻的扫描行存储不同的色度分量，它以2:1的抽样率存储，如果第一行是4:2:0、那么第二行就是4:0:2、再下一行4:2:0…以此类推。</p><p>YUV的存储格式</p><ul><li>planar(平面存储)<br>  1) I420: YYYYYYYY UU VV (YUV420P)<br>  2) YV12: YYYYYYYY VV UU (YUV420P)</li><li>packed(打包存储)<br>  1) NV12: YYYYYYYY UVUV (YUV420SP)<br>  2) NV21: YYYYYYYY VUVU (YUV420SP)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、直播架构&quot;&gt;&lt;a href=&quot;#一、直播架构&quot; class=&quot;headerlink&quot; title=&quot;一、直播架构&quot;&gt;&lt;/a&gt;一、直播架构&lt;/h1&gt;&lt;p&gt;直播可分为两大类别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泛娱乐化直播&lt;/li&gt;
&lt;li&gt;实时互动直播&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
      <category term="音视频技术" scheme="https://jobscn.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="音视频技术" scheme="https://jobscn.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>【计算机网络】拥塞控制</title>
    <link href="https://jobscn.github.io/network/tcp-ip/network-congestion-control.html"/>
    <id>https://jobscn.github.io/network/tcp-ip/network-congestion-control.html</id>
    <published>2019-03-03T08:15:00.000Z</published>
    <updated>2019-07-08T02:54:36.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是网络拥塞"><a href="#什么是网络拥塞" class="headerlink" title="什么是网络拥塞"></a>什么是网络拥塞</h1><p>网络中过多的数据导致延迟、丢失，这就是网络拥塞</p><p>需要注意的，仅仅增加路由器的缓冲区大小不能解决拥塞问题，反而会导致拥塞加剧。<strong>使得缓存未来得及处理的数据被发送方当做丢失，发起重传、加剧拥塞</strong></p><h1 id="拥塞控制与流量控制的区别"><a href="#拥塞控制与流量控制的区别" class="headerlink" title="拥塞控制与流量控制的区别"></a>拥塞控制与流量控制的区别</h1><p>流量控制只与特定发送方和接收方之间点到点的流量有关，而拥塞控制是一个全局性的问题，保证网络能够承受注入的流量，涉及所有主机和路由器。</p><blockquote><p>滑动窗口协议采用流量控制来防止快速的发送端淹没慢速的接收端。</p></blockquote><p>流量控制是接收端回传给发送端的，使用windows字段表示当前缓冲区可用的窗口大小。</p><p>由于TCP是全双工的，每个端都有一个发送窗口和接收窗口。由对端约束自己的发送窗，自己的接收窗口通过去约束对方的发送窗口来实现。</p><h1 id="拥塞控制的目的"><a href="#拥塞控制的目的" class="headerlink" title="拥塞控制的目的"></a>拥塞控制的目的</h1><p>最大化网络功率</p><p>网络功率 = 负载/延迟；</p><h1 id="网络层拥塞控制"><a href="#网络层拥塞控制" class="headerlink" title="网络层拥塞控制"></a>网络层拥塞控制</h1><p>网络层直接经历拥塞，并且由网络层最终确定如何处理过载数据包</p><p>实际吞吐量 = 吞吐量 - 重传数据量</p><p>根据缓冲区的IP数据包长度及数量，提前估算，告知发送端可能发生拥塞(ECN拥塞通知)，最终还需要TCP去调节实际的流量。</p><p>还有准入控制、载荷脱落等方法。</p><h1 id="传输层拥塞控制"><a href="#传输层拥塞控制" class="headerlink" title="传输层拥塞控制"></a>传输层拥塞控制</h1><p>拥塞产生的根源，控制拥塞最有效的方法是减少传输层注入到网络的负载</p><p>TCP把所有的丢包都当做拥塞发生的信号，TCP的在链路层采用差错控制与重传机制屏蔽传输错误，因此传输层的丢包由于传输错误引起的较少。</p><h2 id="确认时钟-同步时钟"><a href="#确认时钟-同步时钟" class="headerlink" title="确认时钟(同步时钟)"></a>确认时钟(同步时钟)</h2><p>平滑TCP输出流量，非TCP拥塞控制的核心算法。</p><p>发送端利用确认时钟可检测到瓶颈带宽，并以此作为自己的最大数据率，但确认时钟只能发生瓶颈后获得。</p><p>只要数据以不超过同步时钟的速率发送，就不会发生排队或堵塞的情况。</p><p>假设有链路<code>Point-快-Router-慢-Point</code></p><ol><li>发送端在快速链路上以较高数据率发送数据段</li><li>这些数据段以较低数据率通过一条链路</li><li>中间路由器以较慢速度受到来自接收端发回的确认。</li><li>再通过高速链路时，已知瓶颈带宽，发回发送端时不会再进行加速。<br>因此步调变缓的确认序列在经过快速链路时，也不会再进行加速，实现了TCP传输流量的平滑变化。</li></ol><p>其中，发送端根据确认序列的时序计算出瓶颈带宽。</p><p>仅靠确认时钟无法完成拥塞控制的流程</p><h2 id="拥塞避免与慢启动"><a href="#拥塞避免与慢启动" class="headerlink" title="拥塞避免与慢启动"></a>拥塞避免与慢启动</h2><blockquote><p>试探出最大可行的拥塞窗口，使用AIMD法则调整拥塞窗口的大小。</p></blockquote><p>AIMD法则要求拥塞窗口按照加性递增、乘性递减的方式来进行调整。慢启动和拥塞避免对AIMD做了稍许修改。</p><p>慢启动</p><ul><li>慢启动的拥塞窗口按照指数增长，拥塞避免的拥塞窗口按线性增长。</li><li>慢启动: TCP发送方<strong><em>每收到一个确认，发送窗口cwnd+1</em></strong>，<strong>对于接收端而言，每个RTT周期结束后，拥塞窗口就呈指数增长。</strong></li><li>初始拥塞窗口大小为1，最终不超过阈值</li></ul><p>拥塞避免</p><ul><li>线性增长，<strong><em>每个RTT周期结束后，拥塞窗口就加1</em></strong>，最终到达流量窗口的最大值或不设限制。</li><li>发送方每次增加拥塞窗口大小时，根据到达时间间隔重新获得确认时钟。</li></ul><h2 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h2><blockquote><p>RTO 超时重传计时器</p></blockquote><p>快速重传</p><ul><li>滑动窗口按正确顺序到达的、最高序号的数据段进行确认，对后序到来的失序数据段则发送重传。</li><li>如果发送端收到3个重复确认就可以认为已经丢包(出现拥塞)，无需等到RTO计时器超时，丢失的数据段应立即重传，且在RTO计时器超时前发出。(如果超过RTO，确认时钟停止等待重新计算，只能重新启用慢启动 - 乘性递减)</li><li>重复确认不到3个时不重传，因为可能是段失序，为多路径传输而非丢包导致。</li></ul><p>快速恢复(TCP Reno)</p><ul><li>发送方快速重传时，RTO计时器还未超时，确认时钟依然有效，<strong><em>没有必要采用耗时的慢启动来重新调整cwnd(TCP Tahole)，应该采用快速恢复机制。</em></strong></li><li>发生拥塞(丢包)时，(乘性递减规则)将拥塞窗口减小为一半，快速恢复后的窗口大小被设为新的阈值，开始拥塞避免。</li><li>只有在首次启用或RTO计时器超时，才重新进入慢启动。</li></ul><h2 id="选择确认与累计确认机制-连续ARQ协议"><a href="#选择确认与累计确认机制-连续ARQ协议" class="headerlink" title="选择确认与累计确认机制(连续ARQ协议)"></a>选择确认与累计确认机制(连续ARQ协议)</h2><p>累计确认</p><ol><li>按有序数据段的最高序号数据段进行确认</li><li>对后序到来的时序数据段则发送重复确认，并缓存失序但正确的数据段。</li></ol><p>选择确认(实现精确重传)</p><ol><li>发送正确顺序的最高序号确认报文</li><li>利用SACK选项字段进行补充，以通知发送方自己所接受的失序数据段的序号或序号范围。(SACK通常只能容纳3个序号或一个范围)</li></ol><h2 id="TCP-ECN-带拥塞信号"><a href="#TCP-ECN-带拥塞信号" class="headerlink" title="TCP ECN(带拥塞信号)"></a>TCP ECN(带拥塞信号)</h2><p>不是靠检测丢包来获取拥塞信号，而是靠路由器在检测到临近拥塞时，对每个携带TCP段的IP报文打上拥塞标记</p><p>发送端在线性获取拥塞信号ECN后，拥塞控制方式与TCP Reno完全相同</p><p>接收端在收到ECN标记的IP包后，向发送单发送ECE置位的TCP段，以通知发送端出现了拥塞，发送端则返回CWR置位的TCP段来应答。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是网络拥塞&quot;&gt;&lt;a href=&quot;#什么是网络拥塞&quot; class=&quot;headerlink&quot; title=&quot;什么是网络拥塞&quot;&gt;&lt;/a&gt;什么是网络拥塞&lt;/h1&gt;&lt;p&gt;网络中过多的数据导致延迟、丢失，这就是网络拥塞&lt;/p&gt;
&lt;p&gt;需要注意的，仅仅增加路由器的缓冲区大小
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="tcp/ip" scheme="https://jobscn.github.io/categories/network/tcp-ip/"/>
    
    
      <category term="network" scheme="https://jobscn.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】Linux内核基础篇</title>
    <link href="https://jobscn.github.io/linux/linux-core-base.html"/>
    <id>https://jobscn.github.io/linux/linux-core-base.html</id>
    <published>2019-03-01T13:36:00.000Z</published>
    <updated>2019-07-08T03:04:53.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>计算机系统所必须的一系列基本程序集合，称为操作系统。其中，最重要的程序称为内核(kernel)，当操作系统启动时，将内核装入RAM中，内核中包含了操作系统运行所必须的核心过程。</p><p>操作系统必须完成两个主要目标</p><ul><li>与硬件交互</li><li>为用户程序提供执行环境</li></ul><p>一些操作系统，允许用户程序直接与硬件进行交互，如<code>MS-DOS</code>。相反的是，类Unix操作系统把与计算机物理组织相关的所有底层细节对用户程序隐藏。当用户程序想要使用硬件资源时，需要向操作系统发出一个请求，内核对该请求进行评估，如果允许使用这个资源，那么，内核代表用户程序，对相关硬件进行交互。</p><p>为了实施这种机制，现代操作系统依靠特殊的硬件特性来禁止用户程序直接与底层硬件部分进行交互，或禁止直接访问任何物理地址。因此，硬件为CPU引入了两种不同的执行模式：用户程序的非特权模式、内核的特权模式。在Unix中，被称为<code>用户态(User Mode)</code>以及<code>内核态(Kernel Mode)</code>。</p><h3 id="多用户系统"><a href="#多用户系统" class="headerlink" title="多用户系统"></a>多用户系统</h3><p>即指一个能并发和独立地运行两个以至多个用户的若干应用程序的计算机。Unix便是实施系统资源硬件保护的多用户系统。</p><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>在多用户系统中，每个用户在机器上都有私有空间。用户之间，不能互相对私有内容进行访问，操作系统必须保证私有的用户空间仅对拥有者可见。用户使用一个唯一数字来标识，称为<code>UID(User ID)</code></p><p>为了与其他用户有选择的共享资料，每个用户都可以是一个或多个用户组中的成员，组由唯一的标识符表示，称为<code>GID(User Group ID)</code>。</p><p>任何类Unix操作系统都有一个特殊的用户，叫做<code>root</code>，即<code>超级用户(superuser)</code>。系统不对该用户使用常见的保护机制，其能够访问系统中的每一个文件，干涉每一个正在执行的用户程序的活动。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>所有的操作系统都使用这样的一个基本抽象：<code>进程(Process)</code>。一个进程可以定义为<code>程序执行时的一个示例</code>或<code>一个运行程序的&quot;执行上下文&quot;</code>。</p><p>多用户系统必须实施一种执行环境，这种环境允许并发、竞争系统资源(主要是CPU)。这种允许进程并发活动的系统称为<code>多道程序系统(multiprogramming)</code>或<code>多处理系统(multiprocessing)</code>。</p><p>Unix是具有抢占式进程的多处理操作系统。永远有几个系统进程在监视外围设备以及监听系统终端并等待用户登陆。</p><p>类Unix操作系统采用进程/内核模式。每个进程都认为自己是系统的唯一进程，可以独占操作系统所提供的服务。只要进程发出系统调用，硬件就会将特权模式从用户态变为内核态，然后进程开始一个内核过程的执行。这样，操作系统在进程的执行上下文中就起了一定作用，仪满足进程所需。随后，内核将迫使硬件返回用户态，进程继续下一步指令。</p><h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><p>大部分Unix内核是单块结构，每一个内核层都被集成到整个内核程序中，并代表当前进程在内核态下运行。而微内核则相反，通常它的内核只包含很小的一部分函数集，可能只包含几个同步原语、一个简单的调度程序、进程间的通信机制。运行于微内核之上的系统进程，再实现操作系统级的功能，如内存分配程序、设备驱动程序、系统调用处理程序等。</p><p>为了达到微内核理论的许多优点又不至于影响性能，Linux内核提供了模块(module)，模块是一个目标文件，其代码可以在运行时链接到内核或解除链接。通常是一组函数组成，用以实现如文件系统、驱动程序或其他内核上层功能。模块同其他内核函数一样，它代表当前进程在内核态下执行。</p><p>模块有如下几个优点：</p><ul><li>模块化方法</li><li>平台无关性</li><li>节省内存使用（当需要时，链接到内核中）</li><li>无性能损失（目标代码一旦被链入内核，其作用与静态链接的内核目标代码完全等价，当模块被调用时，无需显式的进行消息传递）</li></ul><h2 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Unix文件是以字节序列组成的信息载体，内核不解释文件的内容。从用户的方向上看，文件被组织在一颗树结构的命名空间中。</p><p>除了叶节点，其他的节点都表示目录名。目录节点包含它下面的文件及目录的所有信息。</p><p>Unix的每个进程，都有一个当前工作目录，它属于进程执行上下文，标识出进程所用的当前目录。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Unix的文件内容是由字符序列组成，不包含任何控制信息，如文件长度或文件结束符。</p><p>文件系统处理文件需要的所有信息包含在一个名为<code>索引节点(inode)</code>的数据结构中，每个文件都有自己的索引节点，文件系统用索引节点来标识文件。</p><p>不同的文件系统，都必须至少满足POSIX标准中指定的如下属性：</p><ul><li>文件类型</li><li>与文件相关的硬连接个数</li><li>以字节为单位的文件长度</li><li>设备标识符(即包含文件的设备的标识符)</li><li>在文件系统中标识文件的索引节点号</li><li>文件拥有者的UID</li><li>文件的用户组ID</li><li>几个时间戳（索引节点状态改变的时间、最后访问时间、最后修改时间）</li><li>访问权限与文件模式</li></ul><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><h4 id="1-suid"><a href="#1-suid" class="headerlink" title="1.suid"></a>1.suid</h4><p>进程执行一个文件时，通常保持进程拥有者的UID，也就是执行该可执行文件的用户的UID。当可执行文件设置suid标志位时，进程就获得了该文件拥有者的UID。</p><p>如cat程序，本身属主为root、属组也为root，默认情况下被user1执行，那么该cat进程获得user1的uid及gid。若cat程序设置了suid标志位，那么cat程序被执行后的属主便是cat程序文件的属主，即root。而属组不变，为user1。</p><h4 id="2-sgid"><a href="#2-sgid" class="headerlink" title="2.sgid"></a>2.sgid</h4><p>同上，进程将获得该文件的组id</p><h4 id="3-sticky"><a href="#3-sticky" class="headerlink" title="3.sticky"></a>3.sticky</h4><p>设置该标志位的可执行文件，被执行时将向内核发出一个请求，在程序执行结束后，进程依然被保留在内存中。(这个标志已经过时，现在使用基于代码页共享的其他方法)</p><h2 id="Unix内核概述"><a href="#Unix内核概述" class="headerlink" title="Unix内核概述"></a>Unix内核概述</h2><p>Unix内核提供了应用程序可以运行的执行环境。因此，内核必须实现一组服务及响应接口。应用程序使用这些接口时，通常不会与硬件资源直接交互</p><h3 id="进程-内核模式"><a href="#进程-内核模式" class="headerlink" title="进程/内核模式"></a>进程/内核模式</h3><p>内核本身不是一个进程，而是进程的管理者。进程/内核模式假定：请求内核服务的进程使用所谓系统调用的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户态到内核态的转换。</p><p>Unix其实还包括了几个所谓内核线程的特权进程，被赋予特殊权限的进程。它们有以下几个特点</p><ul><li>运行在内核地址空间</li><li>不与用户直接交互，因此不需要终端设备</li><li>通常随系统启动而被创建，并一直活跃直到系统关闭</li></ul><p>Unix内核所做的并不只是处理系统调用，它包括了以下几种方式激活内核：</p><ul><li>进程调用系统调用</li><li>执行进程的CPU发出异常信号，内核代表异常的进程处理异常。</li><li>外围设备向CPU发出一个中断信号以通知一个事件的发生。(每个中断信号都是由内核中的中断处理程序来处理的，因为外围设备与CPU是异步的，因此中断的发生是不可预知的)</li><li>内核线程被执行(内核线程运行在内核态)</li></ul><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>每个进程由进程描述符表示，该描述符包含进程的当前状态等信息。</p><p><strong><em>当内核暂停一个进程的执行时，会将相关处理器寄存器的内容保存于进程描述符中</em></strong>，这些寄存器包括：</p><ul><li>程序计数器(PC)、栈指针(SP)寄存器</li><li>通用寄存器</li><li>浮点寄存器</li><li>包含CPU状态信息的处理器控制寄存器(处理器状态字)</li><li>用于跟踪进程对RAM访问的内存管理寄存器</li></ul><p>当内核决定恢复执行一个进程时，它将用进程描述符中合适的字段来装载CPU寄存器。因为程序计数器所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。</p><p>当一个进程不在CPU上执行时，它正在等待某一事件。Unix内核可以区分很多等待状态，通常由进程描述符队列实现，每个队列表示等待某一个特定事件的一组进程。</p><h3 id="可重入内核"><a href="#可重入内核" class="headerlink" title="可重入内核"></a>可重入内核</h3><p>所有的Unix内核都是可重入的，若干进程可以同时运行在内核态下。</p><p>对于单处理器系统而言，可能有许多进程在等待CPU或某个IO操作的完成中被阻塞于内核态中。例如，一个进程向内核发出读磁盘请求，进入内核态后，内核代替进程发出读磁盘请求，读磁盘过程交由磁盘控制器完成，并恢复其他进程的执行，而这时，上一个进程进入阻塞状态，直到磁盘控制器的读磁盘操作完成，发出中断通知内核，从而让之前阻塞的进程可以继续。</p><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>通常每个进程运行在它的私有地址空间。用户态下运行的进程涉及到私有栈、数据区、代码区。而当内核态运行时，进程访问内核的数据区和代码区，使用另外的私有栈。</p><p>进程虽然看起来都访问一个私有地址空间，但有时进程间也共享部分地址空间。有时，内核会自动完成使得程序执行时共享部分地址空间，比如一个程序被多次执行时。</p><p>Linux支持mmap()系统调用，允许存放在块设备上的文件或信息的一部分映射到进程的部分地址空间。如果同一个文件被多个进程共享，那么每个共享它的进程的地址空间都将包含它的内存映射。</p><h3 id="信号量与自旋锁"><a href="#信号量与自旋锁" class="headerlink" title="信号量与自旋锁"></a>信号量与自旋锁</h3><p>信号量可以被看作一个对象，组成如下：</p><ul><li>一个整数变量</li><li>一个等待进程的链表</li><li>两个原子方法<code>up()</code>与<code>down()</code></li></ul><p>每个需要被保护的数据结构都有它自己的信号量，初值为1.当内核控制路径想要访问这个数据结构时，他在对应的信号量上执行down()方法，随后判断信号量的值，若不是负数，则允许访问该数据结构。否则，将内核控制路径的进程加入到信号量链表并阻塞该进程。当另一个进程执行up()方法时，允许信号量连标上的一个进程继续执行。</p><p>但信号量并不一定是最佳的解决同步问题的方案，如果修改数据结构所需的时间比较短，信号量可能是抵消的，因为内核必须将进程插入到信号量链表中，然后刮起它。这两种 操作比较费时，在完成这些操作时，其他内核控制路径可能已经释放信号量。</p><p>因此，多处理器操作系统有时使用自旋锁(spin lock)。自旋锁与信号量非常相似，但没有进程链表，但一个进程发现锁被另一个进程锁住时，他就不停的“旋转”，执行一个进程的循环指令，直到锁被打开。</p><p>当然，自旋锁在当处理器环境下时无效的，因为当内核控制路径试图访问一个上锁的数据结构时，他可能开始无休止的循环，最终甚至可能导致系统刮起。</p><h3 id="信号与进程间通信"><a href="#信号与进程间通信" class="headerlink" title="信号与进程间通信"></a>信号与进程间通信</h3><p>Unix信号(signal)提供了将系统事件报告给进程的一种机制，每个事件都有自己的信号编号。有两种系统事件：</p><ul><li>异步通告<br><br>例如，当用户在终端按下中断键(Ctrl-C)时，即向前台进程发出中断信号(SIGINT)</li><li>同步错误或异常<br><br>例如，当进程访问内存非法地址时，内核向这个进程发送一个SIGSEGV信号</li></ul><p>POSIX标准定义了大约20种不同的信号，其中，有两种时允许用户自定义的，可以当作用户态下进程通信和同步的原语机制。一般来说，进程可以对收到的信号作出两种反应：</p><ol><li>忽略信号</li><li>异步的执行一个指定过程(信号处理程序)</li></ol><p>如果不指定某种方式，那么内核就根据信号的编号执行一个默认操作，五种可能的默认操作是：</p><ol><li>终止进程</li><li>将执行上下文和进程地址空间的内容写入一个文件(<code>核心转储(core dump)</code>，并终止进程</li><li>忽略信号</li><li>挂起进程</li><li>如果进程曾被暂停，则恢复执行</li></ol><p>此外，SIGKILL与SIGSTOP信号不能由进程直接处理，也不能被进程忽略。</p><p>大部分Unix内核都采用了这些进程间通信机制：信号量、消息队列、共享内存，它们统称为System V IPC。</p><h1 id="二、内存寻址"><a href="#二、内存寻址" class="headerlink" title="二、内存寻址"></a>二、内存寻址</h1><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>包含在机器语言指令中，用来指定一个操作数或一条指令的地址。每个逻辑地址都由一个段和偏移量组成。</p><h3 id="线性地址-虚拟地址"><a href="#线性地址-虚拟地址" class="headerlink" title="线性地址(虚拟地址)"></a>线性地址(虚拟地址)</h3><p>是一个32位无符号整数，可以用来表示高达4G的内存地址。</p><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>内存单元寻址，物理地址由32位或36位无符号整数表示。</p><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>内存控制单元(MMU)通过一种被称为分段单元的硬件电路把一个逻辑地址转换成线性地址；接着，第二个被称为分页单元的硬件电路把线性单元转换成物理地址。</p><p>[逻辑地址]-&gt;分段单元-&gt;[线性地址]-&gt;分页单元-&gt;[物理地址]</p><p>在多处理器系统中，所有CPU允许共享一片内存，因此，RAM芯片可以被并发访问，但RAM芯片上的读写操作必须串行执行，因此，一种叫做内存仲裁器的硬件电路被放置在总线和每个RAM芯片之间，其作用是，若一个RAM芯片空闲，就允许一个CPU访问、否则延迟这个CPU访问。即使在单处理器上，也存在内存仲裁器，因为单处理器系统中可能包含一种叫做DMA控制器的特殊处理器，CPU与DMA属于并发的关系，因此内存仲裁器在其中也不可缺少。</p><h2 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h2><p>Intel微处理器以两种不同方式执行地址转换，一种称为实模式(real mode)，另一种是保护模式(protected model)。实模式主要用于维持处理器与早起模型的兼容，下面主要描述的是保护模式下的地址转换。</p><h3 id="段选择符与段寄存器"><a href="#段选择符与段寄存器" class="headerlink" title="段选择符与段寄存器"></a>段选择符与段寄存器</h3><p>段的地址通常通过段描述符来获取，其中，指向段描述符的结构称为段选择符。</p><h4 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h4><p>段选择符是一个16位长的字段，构成如下<br>|bit|15 ~ 3|2|1 0|<br>|—|—|—|—|<br>|内容|索引号|TI(表表示器)|RPL(请求者特权级)|</p><p>为了快速方便地找到段选择符，处理器提供了段寄存器，段寄存器的唯一目的就是存放段选择符。寄存器一共6个，同一个段寄存器可用于不同目的，方法是将其值临时保存在内存中，稍后再恢复。</p><blockquote><p>TI表示0:GDT, 1:LDT</p></blockquote><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><table><thead><tr><th>寄存器<br>Segment Registers</th><th>作用</th></tr></thead><tbody><tr><td>cs</td><td>代码段寄存器</td></tr><tr><td>ss</td><td>栈段寄存器</td></tr><tr><td>ds</td><td>数据段寄存器</td></tr><tr><td>es、fs、gs</td><td>普通段寄存器，可以指向任意数据段</td></tr></tbody></table><p>cs寄存器还包含了一个两位的字段，用来表明CPU当前的特权级别，0级表示最高优先级、3级表示最低优先级。对于Linux而言，只有0和3两个级别，即内核态和用户态。</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>每个段由一个8字节的段描述符表示，它描述了段的特征。段描述符放在全局描述符表(Global Descriptor Table, GDT)中或局部描述符表(Local Descriptor Table, LDT)中。</p><p>通常只定义一个GDT、进程还可以自己创建附加的LDT段。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小存放在ldtr控制寄存器中。</p><p>段描述符可以描述一个段的线性地址首字节地址、粒度、段最后一个单元的偏移量、是否为系统段标志、段的类型特征和存取权限、描述符特权级、段存储位置标志(1表示在主存中)、D或B标志(代码/数据段标志)、AVL标志(被Linux忽略)。</p><p>有多不同类型及对应的段描述符，Linux广泛采用的类型是：</p><ul><li>代码段描述符<br><br>它可以放在GDT或LDT中，S标志为1（非系统段）</li><li>数据段描述符<br><br>它可以放在GDT或LDT中，S标志为1（非系统段）。栈段通过一般的数据段实现。</li><li>任务状态段描述符(TSSD)<br><br>该段只用于保存处理器寄存器的内容。只能出现在GDT中，根据相应的进程是否正在CPU上运行，其Type字段的只分别为11或9，S标志置为0。</li><li>局部描述符表描述符(LDTD)<br><br>表示这个段描述符代表一个包含LDT的短，它只出现在GDT中。相应的Type字段的值为2，S标志为0。</li></ul><h3 id="快速访问段描述符"><a href="#快速访问段描述符" class="headerlink" title="快速访问段描述符"></a>快速访问段描述符</h3><p>之前说过，逻辑地址由16位的段选择符和32位的偏移量组成，而段寄存器仅仅存放段选择符，由段选择符指向段描述符。</p><p>为了加速逻辑地址到线性地址的转换，8086处理器提供一种附加的非编程寄存器，提供6个可编程的段寄存器使用，每一个非编程的寄存器含有8字节的段描述符，由相应的段寄存器中的段选择符来制定。当段选择符蓓装入段寄存器时，相应的段描述符就由内存装入对应的非编程CPU寄存器中。处理器就不需要从GDT或LDT中读取，只需要直接引用存放段描述的CPU寄存器即可。晋档段寄存器的内容改变时，才可能重新访问GDT或LDT。</p><blockquote><p><strong><em>读者要点总结</em></strong></p><ol><li>段寄存器存放着段选择符</li><li>段选择符可以方便在GDT/LDT中中定位到指定的段描述表。</li><li>而8086提供额外的非编程寄存器，存放着对应段寄存器所需的段描述符内容。</li><li>段+偏移是逻辑地址，通过段选择符转为到线性地址</li></ol><p>有了非编程寄存器，对应的段寄存器所指向的段线性地址，可直接从非编程寄存器从取出的段描述符中得到。反之，需要从段寄存器中取出段描述符-&gt;访问主存中的段描述表(gdtr/ldtr寄存器)+索引得到指定段描述符-&gt;得到段线性地址。（注：一个段描述符长8字节，因此GDT/LDT的基址+索引*8 = 目标段描述符地址）</p></blockquote><p>GDT的第一项总是设为0，因此空段选择符(索引为0)是会引起处理器异常的，段选择符的长度是13bit，因此最多可存储的段描述符数量为2^13-1 = 8191个。</p><h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>分段单元用于将逻辑地址转换为相应线性地址，具体执行以下操作：</p><ul><li>检查TI字段，判断描述符处在GDT或LDT中(决定下一步使用gdtr还是ldtr中的值)。</li><li>计算段描述符地址(基址+索引)</li><li>使用逻辑地址偏移量+段描述符Base字段的值相加获得线性地址</li></ul><h2 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h2><p>前面讲述的8086中的分段，鼓励程序用将程序划分为逻辑上相关的实体，但Linux只使用比较有限的方式进行分段。分段可以给进程分配不同的线性地址空间，而分页可以将同一个线性地址空间映射到不同的物理空间。与分段相比，Linux更喜欢采用分页方式：</p><ul><li>当所有进程使用相同的段寄存器时，内存管理变得更简单，它们能共享同样的一组线性地址。</li><li>Linux的设计目标之一，是可以移植到绝大多数流行的处理器平台上，而RISC体系结构对分段的支持比较有限。</li></ul><p>2.6版的Linux只有在80x86结构下才需要使用分段。</p><p>所有的Linux进程都使用两对相同的段对指令和数据寻址,一对运行在用户态、一对运行在内核态。</p><p>四个主要的Linux段的段描述符的值<br>|段|Base|G|Limit|S|Type|DPL|D/B|P|<br>|—|—|—|—|—|—|—|—|—|—|<br>|用户代码段|0x00000000|1|0xfffff|1|10|3|1|1||<br>|用户数据段|0x00000000|1|0xfffff|1|2|3|1|1|<br>|内核代码段|0x00000000|1|0xfffff|1|10|0|1|1|<br>|内核数据段|0x00000000|1|0xfffff|1|2|0|1|1|</p><p>相应段选择符由<code>__USER_CS</code>、<code>__USER_DS</code>、<code>__KERNEL_CS</code>、<code>__KERNEL_DS</code>这四个宏分别定义。例如，为了对用户代码段寻址，只需要将<code>__USER_CS</code>产生的值装入cs寄存器即可。</p><p>所有的段都从0x00000000开始，因此，Linux下的逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p><p><strong><em>CPL指当前特权级，反映了进程当前实在用户态还是内核态下，由cs寄存器中的段选择符的RPL字段指定。</em></strong> 特权级改变时，段寄存器需要作出相应的更新。</p><p>例如，CPL=3时，ds寄存器必须含有用户数据段的段选择符、ss寄存器指向用户数据段中的用户栈，而CPL=0时，ds寄存器必须含有内核数据段的段选择符、ss寄存器指向内核数据段中的内核栈。</p><blockquote><p>RPL说明的是进程对段访问的请求权限,意思是当前进程想要的请求权限。</p></blockquote><h3 id="Linux-GDT"><a href="#Linux-GDT" class="headerlink" title="Linux GDT"></a>Linux GDT</h3><p>在单处理器系统下只有一个GDT，在多处理系统中每个CPU对应一个GDT。而所有的GDT放在<code>cpu_gdt_table</code>数组中，所有的GDT的地址和它们的大小都放在<code>cpu_gdt_descr</code>数组中。</p><p>每一个GDT中包含的18个段描述符指向下列的段：</p><ul><li>用户态和内核态下的代码段和数据段共4个。</li><li>任务状态段(TSS)，每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有任务状态段都顺序地放在init_tss数组中。第n个CPU的TSS描述符的Base字段指向init_tss数组中的第n个元素。DPL为0，不允许用户态的进程访问。详细在第三章有说明。</li><li>1个缺省局部描述符表字段，通常被所有进程共享。</li><li>3个局部县城存储(Thread-Local Storage, TLS)段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。</li><li>高级电源管理(AMP)相关的3个段。</li><li>支持即插即用(PnP)功能的BIOS服务程序相关的5个段。</li><li>内核用于处理双重错误异常的特殊TSS段。</li></ul><p>每个处理器都有这样的一个GDT副本。除少数几种情况外，每个GDT副本都放着相同的表项。其中，每个处理器都有它自己的TSS段，因此对应的GDT项不同。LDT和TLS段描述符项可能依赖于CPU正在执行的进程而不同。CPU可能临时修改GDT副本里的某个项，例如调用APM的BIOS例程时可能会出现这种情况。</p><h3 id="Linux-LDT"><a href="#Linux-LDT" class="headerlink" title="Linux LDT"></a>Linux LDT</h3><p>大多数用户态程序不使用局部描述符表，内核定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。wine在执行面向段的Windows应用程序时，通常需要创建自己的局部描述符表。</p><h2 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h2><h3 id="分页的概念"><a href="#分页的概念" class="headerlink" title="分页的概念"></a>分页的概念</h3><p>了解硬件分页前，需要先了解几个概念</p><ol><li>页<br><br>线性地址被分成固定长度为单位的组，这个组就称为页。页内部连续的线性地址呗映射到连续的物理地址中。这样，内核就可以以页为单位指定其物理地址和对应的存取权限。通常，页既指一组线性地址，又指包含在这组地址中的数据。</li><li>页框(页帧)<br><br>分页单元把所有的RAM分成固定长度的页框(page frame, 也翻译做’页帧’， 有时也叫物理页)，每一个页框包含一个页，页框长度与页一致。不同的是，页框是主存的一部分，而页只是一个数据块，可以在页框或者磁盘中。</li><li>页表<br><br>把线性地址映射到物理地址的数据结构称为页表(page table)。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。（从80386开始，x86处理器都支持了分页，设置cr0寄存器的PG标志为0，就不使用分页）</li></ol><blockquote><p>实模式下，CPU的分页功能没有被启用。</p></blockquote><h3 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h3><blockquote><p>从80386开始，Intel处理器分页单元处理4KB的页。</p></blockquote><p>32位的线性地址被分成3个域：</p><ul><li>Directory(目录): 高10位</li><li>Table(页表): 中间10位</li><li>Offset(偏移): 低12位</li></ul><p>线性地址转换分两步，分别使用两种转换表</p><ol><li>页目录表</li><li>页表</li></ol><p>每个活动进程必须由一个分配给它的页目录，但并不需要马上为进程的所有页表分配RAM，只在进程需要时才给页表分配RAM。</p><blockquote><p>在页表上增加一个页目录的目的在于减少每个进程的页表所需的RAM数量，如果只单纯使用页表，那将有2<sup>20</sup>个表项，每项需要4字节，则需要4MB RAM。</p></blockquote><p>由于Offset是12位长，因此每一页可含有2<sup>12</sup> = 4096字节的数据。</p><h4 id="线性地址转换为物理地址的流程"><a href="#线性地址转换为物理地址的流程" class="headerlink" title="线性地址转换为物理地址的流程"></a>线性地址转换为物理地址的流程</h4><ol><li>正在使用的页目录的物理地址存放在控制寄存器cr3中</li><li>线性地址中的Directory字段决定使用页目录中的哪一个目录项</li><li>得到了目录项再由Table字段选择使用哪一个表项(页)</li><li>而表项(页)中含有所在页框的物理地址</li><li>最后由Offset决定在这个页框内的相对位置。</li></ol><p>页目录与页表都是10位长，各有1024项。因此，一个页目录可以寻址到1024*1024*4096=2<sup>32</sup>个存储单元，这和32位地址的要求刚好符合。</p><h4 id="页目录项与页表项的结构"><a href="#页目录项与页表项的结构" class="headerlink" title="页目录项与页表项的结构"></a>页目录项与页表项的结构</h4><p>页目录项与页表项由相同的结构。<br>|字段|解释|<br>|—|—|<br>|Present标志|若为1，则表示该页表或页在主存中。若执行一个地址转换所需要的页表或页中Present标志为0，分页单元则将该地址放入控制寄存器cr2中，产生14号异常：缺页异常。|<br>|包含页框物理地址最高20位的字段|该字段表示一个页框或页的物理地址|<br>|Accessed标志|分页单元对相应页框进行寻址时就设置该标志。分页单元从不重置该标志，而是交由操作系统去做。|<br>|Dirty|只应用于页表的项中，每当对页框进行写操作时，设置这个标志。与Accessed标志一样，当选中的页被交换出去时，该标志就可以由操作系统使用，分页单元从不重置该标志，由操作系统去做。|<br>|R/W标志|表示页表或页的存取权限|<br>|User/Supervisor标志|含有访问页或页表所需的特权级|<br>|PCD/PWT标志|控制硬件告诉缓存处理页或页表的方式|<br>|Page Size标志|应用于页目录项，设置为1表示页目录项指2MB或4MB的页框|<br>|Global标志|应用于页表，防止常用页从TLB告诉缓存中刷新出去，只有在cr4寄存器的页全局启用标志置位时这个标志才起作用。|</p><h3 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h3><p>从Pentium模型开始，x86引入了扩展分页(extended paging)，它永续页框大小为4MB而不是4KB。可用于大段连续的线性地址转换成相应的物理地址</p><p>扩展分页通过设置页目录项的Page Size标志启用，这种情况下，分页单元将线性地址分为以下2个字段：</p><ol><li>Directory(高10位)</li><li>Offset(剩下22位)</li></ol><p>通过设置cr4寄存器的PSE标志，使得常规分页与扩展分页能够共存。</p><h3 id="硬件保护方案"><a href="#硬件保护方案" class="headerlink" title="硬件保护方案"></a>硬件保护方案</h3><p>有2个级别，User/Supervisor标志控制，0则CPL小于3才能对页寻址；若为1，则任何权限都能对页寻址。 </p><p>对存取权限而言，段有三种(读、写、执行)，而页的存取权限只有两种(读、写)，Read/Write标志等于0时，表示只读，否则是可读可写的。</p><blockquote><p>假设进程分配的线性地址范围0x20000000到0x2003ffff之间，若访问范围之外的线性地址，都将产生一个缺页异常，因为范围之外的页表项都为0，因此Present标志都被清0。而范围之内的项，若Present标志为0，则产生一个缺页异常。</p></blockquote><h3 id="物理地址扩展分页机制"><a href="#物理地址扩展分页机制" class="headerlink" title="物理地址扩展分页机制"></a>物理地址扩展分页机制</h3><p>Intel从Pentium Pro开始，将管脚数从32个增加到36个，使得寻址能力能达到2<sup>36</sup>=64GB。</p><blockquote><p>注：详见《深入理解Linux内核》第三版 第二章 - 硬件中的分页</p></blockquote><h3 id="64位下的分页机制"><a href="#64位下的分页机制" class="headerlink" title="64位下的分页机制"></a>64位下的分页机制</h3><p>32位普遍采用两级分页，而两级分页并不适用于64位系统的计算机。</p><p>x86_64的页大小依然是4kb，因此低位依然是12位，但只使用48位进行寻址，采用四级分页，线性地址分级为9+9+9+9+12。</p><h3 id="TLB-转换后援缓冲器、快表"><a href="#TLB-转换后援缓冲器、快表" class="headerlink" title="TLB(转换后援缓冲器、快表)"></a>TLB(转换后援缓冲器、快表)</h3><p>用于加速线性地址转换，当一个线性地址被第一次使用时，从RAM中的页表计算出相应的物理地址。同时，该地址就被放入一个TLB表项中，以便以后对同一个线性地址的引用可以快速地得到转换。</p><p>每个CPU都有自己的TLB，当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都失效。</p><h2 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h2><p>Linux采用了一种适用于32位和64位系统的普通分页模型。2.6.11版本开始，采用了四级分页模型</p><ul><li>页全局目录(Page Global Directory)</li><li>页上级目录(Page Upper Directory)</li><li>页中间目录(Page Middle Directory)</li><li>页表(Page Table)</li></ul><p>在这里并被没有明确指明每一部分的大小，因为不同的计算机体系结构不同。比如，在没有启用物理地址扩展的32位系统中，两级页表足够使用，因此页上级目录与页中间目录位全为0，但序列中仍然存在这两个项，以便同样的代码在32位和64位下都能使用。</p><p><img src="https://tinypng.com/web/output/znfb9mfm5gx5c1xtda55rneq1wg0kr2k/786852A8-8858-45FD-945B-155D23CCD292.png" alt="image"></p><p>启用了物理地址扩展的32位系统，使用三级页表。页全局目录对应x86的目录指针表(PDPT)，取消页上级目录，页中间目录对应x86的页目录。</p><p>最后，64位系统使用三级还是四级分页，取决于硬件对线性地址的位的划分。</p><p>关于Linux分页的详细实现与相关宏见《深入理解Linux内核》第三版</p><h3 id="进程页表"><a href="#进程页表" class="headerlink" title="进程页表"></a>进程页表</h3><p>进程的线性地址空间分成两个部分：</p><ul><li>0x00000000到0xbfffffff的线性地址，无论进程运行在用户态还是内核态都可以寻址</li><li>0xc0000000到0xffffffff的线性地址，只有内核态的进程才能寻址</li></ul><p>用户态所产生的线性地址小于0xc0000000，内核态所产生的地址大于等于0xc0000000。</p><h1 id="三、进程"><a href="#三、进程" class="headerlink" title="三、进程"></a>三、进程</h1><p>Linux中常把进程称为任务(task)或线程(thread)。</p><h2 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p>进程是程序执行时的一个实例，从内核观点来看，进程就是担当分配系统资源(CPU时间、内存等)的实体。</p><p>当一个进程创建时，它几乎与父进程相同。它接受父进程地址空间的一个(逻辑)拷贝，与父进程拥有相同的代码。<strong><em>子进程在被进程创建的下一条指令开始执行与父进程相同的代码</em></strong>。并且，<strong><em>它们各自有独立的数据拷贝(栈和堆)</em></strong>，因此子进程对一个内存单元的修改对父进程是相互不可见的。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>现代Unix系统通常支持多线程应用程序，因此一个进程是由几个用户线程组成，每个线程都代表了进程的一个执行流。</p><h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p>Unix System V和Sun Solaris将线程称作为轻量级进程(LWP-Light-weight process),在这些系统中, 相比较重量级进程, 线程被抽象成一种耗费较少资源, 运行迅速的执行单元。</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><blockquote><p>进程描述符是linux下的pcb</p></blockquote><p>一般来说，能被独立调度的每个执行上下文，都必须拥有它自己的进程描述符；因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的task_struct结构。</p><p>它存储的主要信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">标识符:唯一标识符</span><br><span class="line">状态:state字段，在下面详解</span><br><span class="line">优先级:进程优先级</span><br><span class="line">程序计数器:程序的下一条待执行指令地址</span><br><span class="line">内存指针:程序代码和进程相关数据的指针</span><br><span class="line">上下文数据:进程执行时处理器的寄存器中的数据</span><br><span class="line">I/O状态信息:分配给进程的IO设备及文件等。</span><br><span class="line">记账信息:包括处理器时间总和等。</span><br></pre></td></tr></table></figure></p><p>进程标识符PID存放在进程描述符的<code>pid</code>字段中，PID被顺序编号，第一个进程的PID值为1。当PID值达到上限值(缺省最大PID号为32767)后，必须循环使用闲置的pid号。</p><p>内核使用进程描述符表示进程的优先级、是否阻塞、地址空间、访问权限等。进程描述符是一个task_struct类型结构体。这里主要介绍其中的两个字段。</p><h4 id="进程状态-state字段"><a href="#进程状态-state字段" class="headerlink" title="进程状态(state字段)"></a>进程状态(state字段)</h4><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>可运行状态(TASK_RUNNING)</td><td>进程要么在CPU上执行，要么准备执行</td></tr><tr><td>可中断的等待状态(TASK_INTERRUPTIBLE)</td><td>进程被挂起(睡眠)，直到某个条件变为真。产生一个硬件中断，释放进程正在等古代的系统资源，或传递一个信号唤醒进程(回到TASK_RUNNING)</td></tr><tr><td>不可中断的等待状态(TASK_UNINTERRUPTIBLE</td><td>该状态一般很少被用到，表示进程一直等待直到一个不能被中断的事件发生。</td></tr><tr><td>暂停状态(TASK_STOPPED)</td><td>进程的执行被暂停，进程收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后进入暂停状态。</td></tr><tr><td>跟踪状态(TASK_TRACED)</td><td>表示进程的执行已被debugger程序暂停，当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态</td></tr></tbody></table><p>还有2个进程状态，既可以被放置在state字段中，也可以放置在exit_state字段中。</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>僵尸状态</td><td>进程的执行被终止，但父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃已死进程描述符中的数据，因为父进程可能还需要它</td></tr><tr><td>僵尸撤销状态</td><td>在wait4()或waitpid()系统调用刚刚被发出时，为防止其他执行线程也执行wait()类系统调用，而将进程状态暂时的改为僵尸撤销状态</td></tr></tbody></table><blockquote><p>如何避免僵尸进程<br></p><ol><li>父进程调用wait()或wait4()<br></li><li>父进程结束，子进程托管给init进程，由init释放僵尸进程的资源<br></li><li>利用两次fork，使得第一次fork创建得到子进程，让子进程创建孙子进程后结束自己。孙子进程失去父进程，自动由init进程托管，这样父进程与孙子进程都由init进程托管，同2。</li></ol></blockquote><h4 id="进程链表-tasks字段"><a href="#进程链表-tasks字段" class="headerlink" title="进程链表(tasks字段)"></a>进程链表(tasks字段)</h4><p>tasks字段是一个<code>list_head</code>类型双向循环链表节点，指向上一个<code>task_struct</code>结构，next指向下一个<code>task_struct</code>结构。因此tasks字段将进程描述符以双向链表形式连接起来。</p><p>进程链表头是<code>init_task</code>描述符，它是所谓的0进程或swapper进程的进程描述符，它的prev指向描述符链表的最后一个元素(循环链表)。</p><h4 id="TASK-RUNNING状态的进程链表-run-list链表"><a href="#TASK-RUNNING状态的进程链表-run-list链表" class="headerlink" title="TASK_RUNNING状态的进程链表(run_list链表)"></a>TASK_RUNNING状态的进程链表(run_list链表)</h4><p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程(即TASK_RUNNING状态的进程)。</p><p>该队列通过一定的调度算法，使得可运行进程按一定权重排列。</p><h4 id="进程间关系相关字段"><a href="#进程间关系相关字段" class="headerlink" title="进程间关系相关字段"></a>进程间关系相关字段</h4><p>进程0和1是由内核创建，进程1(init)时所有进程的祖先。</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>real_parent</td><td>指向创建了p的进程的描述符，若父进程不再存在，指向init进程。</td></tr><tr><td>parent</td><td>指向p当前父进程，通常与real_parent一致，偶尔不同，比如当另一个进程使用监控p的ptrace()时</td></tr><tr><td>children</td><td>链表头部，链表中的所有元素都是P创建的子进程</td></tr><tr><td>sibling</td><td>指向兄弟进程链表中的下一个或前一个，这些兄弟的父进程都是real_parent所指定的进程</td></tr></tbody></table><h4 id="pidhash表以及链表"><a href="#pidhash表以及链表" class="headerlink" title="pidhash表以及链表"></a>pidhash表以及链表</h4><p>有时，内核必须支持从PID得到进程描述符，因此内核维护一个散列表pidhash，其取值范围时0~2<sup>11</sup>-1=2047，当遇到冲突时，使用双向链表解决冲突。</p><h3 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h3><p>除了TASK_RUNNING状态的所有进程被组织在一起，其他状态的进程在被分组处理时，有不同的处理方式，其中</p><ul><li><code>TASK_STOPPED</code>、<code>EXIT_ZOMBIE</code>、<code>EXIT_DEAD</code>状态的进程没有专门建立链表，因为这三种状态的进程访问比较简单，没有被专门分组</li><li><code>TASK_INTERRUPTIBLE</code>、<code>TASK_UNINTERRUPTIBLE</code>状态使用等待队列实现。</li></ul><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待对垒表示一组睡眠的进程，当某一条件变为真，内核将唤醒它。</p><h4 id="进程资源限制"><a href="#进程资源限制" class="headerlink" title="进程资源限制"></a>进程资源限制</h4><p>每个进程都有一组相关的资源限制，指定了进程可使用的系统资源数量。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程。这种行为就是进程切换、任务切换或上下文切换。</p><h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>进程恢复执行前必须装入寄存器的一组数称为硬件上下文。</p><p><strong><em>进程切换只发生在内核态，在执行进程切换前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上。</em></strong></p><h4 id="任务状态段"><a href="#任务状态段" class="headerlink" title="任务状态段"></a>任务状态段</h4><p>x86体系结构中包含了一个特殊的段类型，称为任务状态段(Task State Segment, TSS)。TSS段就是用来存放硬件上下文的，Linux强制为每个CPU创建了一个TSS。</p><p>TSS反应了CPU上的当前进程的特权级，不必要为没有在运行的进程保留TSS。</p><h4 id="执行进程切换的步骤"><a href="#执行进程切换的步骤" class="headerlink" title="执行进程切换的步骤"></a>执行进程切换的步骤</h4><ol><li>切换页全局目录以安装一个新的地址空间(比如，更新cr3寄存器,cr3寄存器的内容是一个物理地址，若是虚拟地址，就有鬼打墙的问题了)</li><li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</li></ol><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>传统Unix操作系统：子进程复制父进程所拥有的资源。</p><p>现代Unix内核：</p><ol><li>写时复制技术(Copy-On-Write)：运行父子进程读相同的物理页，只要两者中一个试图写一个屋里也，内核将该页内容拷贝到信的物理页，并分配给正在写的进程。（详解见第九章）</li><li>轻量级进程：允许父子进程共享进程在内核的很多数据结构，如页表(整个用户态地址空间)、打开文件表及信号处理。</li><li>vfork()系统调用：创建的进程能共享父进程的内存地址空间，防止父进程重写子进程需要的数据，阻塞父进程的执行，一直到子进程退出或执行一个新的程序为止。</li></ol><h4 id="clone-、fork-、vfork-系统调用"><a href="#clone-、fork-、vfork-系统调用" class="headerlink" title="clone()、fork()、vfork()系统调用"></a>clone()、fork()、vfork()系统调用</h4><p>在Linux中，用clone()函数创建轻量级进程，通过参数fn指定新进程所执行的函数，以及指定传递给fn()的数据、flags指定信息、child_stack指定为子进程分配的堆栈等。</p><p>Linux下的fork()调用是使用clone()实现的，flags指定为<code>SIGCHILD</code>信号及所有清0的clone标志，<code>child_stack</code>指定为父进程当前的堆栈指针。因此，父进程和子进程暂时共享同一个用户态堆栈，但是由于存在写时复制机制，通常只要父子进程其中一个试图去写栈，则每个进程的用户态堆栈都将得到各自的一份拷贝。</p><p>vfork()也是clone()实现的，其中flags指定为<code>SIGCHILD</code>以及<code>CLONE_VM</code>和<code>CLONE_VFORK</code>、<code>child_stack</code>等于父进程当前的栈指针。</p><h3 id="撤销进程"><a href="#撤销进程" class="headerlink" title="撤销进程"></a>撤销进程</h3><p>当进程被终止时，通知内核释放进程所拥有的所有资源，包括内存、打开的文件等等。</p><h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>是一种特殊的自旋锁，一种读可重复，写不可重复的锁。读和写操作是互斥的。</p><h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><p>是一种类似读写锁的锁，但是写时依然可以读，读时也可以写，使用一种顺序计数器，写时顺序计数器会自增，读需要重复进行，当计数值相等，则读值操作成功。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>不同于自旋锁，等待时会挂起进程。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>CPU时间被分为片，为每个可运行进程分配一片。</p><p>设计调度时，传统上将进程分为</p><ul><li>I/O受限(频繁使用I/O设备)</li><li>CPU受限(大量使用CPU做计算)</li></ul><p>也有将进程分为</p><ul><li>交互式进程(经常与用户进行交互)</li><li>批处理进程(不需要与用户交互，常在后台运行)</li><li>实时进程(有很强的调度需要)</li></ul><h4 id="进程的抢占"><a href="#进程的抢占" class="headerlink" title="进程的抢占"></a>进程的抢占</h4><p>当一个进程被抢占时，其时间片未使用完，进程状态仍在TASK_RUNNING，当抢占进程结束后，该进程继续恢复执行，并不会挂起。</p><h4 id="时间片长短"><a href="#时间片长短" class="headerlink" title="时间片长短"></a>时间片长短</h4><p>时间片太长会导致系统对其他进程的反应迟钝，使得使用者感受到操作阻碍。</p><p>时间片太短，则系统将花费大量时间在进程切换上。</p><p>Linux选择尽可能长，同时能保持良好响应时间的一个时间片。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>Linux总是按照以下调度算法进行调度</p><ol><li>FIFO(先进先出)<br><br>先进先出的实时进程。当调度程序把CPU分配给进程的时候，进程描述符放在运行队列链表的当前位置。</li><li>RR(时间片轮转)<br><br>当调度程序将CPU分配给进程时，它把该进程的描述符放在运行队列链表的末尾，公平分配CPU时间。</li><li>NORMAL(普通分时进程)</li></ol><h4 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h4><p>普通进程的调度算法可以总结为程序为自己设定一个静态优先级，该静态优先级通过一定算法决定所拥有的时间片，同时，调度程序根据进程的平均睡眠时间结合静态优先级计算得出动态优先级，用以选出下一个交给CPU去执行的进程的优先级。</p><h5 id="静态优先级与基本时间片"><a href="#静态优先级与基本时间片" class="headerlink" title="静态优先级与基本时间片"></a>静态优先级与基本时间片</h5><p>普通进程都有属于自己的静态优先级，数值从100到139，值越大，静态优先级越低。</p><p>基本时间片单位为ms</p><p>当静态优先级&lt;120时，基本时间片=(140-静态优先级)*20</p><p>当静态优先级&gt;=120时，基本时间片=(140-静态优先级)*5</p><p>静态优先级越高，基本时间片就越长。</p><blockquote><p>系统提供接口设置nice值，值为-20~19默认为0，通过计算得出静态优先级，静态优先级对用户不可见。对实时进程来说，直接使用静态优先级。对普通进程来说则使用动态优先级。nice值越大，优先级越低。</p></blockquote><h5 id="动态优先级与平均睡眠时间"><a href="#动态优先级与平均睡眠时间" class="headerlink" title="动态优先级与平均睡眠时间"></a>动态优先级与平均睡眠时间</h5><p>普通进程除了静态优先级还有动态优先级，范围100~139。动态优先级是用于调度程序选择新进程来运行时使用的，它与静态优先级的经验公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态优先级=max(100, min(静态优先级 - bonus+5, 139)</span><br></pre></td></tr></table></figure></p><p>bonus的值依赖于进程过去的运行情况(平均睡眠时间情况)，范围0~10，值小于5表示降低动态优先级，大于5表示增加动态优先级。</p><p>平均睡眠时间表示进程睡眠状态所消耗的平均纳秒数，平均睡眠时间永远不会大于1s。</p><blockquote><p><a href="https://blog.csdn.net/liuxiaowu19911121/article/details/47070111" target="_blank" rel="noopener">CFS调度算法</a>，使得Linux不需要使用固定的时间片，而灵活的采用<strong><em>实际运行时间</em></strong>来控制进程的运行周期，每一个nice值对应一个权重，根据以下公式计算得出运行时间「分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和」</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.什么是CFS</span><br><span class="line">CFS(Completely Fair Scheduler)是Linux 2.6.23中引入的，针对普通进程（linux中除了普通进程之外还有实时进程，实时进程有专门的实时调度器，其实现在kernel/sched_rt.c）的一个调度器。它的实现在kernel/sched_fair.c。</span><br><span class="line"></span><br><span class="line">CFS的设计原则是，尽力保证CPU资源在所有可运行进程之间平均划分——假如系统中一共有n个可运行进程，那么在任何时刻，每个可执行进程刚好使用了1/n的CPU资源。注意，红色字体意味着这只能是一个理想化的模型，在某一时刻（甚至可以说在每一时刻）肯定会有人超过1/n，有人不足1/n，但是CFS会以此模型为目标尽力去做到。</span><br><span class="line"> </span><br><span class="line">2. vruntime</span><br><span class="line">CFS通过为每个可运行进程维护一个虚拟运行时间vruntime来实现它的目标。vruntime记录了一个可执行进程到当前时刻为止执行的总时间（需要以进程总数n进行归一化，并且根据进程的优先级进行加权）。CFS每次挑选新进程投入运行的时候，采用的策略超级简单：挑选vruntime最小的可运行进程p投入运行，当运行了一段时间dt之后，进程p的vruntime相应增加Dt(vruntime+=Dt)，然后CFS重新选择拥有最小vruntime的进程p&apos;投入运行。</span><br><span class="line"></span><br><span class="line">需要注意的是，上文中vruntime的增加值Dt并不一定等于dt，Dt的计算需要根据进程的优先级也就是nice值进行加权，并对可执行进程总数n进行归一化。例如对同样的dt，高优先级进程的Dt比低优先级进程的Dt小。也就是说高优先级进程的vruntime增加较慢，所以就有更多的机会获得CPU。</span><br><span class="line"></span><br><span class="line">在理想的情况下，CFS应该把时间粒度划分的无限小。当一个可运行进程投入运行时，只运行无限小的时间就交出CPU。这样就可以满足任意时刻每个可运行进程的vruntime都相等的理想目标。实际中当然不可能做到无限小，每个进程的运行时间的最小粒度默认是1ms，再小的话，上下文切换的开销就相当巨大了。</span><br><span class="line"> </span><br><span class="line">3. 可运行进程的维护</span><br><span class="line">CFS如何快速挑选最小vruntime的可运行进程呢？答案是红黑树。红黑树是一种准平衡二叉排序树，也是一种自平衡二叉树，它的search/insert/delete操作的时间复杂度都是O(log(n))，并具有良好地动态特性（相比AVL树）。CFS将所有可运行进程组织成一个红黑树(rbtree)，红黑树的key就是进程的vruntime。通过这个rbtree，CFS可以在O(log(n))时间内找到最小vruntime的进程——也就是最左边的树节点(leftmost)。并且，CFS会将leftmost节点cache起来，以便加速下一次查找。</span><br><span class="line"> </span><br><span class="line">在每一次调度中，CFS从rbtree中挑中leftmost进程投入运行，运行完之后增加这个进程的vruntime值，并将其重新insert到rbtree里（如果这个进程没有被阻塞，即仍然是可运行的）。随着系统不断运行，可运行进程会不断地从rbtree的最左边delete，再被insert到右边，是一个很有趣的过程。</span><br></pre></td></tr></table></figure><h5 id="活动进程与过期进程"><a href="#活动进程与过期进程" class="headerlink" title="活动进程与过期进程"></a>活动进程与过期进程</h5><p>较高静态优先级的普通进程获得了较大的CPU时间片，</p><p>活动进程表示还没有用完时间片的进程，运行被运行</p><p>过期进程表示已经用完时间片，被禁止运行，直到所有活动进程都过期。</p><h4 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h4><p>实时进程与实时优先级相关，值范围1~99，优先级为1则为最高优先级，调度程序总是让优先级高的进程运行。与普通进程不同，实时进程总是被当做活动进程。</p><h3 id="调度所使用的数据结构"><a href="#调度所使用的数据结构" class="headerlink" title="调度所使用的数据结构"></a>调度所使用的数据结构</h3><p>首先，需要知道第三章所提到的进程链表以及运行队列链表，进程链表链接所有进程描述符，运行队列链表链接所有的可运行进程的进程描述符(idle进程除外)。</p><p>每个CPU都拥有一个属于自己的runqueue数据结构，存放运行的进程。</p><p>每个进程描述符内也包括调度相关字段，包括进程的动态优先级、静态优先级、当前状态、平均睡眠时间、最近插入运行队列时间或进程最近一次切换时间、最近一次替换笨进程的进程切换时间、调度类型(FIFO、RR、NORMAL)、时间片还剩的街拍书、实时优先级等。</p><p>父进程剩余的节拍数，会被分成两等份，一份给父进程，一份给子进程。因此，一个进程不能通过创建多个后代来霸占资源，除非它有给自己实时策略的特权。</p><h4 id="常见的批处理作业调度算法"><a href="#常见的批处理作业调度算法" class="headerlink" title="常见的批处理作业调度算法(*)"></a>常见的批处理作业调度算法(*)</h4><h5 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h5><p>按照各个作业进入系统的次序决定调度顺序。</p><h5 id="SJF-短作业优先"><a href="#SJF-短作业优先" class="headerlink" title="SJF(短作业优先)"></a>SJF(短作业优先)</h5><p>优先处理运行时间段的作业，需要用户在提交作业时提交作业运行时间的估计值。</p><h5 id="SRT-最短剩余时间优先"><a href="#SRT-最短剩余时间优先" class="headerlink" title="SRT(最短剩余时间优先)"></a>SRT(最短剩余时间优先)</h5><p>是针对SJF增加了抢占机制的调度算法，若到来的新任务剩余时间片小于当前正在执行的进程，则优先执行。</p><h5 id="RR-时间片轮转"><a href="#RR-时间片轮转" class="headerlink" title="RR(时间片轮转)"></a>RR(时间片轮转)</h5><p>轮转算法一个时间片长度为一个周期产生中断，中断发生时，将当前进程置于就绪队列链尾，基于FCFS选择下一个就绪作业运行。</p><h5 id="HRN-最高响应比优先"><a href="#HRN-最高响应比优先" class="headerlink" title="HRN(最高响应比优先)"></a>HRN(最高响应比优先)</h5><p>该算法是对FCFS以及SJF调度算法的综合平衡<br>响应比=(等待时间+服务时间)/服务时间</p><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><p>RAM一部分被永久分配给内核使用，用来存放内核代码及静态内核数据结构。其余部分，称为动态内存，本章将重点放在如何将主存分配给进程。</p><h2 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h2><p>按X86体系的CPU来说，处理器操作一个页时，会先访问一级缓存，未命中时访问二级缓存，仍未命中时访问主存，主存缺页则访问外存。</p><p>其中，一二级缓存相对透明，因为它完全由MMU负责。</p><h2 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h2><p>Intel的Pentium处理器可以采用两种不同的页框: 4KB和4MB(PAE激活则为2MB)</p><h3 id="页描述符"><a href="#页描述符" class="headerlink" title="页描述符"></a>页描述符</h3><p>内核必须记录每个页框的当前状态，确定页框属于进程或是内核、包含代码或是数据、空闲或是被使用等，就需要借助页描述符这一数据结构。</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>lru</td><td>包含页的最近最少使用的双向链表指针</td></tr><tr><td>flags</td><td>一组标志，也对页框所在的管理区进行编号</td><td>_mapcount</td><td>页框中的页表项数目</td></tr><tr><td>_count</td><td>页框的引用计数</td></tr></tbody></table><ul><li>_count<br><br>如果该字段为-1，则表示相应页框空闲，可悲分配给任一进程或内核本身。大于或等于0则表示被分配给了一个或多个进程。<code>page_count()</code>函数返回<code>_count</code>加1的结果，表示该页的使用者数目。</li></ul><h2 id="内核内存分区"><a href="#内核内存分区" class="headerlink" title="内核内存分区"></a>内核内存分区</h2><p>内核空间的逻辑地址从0xc0000000到0xffffffff,但内核要求能访问所有物理内存。是如何做到的，下面来看内核的内存分区。</p><p>Linux内核在x86 UMA体系结构中分为三个区段</p><ol><li>ZONE_DMA: 低于16Mb内存页框</li><li>ZONE_NORMAL: 16MB~896MB内存页框</li><li>ZONE_HIGHMEM: 包含896MB开始的所有内存页框(896MB~1024MB)</li></ol><p>这三个管理区都映射到线性地址的第4个GB上，前2个区都可以直接访问，而高端内存不可以被内核直接访问，尽管它的线性地址也映射在线性地址的第4个GB上，后面的高端内存一节会详细说明。</p><blockquote><p>64位体系上的<code>ZONE_HIGHMEM</code>区总是空着的</p></blockquote><p>管理区描述符的数据结构保存了管理区中的空闲页数目(<code>free_pages</code>)、保留页数目(<code>pages_min</code>)、该描述符的自旋锁(<code>lock</code>)、活动及非活动链表使用的自旋锁(<code>lru_lock</code>)、以页为单位的管理区总大小(<code>spanned_pages</code>、<code>present_pages</code>)等。</p><h3 id="高端内存"><a href="#高端内存" class="headerlink" title="高端内存"></a>高端内存</h3><p>高端内存的页框有三种不同机制的映射方式</p><ol><li>永久内核映射</li><li>临时内核映射</li><li>非连续内存分配</li></ol><h4 id="永久内核映射"><a href="#永久内核映射" class="headerlink" title="永久内核映射"></a>永久内核映射</h4><p>允许内核建立高端页框到内核地址空间的长期映射，使用主内核页表中一个专门的页表。</p><h4 id="临时内核映射"><a href="#临时内核映射" class="headerlink" title="临时内核映射"></a>临时内核映射</h4><p>每个CPU都有自己的包含13个窗口的集合，在高端内存的任一页框都可以通过一个窗口(保留的页表项)映射到内核地址空间。</p><p>发生一个临时映射时(页表值修改)，以前的映射就被覆盖掉。</p><blockquote><p><a href="https://www.cnblogs.com/wuchanming/p/4360277.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuchanming/p/4360277.html</a></p></blockquote><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li>用户空间(进程)是否有高端内存的概念<br><br>只有内核空间此案有高端内存，用户最多可以访问3G物理内存，而内核进程可以访问所有物理内存。</li><li>64位内核空间有高端内存吗<br><br>64位linux不存在高端内存，因为64位内核空间可以支持超过512G内存。</li><li>用户进程能访问多少物理内存？内核代码能访问多少物理内存？<br><br>32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。</li></ol><h2 id="连续内存区管理"><a href="#连续内存区管理" class="headerlink" title="连续内存区管理"></a>连续内存区管理</h2><p>把内存映射到一组连续的页框，这样会充分利用高速缓存，并获得较低的平均访问时间。详见《深入理解Linux内核(第三版)》</p><p>这里主要讨论操作系统意义上的连续内存管理，并不特指Linux内核所采用的方式</p><p>可能导致两种内存碎片问题</p><ol><li>外碎片(外部不能被使用的空闲内存)</li><li>内碎片(分配的连续内存中未被使用的内存)</li></ol><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>连续内存区管理采用动态分区分配</p><p>这种方式需要内核维护2个数据结构<br></p><ol><li>进程已分配分区情况</li><li>空闲分区情况</li></ol><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>通过对空闲分区的排序来决策下一个进程分配的位置<br></p><ol><li>最先匹配(第一个可以放下的): 按地址排序</li><li>最佳匹配(大小最合适): 顺序查找</li><li>最差匹配(使用最大的区块): 空闲分区从大到小</li></ol><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><ol><li>紧凑: 对等待队列中的进程内存进行紧凑</li><li>分区对换: 抢占处于等待状态进程的分区</li></ol><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>伙伴系统是一个对连续内存分配以及碎片整理的一个的实现。</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p>首先，一个伙伴系统的可分配分区的大小一定为2^n。</p><p>当需要的分区大小为2<sup>n-1</sup>&lt;s&lt;=2<sup>n</sup>时，把大小为2<sup>n</sup>的空闲分区分配给该进程。</p><p>系统将所有空闲块大小和起始地址组织成二位数组，初始状态只有一个大小为2<sup>U</sup>的空闲块。</p><p>分配时，每次在这个二维数组中，从小到大在空闲块中找到最小的可用空闲块。若块过大(s&lt;=2<sup>i-1</sup>)则进行二等分<strong><em>并将2个等分块放入空闲块列表中</em></strong>，直到得到合适大小。</p><p>合并时，两块大小一样并且相邻，且起始地址较低的块地址必须是2<sup>i+1</sup>的整数倍。</p><p>linux中使用到Buddy System的情况，正是在内核的内存分配中。</p><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li>在使能分页机制的情况下，更合适的外碎片整理方法是什么?<br> A.紧凑 B.分区对换 C.都不是<br><br>答案C: 使能分页机制后，粒度较细，每一物理页都可以被使用，不存在外碎片。</li><li>描述伙伴系统(Buddy System)特征正确的是()<br><br>A.多个小空闲空间可合并为大的空闲空间 B.会产生外碎片 C.会产生内碎片 D.都不对<br><br>答案ABC: 伙伴系统依然会存在外碎片。</li><li>如何回收伙伴系统产生的内存块<br><br>回收时，寻找该内存块的伙伴，也就是寻找相邻的空闲内存块，并且低地址的块起始地址满足2^(n+1)且大小相同，则两者为伙伴，可以合并。</li></ol><h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p>其中就有几种方式，如段式、页式、段页式等，非连续内存使得内存的外碎片减少，内存得以被高效率利用。</p><p>详见《深入理解Linux内核(第三版)》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可有效应对大地址空间可采用的页表手段是()</span><br><span class="line">A. 多级页表 B. 反置页表 C. 页寄存器方案 D. 单级页表</span><br><span class="line"></span><br><span class="line">前两个是对的。至于为什么页寄存器不行，老师在Piazza上给出了回复：</span><br><span class="line"></span><br><span class="line">页寄存器和反置页表很像，但它们的一个区别是进程ID在地址转换中的使用。没有进程ID（也就是说页寄存器方案）时，页表占用的空间仍然是与进程数相关的（也就是每个进程对应一组页寄存器？）。反置页表的大小只与物理内存大小，与并发进程数无关。</span><br><span class="line">采用页寄存器的硬件开销会很大。所以现在的通用CPU（包括64位的CPU）没有采用这种方式，大部分还是多级页表。由于有TLB作为缓存，效率还不错。</span><br></pre></td></tr></table></figure><h3 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h3><p>为扩大主存容量，采用虚拟存储技术，将暂时不用的内存移到外存中。</p><p>同时，虚拟存储技术希望由操作系统完成，无需程序员干涉。</p><p>覆盖技术，则需要程序员去实现。</p><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><blockquote><p><strong><em>覆盖操作发生在程序内部</em></strong></p></blockquote><p>将程序划分为若干功能相对独立的模块</p><ul><li>必要部分: 代码和数据常驻内存</li><li>不必要部分: 放在其他程序模块中，用到时装入内存。</li><li>不存在调用关系的模块可相互覆盖，共用同一块内存区域。</li></ul><p>假定模块A和模块B共用了一块内存中，B已经装在入内存，这时程序需要使用A模块，这时需要将模块B从这块共享内存中换出，载入模块A。</p><p>覆盖技术使得编程难度增加，需要划分模块，同时增加了执行时间。</p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><blockquote><p><strong><em>交换操作发生在程序之间</em></strong></p></blockquote><p>增加正在运行或需要运行的程序的内存，也就是将暂时不需要执行的程序放到外存中。</p><p>需要换入和换出两种操作，两种操作的基本单位都是整个进程的地址空间，在后面会讲到以页为单位的交换技术。</p><blockquote><p>何时需要发生交换：内存空间不够或有可能不够时。</p></blockquote><blockquote><p>交换区大小：存放所有用户仅此的所有内存映像拷贝。</p></blockquote><blockquote><p>地址映射重定位：需要采用动态地址映射方式。</p></blockquote><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol><li>时间局部性: 一条指令的一次执行和第二次执行、数据的一次访问和第二次访问，发生在较短时间内。</li><li>空间局部性: 当前指令或数据和即将要访问的指令和数据通常在一个小范围区域内。</li><li>分支局部性: 一条跳转指令的两次执行通常跳到相同的内存位置。</li></ol><p>因此，当一个程序被加载到内存时，只需要将当前指令的对应页或者对应段装入内存。<br><br>若需要的指令或数据不在内存，则产生缺页异常。<br><br>同时，操作系统需要监视内存中暂时不用的页面或段将其移到外存中。</p><h3 id="虚拟页式交换技术"><a href="#虚拟页式交换技术" class="headerlink" title="虚拟页式交换技术"></a>虚拟页式交换技术</h3><p>在页式管理基础上，在程序的逻辑地址空间到物理地址空间转换的过程中，增加了页表的请求和置换操作，做系统则需要增加一个缺页异常处理程序。</p><blockquote><p>当访问页表时，虚拟标志位标志页表项为f时，则表示该页表项不再物理内存上，产生缺页异常。</p></blockquote><p>主要的虚拟存储的页标志位有</p><ol><li>驻留位: 表示该页是否在内存中(1在0不在)</li><li>修改位: 表示在内存中的该页是否被修改过，若修改过，则需要更新外存中相应内容的值(重新将该页写回外存)</li><li>访问位: 表示该页是否被访问过，用于页面置换算法</li><li>保护位: 该页的访问权限(读写)</li></ol><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>缺页异常时的具体处理流程如下：</p><ol><li>读取指定页，指定页表项内的驻留位为0</li><li>触发缺页异常</li><li>查找外存中对应的页</li><li>页面换入空闲页帧，若不存在空闲页帧，通过页面置换算法置换出某一页，驻留位设置为0，并判断对应页是否修改过，若修改过，写回外存。</li><li>页表项驻留位修改为1</li><li>重新执行导致异常的指令</li></ol><p>需要注意的是，操作系统在哪里保存未被映射的页？</p><p>在Linux和Unix中使用一个叫交换区的空间专门用来保存未被映射的页面。其中，有一些页面不需要被放入交换区中，如代码段、共享库。</p><p>有效存储访问时间(EAT)<br><br>EAT = 访存时间*(1-p) + 缺页异常处理时间*缺页率p(1+页修改概率q)</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li>局部页面置换算法: 针对当前进程的页面置换(最优算法、先进先出算法、最近最久未使用算法、时钟算法、最不常用算法)</li><li>全局页面置换算法: 针对所有进程的页面置换(工作集算法、缺页率算法)</li></ul><blockquote><p>页面锁定(frame locking): 必须放置在内存的逻辑页面(操作系统关键代码)、要求响应速度的页面</p></blockquote><h4 id="最优页面置换算法-OPT-optimal"><a href="#最优页面置换算法-OPT-optimal" class="headerlink" title="最优页面置换算法(OPT, optimal)"></a>最优页面置换算法(OPT, optimal)</h4><p><strong><em>基本思路</em></strong><br></p><ul><li>置换在未来最长时间不访问的页面</li></ul><p><strong><em>算法实现</em></strong><br></p><ul><li>缺页时，计算内存中每个逻辑页面的下一次访问时间。</li><li>选择最长时间不访问的页面</li></ul><p><strong><em>算法特征</em></strong><br></p><ul><li>缺页最少，最理想</li><li>实际环境无法实现，因为无法预知每个页面下次访问前的等待时间。</li><li>这种算法虽然不可以实际使用，但可以作为置换算法的性能评价依据</li></ul><h4 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h4><p><strong><em>基本思路</em></strong><br></p><ul><li>选择在内存驻留时间最长的页面进行置换</li></ul><p><strong><em>算法实现</em></strong><br></p><ul><li>维护一个记录所有内存中的逻辑页面的链表</li><li>按驻留内存的事件排序，链首时间最长。</li><li>选择链首的页进行缺页替换。</li></ul><p><strong><em>算法特征</em></strong><br></p><ul><li>实现简单</li><li>性能较差</li><li>进程分配的物理页增加时，缺页更多(Belady现象)</li></ul><h4 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h4><p><strong><em>基本思路</em></strong><br></p><ul><li>选择最长时间没有被使用的页面进行置换</li><li>利用过去预测未来</li></ul><p><strong><em>算法实现</em></strong><br></p><ul><li>将上一次最久未使用的页面进行替换</li></ul><p><strong><em>算法实现方法</em></strong><br></p><ol><li>构造页面链表，维护一个按最近访问顺序排序的页面链表，链首刚被使用过，链尾时最久未使用的页面。访问时，找到相应页面，移到链首。缺页时，置换掉链尾的页面，换入新的页面于链首。</li><li>构造活动页面栈，将页号压入栈顶，并把栈内相同页号抽出，缺页时，置换栈底的页面。</li></ol><h4 id="时钟置换算法-clock"><a href="#时钟置换算法-clock" class="headerlink" title="时钟置换算法(clock)"></a>时钟置换算法(clock)</h4><p><strong><em>基本思路</em></strong><br><br>对页面访问的情况进行大致统计</p><p><strong><em>数据结构</em></strong></p><ul><li>页表项增加一个访问位，描述页面过去一段时间是否访问过。</li><li>各个页面组织成环形链表，指针指向最先调入的页面。</li></ul><p><strong><em>算法</em></strong><br>访问页面时，在页表项记录页面访问情况，缺页时，从指针处开始顺序查找未被访问的页面(第一个)进行置换。</p><p><strong><em>特征</em></strong><br>LRU和FIFO的折中方案, 由于使用环形链表，搜索的过程类似一个时钟的指针在旋转查找可置换项。</p><p><strong><em>实现</em></strong></p><ol><li>页面装入内存，访问位置为0</li><li>访问页面时(读/写)，访问位置为1</li><li>缺页时，从指针当前位置循环检查环形链表。<br> 1) 访问位为0，置换该页<br> 2) 访问位为1，设置访问位为0，并继续循环搜索直到遇到第一个访问位为0。</li></ol><h4 id="改进的Clock算法"><a href="#改进的Clock算法" class="headerlink" title="改进的Clock算法"></a>改进的Clock算法</h4><p><strong><em>基本思路</em></strong><br>普通时钟算法只考虑了读的情况，如果页面内容有修改，每次必须将被修改的页内容写到外存，处理时间较长。改进的clock算法目标减少修改页的缺页处理开销。</p><p><strong><em>算法</em></strong></p><ul><li>在页面上增加一个修改位，并在访问时进行相应设置(修改过则设置为1，未修改设置为0)。</li><li>缺页时，置换指针所指向的页处理方式有以下几种情况</li></ul><table><thead><tr><th>访问位</th><th>修改位</th><th>处理方式</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>设置访问位为0</td></tr><tr><td>1</td><td>0</td><td>设置访问位为0</td></tr><tr><td>0</td><td>0</td><td>置换该页</td></tr><tr><td>0</td><td>1</td><td>将值写回外存(并不直接开始做，交由系统其他程序去处理)，修改位设为0，不置换该页，指针继续移动</td></tr></tbody></table><h4 id="最不常用置换算法-LFU"><a href="#最不常用置换算法-LFU" class="headerlink" title="最不常用置换算法(LFU)"></a>最不常用置换算法(LFU)</h4><p>对LRU的简化，统计开销较大<br><strong><em>基本思路</em></strong><br>缺页时，置换访问次数最少的页面。</p><p><strong><em>实现</em></strong></p><ol><li>每个页面设置一个访问计数</li><li>访问页面时，访问计数+1</li><li>缺页时，置换计数最小的页面</li></ol><p><strong><em>特征</em></strong></p><ul><li>算法开销大</li><li>开始时频繁使用的页面，在后期很难被置换掉: 计数定期右移</li></ul><p><strong><em>LRU与LFU区别</em></strong><br>一个关注多久未访问、一个关注访问次数。</p><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>采用FIFO等算法时，可能出现可分配的物理页面数增加，缺页次数反而升高的现象。</p><p>原因时，FIFO算法的置换特征与进程访问内存的动态特征矛盾。被置换出去的页面并不一定时进程近期不会访问的。</p><p>例如访问序列：1,2,3,4,1,2,5,1,2,3,4,5<br>|物理页面数|缺页次数|<br>|—|—|<br>|3|9|<br>|4|10|</p><p>Q: 哪些算法不会出现Belady现象？<br><br>LRU<br>例如访问序列：1,2,3,4,1,2,5,1,2,3,4,5<br>|物理页面数|缺页次数|<br>|—|—|<br>|3|10|<br>|4|8|</p><h4 id="LRU、FIFO、Clock算法比较"><a href="#LRU、FIFO、Clock算法比较" class="headerlink" title="LRU、FIFO、Clock算法比较"></a>LRU、FIFO、Clock算法比较</h4><ol><li>两者都是先入先出的思路<br><ul><li>LRU依据页面的最近访问时间排序、需要动态调整顺序。</li><li>FIFO依据进入内存的时间排序，时间固定不变。</li></ul></li><li>LRU可退化成FIFO<br><br>如页面进入内存后没有被访问过，最近访问时间与进入内存的时间相同，退化成了FIFO</li><li>clock是两者的折中<br><ol><li>由于LRU性能好但维护LRU栈开销大，FIFO开销小，但会发生Belady现象。</li><li>Clock在访问页面时，不动态调整页面在链表中的顺序，仅做标记。</li><li>缺页时，clock指针跳过访问过的页面(相当于移到链尾了)</li><li>对于未被访问的页面，clock和LRU(退化为FIFO)算法的表现一样好</li><li>对于被访问过的页面，clock不能记录准确顺序，而LRU算法可以。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、绪论&quot;&gt;&lt;a href=&quot;#一、绪论&quot; class=&quot;headerlink&quot; title=&quot;一、绪论&quot;&gt;&lt;/a&gt;一、绪论&lt;/h1&gt;&lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="linux" scheme="https://jobscn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://jobscn.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】索引详解</title>
    <link href="https://jobscn.github.io/dbms/database-indexing.html"/>
    <id>https://jobscn.github.io/dbms/database-indexing.html</id>
    <published>2019-02-28T15:28:41.000Z</published>
    <updated>2019-07-08T03:39:06.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>索引是为了提高数据检索速度而提前建立的相关数据结构。</p><h1 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h1><ol><li>索引大大减少了存储引擎需要扫描的数据量</li><li>加快排序的速度，Btree索引本身所具备的排序功能帮助数据库避免使用临时表来进行排序</li><li>索引可以使得随机I/O变为顺序I/O，分布在磁盘各处的数据，经过索引的串联形成一定顺序。</li></ol><h1 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h1><blockquote><p>MyISAM和Innodb通常使用BTree索引<br>认识B树之前，还需要知道<a href="https://blog.csdn.net/saasanken/article/details/80796178" target="_blank" rel="noopener">平衡二叉树</a></p></blockquote><p>主流数据库所采用的索引数据结构，基本上都是<code>b tree</code>与<code>b+ tree</code>，少数部分采用哈系桶作为索引的数据结构。因此，理解B树与B+树是相当重要的一个内容。</p><p>B+树是B树的一种变形，在了解B+树之前，先看看什么是B树。</p><h2 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h2><blockquote><p>建议参考: <a href="https://www.cnblogs.com/vincently/p/4526560.html" target="_blank" rel="noopener">https://www.cnblogs.com/vincently/p/4526560.html</a><br>B树是一种2-3树的扩展，B树的特征如下:</p><ul><li>根节点至少有2个子节点</li><li>满足类似平衡二叉树的特征</li></ul></blockquote><p>B树插入节点时，当节点内的关键字(索引值)超过B树的阶时，自动选取当前节点中的节点中间值，</p><p>具体数据结构:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> keynum;             <span class="comment">/* 结点中关键码的个数，即结点的大小*/</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">parent</span>;</span>    <span class="comment">/*指向双亲结点*/</span>   </span><br><span class="line">    KeyType key[m+<span class="number">1</span>];       <span class="comment">/*关键码向量，0 号单元未用*/</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">ptr</span>[<span class="title">m</span>+1];</span>  <span class="comment">/*子树指针向量*/</span>   </span><br><span class="line">    Record *recptr[m+<span class="number">1</span>];    <span class="comment">/*记录指针向量*/</span>  </span><br><span class="line">&#125;NodeType;                  <span class="comment">/*B 树结点类型*/</span></span><br></pre></td></tr></table></figure></p><p>当节点内的指针数超过阀值时，需要拆分节点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SplitBTNode函数</span><br><span class="line">功能：将结点p分裂成两个结点,前一半保留,后一半移入结点q</span><br><span class="line">代码实现：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitBTNode</span><span class="params">(BTNode *&amp;p,BTNode *&amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> s=(m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    q=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));             <span class="comment">//给结点q分配空间</span></span><br><span class="line"></span><br><span class="line">    q-&gt;ptr[<span class="number">0</span>]=p-&gt;ptr[s];                            <span class="comment">//后一半移入结点q</span></span><br><span class="line">    <span class="keyword">for</span>(i=s+<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        q-&gt;key[i-s]=p-&gt;key[i];</span><br><span class="line">        q-&gt;ptr[i-s]=p-&gt;ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;keynum=p-&gt;keynum-s;                </span><br><span class="line">    q-&gt;parent=p-&gt;parent;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=p-&gt;keynum-s;i++)                         <span class="comment">//修改双亲指针 </span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;ptr[i]!=<span class="literal">NULL</span>) </span><br><span class="line">            q-&gt;ptr[i]-&gt;parent=q;</span><br><span class="line">    p-&gt;keynum=s<span class="number">-1</span>;                              <span class="comment">//结点p的前一半保留,修改结点p的keynum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="什么是B-树"><a href="#什么是B-树" class="headerlink" title="什么是B+树"></a>什么是B+树</h2><p>相比于B树，B+树的区别在于，有多少个关键字就有多少个叶子节点，而其他节点只用作索引，并不保存数据。</p><p>需要知道的是，B树所有叶节点处在同一层上。同时，所有叶节点都使用了指针进行相互连接。</p><h1 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h1><p>memory存储引擎通常使用哈希索引</p><p>基于哈希表实现，只有查询条件精确匹配哈希表中的所有列，才能使用到哈希索引。</p><p>对于hash索引中的所有列，存储引擎会为每一行计算一个hash码，hash索引中存储的就是hash码，因此只能满足全值匹配。</p><h1 id="数据库中的索引"><a href="#数据库中的索引" class="headerlink" title="数据库中的索引"></a>数据库中的索引</h1><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>在建表时，如果不为表设置主键，那么数据就无序的按行存放于磁盘中。如果为表设置一个主键，则数据从整齐排列的结构转化为树状结构，也就是B+Tree结构。因此一个表只能有一个聚集索引，因为它决定了这张表的物理存储顺序。</p><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>非聚集索引同聚集索引一样的采用平衡树作为主要数据结构，如果为多个字段添加索引，则会出现多个相互独立的索引结构。</p><p><strong><em>通过非聚集索引，并不直接得到真实数据，而只是查到相应记录对应的主键值，最终再使用聚集索引检索到真实的数据</em></strong>，聚集索引是获取真实数据的唯一路径。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><blockquote><p>memory引擎不支持覆盖引擎</p></blockquote><p>对于以上所说的索引方式存在一种例外，是不需要再经过聚集索引，而直接可以获得数据一种索引方式，称之为<code>覆盖索引</code>，又或者是我们常说的<code>复合索引</code>或<code>多字段索引</code>。</p><p>覆盖索引直接将对应字段的值拷贝到索引当中。仅此，只需要检索索引，到达该索引的叶节点，即可获取到相应数据值。</p><p>例如下面这样的一个语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//建立索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_birthday <span class="keyword">on</span> user_info(birthday);</span><br><span class="line"></span><br><span class="line">//查询生日在1991年11月1日出生用户的用户名</span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">where</span> birthday = <span class="string">'1991-11-1'</span></span><br></pre></td></tr></table></figure></p><p>这里为<code>user_info</code>表的<code>birthday</code>字段建立了<code>index_birthday</code>索引。因此，在查询<code>birthday</code>字段时，<strong><em>会先通过非聚集索引，得到对应查询结果的主键ID，并通过主键ID再执行聚集索引，查询到真实数据</em></strong></p><p>而如果我们将这个索引，修改为复合索引(覆盖索引)，那么情形就会有所改变，下面来看。</p><h3 id="复合索引-多字段索引"><a href="#复合索引-多字段索引" class="headerlink" title="复合索引(多字段索引)"></a>复合索引(多字段索引)</h3><p>一个简单的创建复合索引的sql语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_birthday_and_user_name</span><br><span class="line"><span class="keyword">on</span> user_info(birthday, user_name);</span><br></pre></td></tr></table></figure></p><p>这时，再执行对应的查询操作时，非聚集索引的叶节点<strong><em>不仅包含了主键ID，还包含user_name的值</em></strong>，如果只是获取<code>user_name</code>的值(比如上面<code>select</code>语句)，就不需要再去执行聚集索引操作。</p><h3 id="INCLUDE索引"><a href="#INCLUDE索引" class="headerlink" title="INCLUDE索引"></a>INCLUDE索引</h3><p>在创建索引时，增加一个INCLUDE项，就可以做到在不增加索引键大小的情况下，仅使用一个非聚集索引就完成数据的检索。</p><p>比如我们将上面的创建索引语句修改为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//建立索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_birthday <span class="keyword">on</span> user_info(birthday)</span><br><span class="line"><span class="keyword">INCLUDE</span> (user_name);</span><br></pre></td></tr></table></figure></p><p>这样的效果是，只能通过<code>birthday</code>进行索引，因此索引键的大小并没有变化，但索引的叶节点内却包含了<code>user_name</code>字段的值。</p><p>若将WHERE条件修改为<code>user_name</code>，则将不会通过<code>index_birthday</code>索引进行查询，而是采用聚集索引(全表查询)的方式进行搜索。</p><h2 id="使用B树的索引的检索方式"><a href="#使用B树的索引的检索方式" class="headerlink" title="使用B树的索引的检索方式"></a>使用B树的索引的检索方式</h2><p>对于普通索引或复合索引，采用了B+树形式存储键值，数据库是如何使用这些键值的？</p><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配也就是要求键值完全匹配的一种查询，比如这样的查询语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name <span class="keyword">from</span> t_order <span class="keyword">where</span> order_id=<span class="string">'123456'</span></span><br></pre></td></tr></table></figure></p><h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><p>最左前缀匹配意味着当有两个以上索引时，将索引列的顺序逐个匹配关键字。</p><p>比如设置了两个联合索引<code>order_id</code>与<code>order_data</code>，那么以下的查询语句是可以使用索引的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name <span class="keyword">from</span> t_order <span class="keyword">where</span> order_id=<span class="string">'123456'</span></span><br></pre></td></tr></table></figure></p><p>即使顺序颠倒也依然成立<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name <span class="keyword">from</span> t_order <span class="keyword">where</span> order_id=<span class="string">'123456'</span> <span class="keyword">AND</span> order_data=<span class="string">'CA00013'</span></span><br></pre></td></tr></table></figure></p><p>但查询条件中的列缺少前序索引列时，那么这个联合索引将不被使用。例如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name <span class="keyword">from</span> t_order <span class="keyword">where</span> order_data=<span class="string">'CA00013'</span></span><br></pre></td></tr></table></figure></p><p>最左匹配有两个重要原则</p><ol><li><code>=</code>和<code>in</code>可以乱序，mysql的查询优化器会自动将其优化为满足索引可识别的形式。</li><li>从左到右当遇到范围查询(<code>&gt;</code>,<code>&lt;</code>,<code>between</code>,<code>like</code>)时，最左前缀就会停止匹配。例如，建立索引(a,b,c,d)，查询语句 a=1 and b=2 and c&gt;3 and d=4，那么索引的有效列就只是a,b,c三个列，d不会被匹配进去。如果更换索引顺序为(a,b,d,c)那么这条语句的所有列都能应用索引。</li></ol><h3 id="列前缀匹配"><a href="#列前缀匹配" class="headerlink" title="列前缀匹配"></a>列前缀匹配</h3><p>匹配某一列的开头部分，例如<code>order_data=&#39;CA00%&#39;</code></p><h3 id="范围值匹配"><a href="#范围值匹配" class="headerlink" title="范围值匹配"></a>范围值匹配</h3><p>B树同样的适合于范围值的查找，例如<br><br><code>order_id &gt; &#39;123&#39; and order_id &lt; &#39;456&#39;</code></p><h3 id="精确匹配左前列，范围匹配另一列"><a href="#精确匹配左前列，范围匹配另一列" class="headerlink" title="精确匹配左前列，范围匹配另一列"></a>精确匹配左前列，范围匹配另一列</h3><p>在上面提到过，是最左匹配两个重要原则的第二个</p><p>例如 <code>a=1 and b=2 and c &gt; 3 and c&lt;6</code></p><h3 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h3><p>只需要访问非聚集索引而不需要访问聚集索引的查询(也就是覆盖索引)</p><h2 id="索引交叉"><a href="#索引交叉" class="headerlink" title="索引交叉"></a>索引交叉</h2><p>当一个查询语句中，用到多个索引时，数据库检索会做索引的交叉处理。</p><p>例如当一个查询的检索条件用到2个非聚集索引，而结果需要展示更多的字段时，数据库将这样处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引1-\</span><br><span class="line">       -&gt;哈希匹配最小子集-&gt;聚集索引-&gt;数据</span><br><span class="line">索引2-/</span><br></pre></td></tr></table></figure></p><p>如果这2个非聚集索引包含了所需要展示的所有字段(通过<code>INCLUDE</code>或复合索引等方式)，则数据库检索方式将变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引1-\</span><br><span class="line">       -&gt;哈希匹配最小子集-&gt;数据</span><br><span class="line">索引2-/</span><br></pre></td></tr></table></figure></p><h2 id="BTree索引的限制"><a href="#BTree索引的限制" class="headerlink" title="BTree索引的限制"></a>BTree索引的限制</h2><p>与前文中最左前缀匹配中的给出的两条原则相似，这里给出一个总结。</p><ol><li>如果不是按照索引的最左列开始查询，则无法使用索引。(mysql会自动优化条件中的列顺序)</li><li>不可以跳过索引顺序左边的索引列</li><li><code>NOT IN</code>和<code>&lt;</code>、<code>&gt;</code>操作无法使用索引</li><li>查询中有某个列的范围查询，则右边的所有列都不使用索引。</li></ol><h2 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h2><p>前面哈希索引一节，提到了哈希索引只能满足<code>全值匹配</code>一种查询操作，我们来看看哈希索引存在哪些限制。</p><ol><li>哈希索引需要2次查询。哈希索引仅保存了哈希码、行指针等。需要先找到行，对行进行读取。</li><li>不可用于排序。由于哈希索引按哈希码排序，并不是按照键值顺序，因此是无法实现排序的。</li><li>仅支持全值匹配查找，不支持范围查找、模糊查找</li><li>存在哈希冲突。不适用于类似性别(男、女)这样的选择性差的列，因为计算出的哈希码基本相同。</li></ol><h1 id="MyISAM与InnoDB中的B-树"><a href="#MyISAM与InnoDB中的B-树" class="headerlink" title="MyISAM与InnoDB中的B+树"></a>MyISAM与InnoDB中的B+树</h1><blockquote><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p></blockquote><h2 id="MyISAM中的索引"><a href="#MyISAM中的索引" class="headerlink" title="MyISAM中的索引"></a>MyISAM中的索引</h2><p>对于MyISAM的主键索引而言，叶节点存放数据记录的实际地址，属于一种”非聚集”索引。</p><h2 id="InnoDB中的索引"><a href="#InnoDB中的索引" class="headerlink" title="InnoDB中的索引"></a>InnoDB中的索引</h2><p>InnoDB的索引则与MyISAM不同，有聚集索引的概念，这意味着，主键索引本身就是一个数据，叶节点直接存放真实数据。因为聚集索引与物理实际存放的顺序相同。因此，InnoDB表数据文件就是一颗B+树。</p><p>因此，<strong>InnoDB中要求表一定要有聚集索引</strong>，MyISAM不对此做要求。</p><p>对于Mysql的InnoDb引擎而言，<strong>主键默认成为聚集索引</strong>，如果不设主键，则非空的列成为聚集索引，否则生成隐藏列作为聚集索引，<strong>用户不能自己创建聚集索引，例如其他高级数据库中的<code>CREATE CLUSTERED INDEX</code>语句</strong></p><blockquote><p>InnoDB建议选择自增列作为主键，以便于聚集索引的建立，不建议使用UUID作为主键。</p></blockquote><blockquote><p>MyISAM按插入顺序在磁盘上存放数据，行尺寸固定，只需要跳过所需字节来定位目标行。</p></blockquote><h1 id="Mysql中的索引"><a href="#Mysql中的索引" class="headerlink" title="Mysql中的索引"></a>Mysql中的索引</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>一个简单的创建索引语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [NONCLUSTERED|CLUSTERED] <span class="keyword">INDEX</span> index_name </span><br><span class="line"><span class="keyword">ON</span> table_name(field_name)</span><br></pre></td></tr></table></figure></p><p>其中，如果未指定是否是聚集索引，则默认为<code>NONCLUSTERED</code></p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><h1 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h1><blockquote><p>对于索引的优化，需要会用explain，明白extra字段的含义<br><br>using where: 使用索引但需要回表<br><br>using index: 覆盖索引<br><br>using index condition: 包含索引与未索引列时，先处理索引列，再回表查询。<br><br>using where; Using index: 不需要回表查询，查询所需的内容在索引中完成。</p></blockquote><h2 id="不可使用表达式或函数"><a href="#不可使用表达式或函数" class="headerlink" title="不可使用表达式或函数"></a>不可使用表达式或函数</h2><p>例如:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line"><span class="keyword">to_days</span>(out_date) - <span class="keyword">to_days</span>(<span class="keyword">current_date</span>) &lt;=<span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>其中<code>out_date</code>是索引列，对其使用函数将无法使用到索引。应该这样修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> product</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">out_date &lt;= <span class="keyword">date_add</span>(<span class="keyword">current_date</span>, <span class="built_in">interval</span> <span class="number">30</span> <span class="keyword">day</span>)</span><br></pre></td></tr></table></figure></p><h2 id="对前缀建立索引或缩短键值"><a href="#对前缀建立索引或缩短键值" class="headerlink" title="对前缀建立索引或缩短键值"></a>对前缀建立索引或缩短键值</h2><p>缩短键值对索引查找所付出的I/O效率的提升是有一定效果的，并且Mysql中的索引，对键值大小有所限制<code>innodb</code>引擎中的键值大小不可以超过767字节，<code>MyISAM</code>不可以超过1000个字节。</p><p>对于常见的基本数据类型，一般不会超过这些限制，但如果超过，我们依然有方案可用，那就是对前缀建立索引:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(col_name(n))</span><br></pre></td></tr></table></figure></p><p>mysql中可以这样去对某一列前n个字符的建立索引。</p><p>需要注意的是，对前缀建立索引，会降低索引列的选择性。</p><h2 id="使用联合索引并且选择好顺序"><a href="#使用联合索引并且选择好顺序" class="headerlink" title="使用联合索引并且选择好顺序"></a>使用联合索引并且选择好顺序</h2><p>如果对每一个列建立索引，显然不仅索引繁多，索引的开销以及查询结果多个索引的合并的开销，都是相当大的，选择联合索引也是一种比较好的解决方案。</p><p>但倘若建立联合索引，则需要更多注意建立索引时索引列顺序的选择</p><ol><li>经常被使用到的列顺序优先</li><li>选择性高的列优先(如果对应列是性别、状态这种重复性很强，选择性很低的列，一般没有必要建立索引)</li><li>宽度小的列优先(索引的键值越小，I/O效率越高)</li><li>所需字段不多时，可以使用覆盖索引(包含了一次查询所需要的所有字段的索引)。可以优化缓存，减少缓存换入换出，减少了磁盘I/O操作；减少随机I/O，变随机I/O为顺序I/O；避免InnoDB对聚集索引的查询。；避免MyISAM进行系统调用(MyISAM表数据依赖操作系统来缓存)</li></ol><h2 id="索引列中不要包含NULL值"><a href="#索引列中不要包含NULL值" class="headerlink" title="索引列中不要包含NULL值"></a>索引列中不要包含NULL值</h2><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p><h2 id="数据库自带的一种覆盖索引"><a href="#数据库自带的一种覆盖索引" class="headerlink" title="数据库自带的一种覆盖索引"></a>数据库自带的一种覆盖索引</h2><p>在sakila数据库中对索引列<code>last_name</code>执行以下语句时<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> actor_id, last_name <span class="keyword">from</span> actor <span class="keyword">where</span> last_name=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure></p><p>可以看到Extra一栏写着<code>Using Index</code>，这是因为索引列<code>last_name</code>已经包含了该表的主键<code>actor_id</code>的值，也可以称之为是一种覆盖索引。</p><h2 id="使用索引优化排序"><a href="#使用索引优化排序" class="headerlink" title="使用索引优化排序"></a>使用索引优化排序</h2><p>需要的条件:</p><ol><li>索引的列顺序和order by子句的顺序完全一致</li><li>索引中所有列的升序或降序和order by顺序完全一致</li><li>order by中的字段全部在关联表中的第一张表中</li></ol><p>可在索引内完成的排序例如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_date <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2010-05-09'</span>  <span class="keyword">order</span> <span class="keyword">by</span> inventory_id;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_date <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2010-05-09'</span>  <span class="keyword">order</span> <span class="keyword">by</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure></p><p>如果顺序不一致，则会出现using filesort，比如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_date <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2010-05-09'</span>  <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>, customer_id;</span><br></pre></td></tr></table></figure></p><p>但一定要注意不能使用范围查询，否则范围符号右边出现的索引将失效<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_date <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date &gt; <span class="string">'2010-05-09'</span>  <span class="keyword">order</span> <span class="keyword">by</span> inventory_id;</span><br></pre></td></tr></table></figure></p><h2 id="模拟hash索引"><a href="#模拟hash索引" class="headerlink" title="模拟hash索引"></a>模拟hash索引</h2><p>通过额外一列，单独对行做hash并对该列建立索引来实现模拟hash的功能。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> column_hash = <span class="keyword">md5</span>(<span class="keyword">column</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_name <span class="keyword">on</span> <span class="keyword">table</span>(column_hash);</span><br></pre></td></tr></table></figure></p><p>hash索引需要注意的是</p><ol><li>只能处理键值全值匹配</li><li>hash函数决定索引键的大小</li><li>需要小心hash冲突</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">column</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column_hash = <span class="keyword">md5</span>(<span class="string">"xxxx"</span>) <span class="keyword">and</span> <span class="keyword">column</span>=<span class="string">"xxx"</span>;</span><br></pre></td></tr></table></figure><p>之所以还需要使用<code>and column=&quot;xxx&quot;</code>是为了避免hash冲突的出现，这使得整个查询在哈希索引的作用下，再对结果进行一次冲突避免。</p><h2 id="使用索引优化锁"><a href="#使用索引优化锁" class="headerlink" title="使用索引优化锁"></a>使用索引优化锁</h2><ol><li>使用索引可以减少处理行，减少了加锁的行数</li><li>使用索引可以减少处理行并在内存中处理，因此加快处理速度，加快锁是释放。</li></ol><p>两个事务并发的对查询加排它锁时，如果查询的对应字段加了索引，排他锁是行级的，如果没有索引，那么排他锁将锁住整个表，使得第二个查询无法执行。</p><h2 id="删除重复和冗余的索引"><a href="#删除重复和冗余的索引" class="headerlink" title="删除重复和冗余的索引"></a>删除重复和冗余的索引</h2><blockquote><p>unique key(id) 并不只是约束，同时也会建立唯一索引。</p></blockquote><ol><li><p>重复索引<br><br>例如，对某一字段这样定义<code>primary key(id), unique key(id), index(id)</code>，那么这里就出现了三个索引，主键索引、唯一索引、单列索引，是重复的，对维护的开销比较大。</p></li><li><p>冗余索引<br><br> 1) 例如，<code>index(a), index(a,b)</code>属于冗余索引，对b树机制缺乏了解，其实<code>index(a)</code>包含在<code>index(a,b)</code>这一联合索引中，因此没有必要建立<code>index(a)</code>索引<br><br> 2) 如果建立这样的索引<code>primary key(id), index(a,id)</code>，意味着使用者缺乏对innodb存储引擎建立索引的了解，每一个二级索引，会自动的拷贝主键索引信息的。</p></li></ol><p>使用<code>pt-duplicate-key-checker h=127.0.0.1</code>命令可以检查冗余和重复的索引</p><h2 id="更新索引统计信息及减少索引碎片"><a href="#更新索引统计信息及减少索引碎片" class="headerlink" title="更新索引统计信息及减少索引碎片"></a>更新索引统计信息及减少索引碎片</h2><p>需要定期的维护索引的碎片<br><br><code>analyze table table_name</code><br><br><code>optimize table table_name</code>(会锁表，需要注意使用时间)</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol><li>为表上的所有字段建立索引，这种做法是否可行？<br><br> 1) 不可行，插入、更新等操作所需要的维护索引的开销会变得很大。因此对于经常需要更新和插入的表格就没有必要为不常用的where语句去建立索引、对于较小的表也可以不用建立索引。(注: innodb引入了插入缓存，使得多次插入不会引起多次的索引维护)<br> 2) 太多索引也会影响查询时间，会增加查询优化器对查询语句分析的时间。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/kissdodog/p/3158701.html" target="_blank" rel="noopener">https://www.cnblogs.com/kissdodog/p/3158701.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是索引&quot;&gt;&lt;a href=&quot;#什么是索引&quot; class=&quot;headerlink&quot; title=&quot;什么是索引&quot;&gt;&lt;/a&gt;什么是索引&lt;/h1&gt;&lt;p&gt;索引是为了提高数据检索速度而提前建立的相关数据结构。&lt;/p&gt;
&lt;h1 id=&quot;为什么要使用索引&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="dbms" scheme="https://jobscn.github.io/categories/dbms/"/>
    
    
      <category term="数据库" scheme="https://jobscn.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://jobscn.github.io/tags/mysql/"/>
    
      <category term="数据结构" scheme="https://jobscn.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【C++】virtual-inheritance 虚继承</title>
    <link href="https://jobscn.github.io/cpp/cpp-virtual-inherit.html"/>
    <id>https://jobscn.github.io/cpp/cpp-virtual-inherit.html</id>
    <published>2019-02-27T01:42:00.000Z</published>
    <updated>2019-07-08T03:31:06.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是虚继承"><a href="#什么是虚继承" class="headerlink" title="什么是虚继承"></a>什么是虚继承</h1><p>在普通的类继承情况下，通过virtual的方式继承父类，与虚函数的概念有所不同，virtual通常只在多重继承下才能发挥其作用。</p><h1 id="虚继承的作用"><a href="#虚继承的作用" class="headerlink" title="虚继承的作用"></a>虚继承的作用</h1><p>在多重继承下，可能会出现在不同级重复继承同一个类，例如<code>C类继承B和A</code>, <code>B类继承A类</code>，这时出现了C和B同时分别的继承了A类，这会导致<strong>A类被重复构造</strong>，并且<strong>A类的成员函数调用将出现二义性而导致无法调用</strong>。</p><h1 id="虚继承的原理"><a href="#虚继承的原理" class="headerlink" title="虚继承的原理"></a>虚继承的原理</h1><p>与虚函数原理类似，通过增加一个vbptr虚基类表来实现，如果在64位系统下，既有虚函数又有虚基类，那么一个对象模型将变为:</p><p>vptr[8B]-vbptr[8B]-其他非静态类成员变量(注意字节对齐)</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>编写以下三个类进行测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VTest()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"vtest construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VTest2</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> VTest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VTest2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"vtest2 construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VTest3</span>:</span> <span class="keyword">public</span> VTest2, <span class="keyword">virtual</span> <span class="keyword">public</span> VTest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VTest3()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"vtest3 construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VTest3 vt3;</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vtest construct</span><br><span class="line">vtest2 construct</span><br><span class="line">vtest3 construct</span><br></pre></td></tr></table></figure></p><p>如果将继承的virtual去掉，输出将变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vtest construct</span><br><span class="line">vtest2 construct</span><br><span class="line">vtest construct</span><br><span class="line">vtest3 construct</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是虚继承&quot;&gt;&lt;a href=&quot;#什么是虚继承&quot; class=&quot;headerlink&quot; title=&quot;什么是虚继承&quot;&gt;&lt;/a&gt;什么是虚继承&lt;/h1&gt;&lt;p&gt;在普通的类继承情况下，通过virtual的方式继承父类，与虚函数的概念有所不同，virtual通常只在多重继
      
    
    </summary>
    
      <category term="cpp" scheme="https://jobscn.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://jobscn.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【C++】关于可变长参数</title>
    <link href="https://jobscn.github.io/cpp/cpp-va-list.html"/>
    <id>https://jobscn.github.io/cpp/cpp-va-list.html</id>
    <published>2019-02-23T03:13:00.000Z</published>
    <updated>2019-07-08T03:32:41.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是可变长参数"><a href="#什么是可变长参数" class="headerlink" title="什么是可变长参数"></a>什么是可变长参数</h1><p>类似<code>printf()</code>函数不定个数的参数，使用<code>...</code>符号表示。</p><p>主要使用<code>...</code>、<code>va_list</code>变量、<code>va_start()</code>、<code>va_arg()</code>、<code>va_end()</code>几个宏实现。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>首先使用<code>...</code>作为参数定义一个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置<code>va_list</code>变量，使用<code>va_start</code>初始化ap，并记得使用<code>va_end</code>释放ap<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line">va_start(ap, b); <span class="comment">//`...`参数位于b形参后面</span></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">va_end(ap);</span><br></pre></td></tr></table></figure></p><p>使用<code>va_arg()</code>提取值，前提是，必须提前知道可变参数的个数，否则这个行为将一直执行下去。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = va_arg(ap, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p><h1 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">va_sum</span> <span class="params">(<span class="keyword">int</span> first_num, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (1) 定义参数列表</span></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="comment">// (2) 初始化参数列表</span></span><br><span class="line">    va_start(ap, first_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = first_num;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取参数值</span></span><br><span class="line">    <span class="keyword">while</span> ((temp = va_arg(ap, <span class="keyword">int</span>)) != END)</span><br><span class="line">    &#123;</span><br><span class="line">        result += temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭参数列表</span></span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_val = va_sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, END);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d"</span>, sum_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h1><ol><li><code>char</code>类型在使用<code>va_arg()</code>提取时会被自动提升为<code>int</code>类型，同样低，其他字节数低于<code>int</code>的类型都会被提升为<code>int</code></li><li><code>va_list</code>的ap可以直接传参给<code>vprintf(const char *, __va_list_tag *)</code>使用</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是可变长参数&quot;&gt;&lt;a href=&quot;#什么是可变长参数&quot; class=&quot;headerlink&quot; title=&quot;什么是可变长参数&quot;&gt;&lt;/a&gt;什么是可变长参数&lt;/h1&gt;&lt;p&gt;类似&lt;code&gt;printf()&lt;/code&gt;函数不定个数的参数，使用&lt;code&gt;...&lt;/
      
    
    </summary>
    
      <category term="cpp" scheme="https://jobscn.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://jobscn.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【C++11】关于智能指针</title>
    <link href="https://jobscn.github.io/cpp/cpp-shared-ptr.html"/>
    <id>https://jobscn.github.io/cpp/cpp-shared-ptr.html</id>
    <published>2019-02-19T01:08:13.000Z</published>
    <updated>2019-07-08T03:25:26.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是智能指针？"><a href="#什么是智能指针？" class="headerlink" title="什么是智能指针？"></a>什么是智能指针？</h1><p>智能指针是代替用户自动去管理的指针的创建于释放的类，是在c++11以后相当常用的类，它使得用户可以省去大部分繁琐的指针管理工作，智能指针通常使用RAII手法实现，下面罗列了几种智能指针与其特点。</p><blockquote><p>RAII(Resource Acquisition Is Initialization)即资源的构造即初始化，资源的析构即释放。</p></blockquote><table><thead><tr><th>智能指针</th><th>特点</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>auto_ptr(C++11之前)</td><td>执行复制操作会成功，<strong><em>但原auto_ptr被置空</em></strong></td><td>实现指针的自动释放，防止内存泄漏</td><td>1.排他所有权，两个auto_ptr不能指向同一个资源。<br>2. STL容器不可用，因为容器要求必须可复制</td></tr><tr><td>unique_ptr</td><td>拥有auto_ptr所有功能，<strong><em>无法进行赋值和复制操作</em></strong></td><td>用来表示一个所有权不可被转移的指针</td><td></td></tr><tr><td>shared_ptr</td><td>增加了一个引用计数代理对象指针</td><td>自动引用计数，在资源没有所有者时自动释放资源。</td><td></td></tr><tr><td>weak_ptr</td><td>不拥有与share_ptr类似，<strong><em>但构造和析构不会改变引用计数</em></strong></td><td>常配合shared_ptr使用， 解决了多个对象内部含有shared_ptr的循环指向导致对象无法释放。</td></tr></tbody></table><h1 id="share-ptr的实现"><a href="#share-ptr的实现" class="headerlink" title="share_ptr的实现"></a>share_ptr的实现</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><blockquote><p>以下share_ptr定义摘自MacOS。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">    <span class="keyword">typedef</span> weak_ptr&lt;_Tp&gt; weak_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*      __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">nat</span> &#123;</span><span class="keyword">int</span> __for_bool_;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    _<span class="function">LIBCPP_CONSTEXPR <span class="title">shared_ptr</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    _<span class="function">LIBCPP_CONSTEXPR <span class="title">shared_ptr</span><span class="params">(<span class="keyword">nullptr_t</span>)</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">explicit</span> <span class="title">shared_ptr</span>(_<span class="title">Yp</span>* __<span class="title">p</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat());</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(_<span class="title">Yp</span>* __<span class="title">p</span>, _<span class="title">Dp</span> __<span class="title">d</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat());</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(_<span class="title">Yp</span>* __<span class="title">p</span>, _<span class="title">Dp</span> __<span class="title">d</span>, _<span class="title">Alloc</span> __<span class="title">a</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat());</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Dp</span>&gt; <span class="title">shared_ptr</span>(<span class="title">nullptr_t</span> __<span class="title">p</span>, _<span class="title">Dp</span> __<span class="title">d</span>);</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Dp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt; <span class="title">shared_ptr</span>(<span class="title">nullptr_t</span> __<span class="title">p</span>, _<span class="title">Dp</span> __<span class="title">d</span>, _<span class="title">Alloc</span> __<span class="title">a</span>);</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt; _<span class="title">LIBCPP_INLINE_VISIBILITY</span> <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Yp&gt;&amp; __<span class="title">r</span>, <span class="title">element_type</span>* __<span class="title">p</span>) _<span class="title">NOEXCEPT</span>;</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Yp&gt;&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat())</span><br><span class="line">                       _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="built_in">shared_ptr</span>&amp;&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt; _<span class="title">LIBCPP_INLINE_VISIBILITY</span>  <span class="title">shared_ptr</span>(<span class="title">shared_ptr</span>&lt;_Yp&gt;&amp;&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat())</span><br><span class="line">                       _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt; <span class="title">explicit</span> <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">weak_ptr</span>&lt;_Yp&gt;&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type= __nat());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">auto_ptr</span>&lt;_Yp&gt;&amp;&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">auto_ptr</span>&lt;_Yp&gt; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;:</span>:type = __nat());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">unique_ptr</span>&lt;_Yp, _Dp&gt;&amp;&amp;,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">                   &lt;</span></span><br><span class="line"><span class="class">                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">                       __nat</span></span><br><span class="line"><span class="class">                   &gt;:</span>:type = __nat());</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">unique_ptr</span>&lt;_Yp, _Dp&gt;&amp;&amp;,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">                   &lt;</span></span><br><span class="line"><span class="class">                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">                       __nat</span></span><br><span class="line"><span class="class">                   &gt;:</span>:type = __nat());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">unique_ptr</span>&lt;_Yp, _Dp&gt;,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">                   &lt;</span></span><br><span class="line"><span class="class">                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">                       __nat</span></span><br><span class="line"><span class="class">                   &gt;:</span>:type = __nat());</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">unique_ptr</span>&lt;_Yp, _Dp&gt;,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">                   &lt;</span></span><br><span class="line"><span class="class">                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">                       __nat</span></span><br><span class="line"><span class="class">                   &gt;:</span>:type = __nat());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>();</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            shared_ptr&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp; __r) _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">shared_ptr</span>&amp;&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            shared_ptr&lt;_Tp&gt;&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp;&amp; __r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            shared_ptr</span></span><br><span class="line"><span class="class">        &gt;:</span>:type&amp;</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&lt;_Yp&gt;&amp;&amp; __r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            shared_ptr&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&lt;_Yp&gt; __r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            !is_array&lt;_Yp&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="class">            is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            shared_ptr&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&lt;_Yp, _Dp&gt;&amp;&amp; __r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&lt;_Yp, _Dp&gt; __r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">shared_ptr</span>&amp; __r)</span> _NOEXCEPT</span>;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            void</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        reset(_Yp* __p);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            void</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        reset(_Yp* __p, _Dp __d);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">Dp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            void</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        reset(_Yp* __p, _Dp __d, _Alloc __a);</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function">element_type* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __ptr_;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="keyword">typename</span> add_lvalue_reference&lt;element_type&gt;::type <span class="keyword">operator</span>*() <span class="keyword">const</span> _NOEXCEPT</span><br><span class="line">        &#123;<span class="keyword">return</span> *__ptr_;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    element_type* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> _NOEXCEPT &#123;<span class="keyword">return</span> __ptr_;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __cntrl_ ? __cntrl_-&gt;use_count() : <span class="number">0</span>;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> use_count() == <span class="number">1</span>;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    _<span class="function">LIBCPP_EXPLICIT <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> get() != <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">bool</span> <span class="title">owner_before</span>(<span class="title">shared_ptr</span>&lt;_Up&gt; <span class="title">const</span>&amp; __<span class="title">p</span>) <span class="title">const</span> _<span class="title">NOEXCEPT</span></span></span><br><span class="line"><span class="class">        &#123;</span><span class="keyword">return</span> __cntrl_ &lt; __p.__cntrl_;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">bool</span> <span class="title">owner_before</span>(<span class="title">weak_ptr</span>&lt;_Up&gt; <span class="title">const</span>&amp; __<span class="title">p</span>) <span class="title">const</span> _<span class="title">NOEXCEPT</span></span></span><br><span class="line"><span class="class">        &#123;</span><span class="keyword">return</span> __cntrl_ &lt; __p.__cntrl_;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">    __owner_equivalent(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; __p) <span class="keyword">const</span></span><br><span class="line">        &#123;<span class="keyword">return</span> __cntrl_ == __p.__cntrl_;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NO_RTTI</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Dp</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        _<span class="title">Dp</span>* __<span class="title">get_deleter</span>() <span class="title">const</span> _<span class="title">NOEXCEPT</span></span></span><br><span class="line"><span class="class">            &#123;</span><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Dp*&gt;(__cntrl_</span><br><span class="line">                    ? <span class="keyword">const_cast</span>&lt;<span class="keyword">void</span> *&gt;(__cntrl_-&gt;__get_deleter(<span class="keyword">typeid</span>(_Dp)))</span><br><span class="line">                      : <span class="literal">nullptr</span>);&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_NO_RTTI</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_VARIADICS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> ..._<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span></span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class">        <span class="title">make_shared</span>(_<span class="title">Args</span>&amp;&amp; ...__<span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span>, <span class="title">class</span> ..._<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span></span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class">        <span class="title">allocate_shared</span>(<span class="title">const</span> _<span class="title">Alloc</span>&amp; __<span class="title">a</span>, _<span class="title">Args</span>&amp;&amp; ...__<span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// _LIBCPP_HAS_NO_VARIADICS</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt; make_shared();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">A0</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt; <span class="title">make_shared</span>(_<span class="title">A0</span>&amp;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">A0</span>, <span class="title">class</span> _<span class="title">A1</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt; <span class="title">make_shared</span>(_<span class="title">A0</span>&amp;, _<span class="title">A1</span>&amp;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">A0</span>, <span class="title">class</span> _<span class="title">A1</span>, <span class="title">class</span> _<span class="title">A2</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt; <span class="title">make_shared</span>(_<span class="title">A0</span>&amp;, _<span class="title">A1</span>&amp;, _<span class="title">A2</span>&amp;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class">        <span class="title">allocate_shared</span>(<span class="title">const</span> _<span class="title">Alloc</span>&amp; __<span class="title">a</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span>, <span class="title">class</span> _<span class="title">A0</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class">        <span class="title">allocate_shared</span>(<span class="title">const</span> _<span class="title">Alloc</span>&amp; __<span class="title">a</span>, _<span class="title">A0</span>&amp; __<span class="title">a0</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span>, <span class="title">class</span> _<span class="title">A0</span>, <span class="title">class</span> _<span class="title">A1</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class">        <span class="title">allocate_shared</span>(<span class="title">const</span> _<span class="title">Alloc</span>&amp; __<span class="title">a</span>, _<span class="title">A0</span>&amp; __<span class="title">a0</span>, _<span class="title">A1</span>&amp; __<span class="title">a1</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span>, <span class="title">class</span> _<span class="title">A0</span>, <span class="title">class</span> _<span class="title">A1</span>, <span class="title">class</span> _<span class="title">A2</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">static</span> <span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class">        <span class="title">allocate_shared</span>(<span class="title">const</span> _<span class="title">Alloc</span>&amp; __<span class="title">a</span>, _<span class="title">A0</span>&amp; __<span class="title">a0</span>, _<span class="title">A1</span>&amp; __<span class="title">a1</span>, _<span class="title">A2</span>&amp; __<span class="title">a2</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_VARIADICS</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">bool</span> = <span class="title">is_function</span>&lt;_Yp&gt;:</span>:value&gt;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">shared_ptr_default_allocator</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">typedef</span> allocator&lt;_Yp&gt; type;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">struct</span> __<span class="title">shared_ptr_default_allocator</span>&lt;_Yp, true&gt;</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">typedef</span> allocator&lt;__shared_ptr_dummy_rebind_allocator_type&gt; type;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>, <span class="title">class</span> _<span class="title">OrigPtr</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_OrigPtr*,</span></span><br><span class="line"><span class="class">                                          const enable_shared_from_this&lt;_Yp&gt;*</span></span><br><span class="line"><span class="class">        &gt;::value,</span></span><br><span class="line"><span class="class">            void&gt;:</span>:type</span><br><span class="line">        __enable_weak_this(<span class="keyword">const</span> enable_shared_from_this&lt;_Yp&gt;* __e,</span><br><span class="line">                           _OrigPtr* __ptr) _NOEXCEPT</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_cv&lt;_Yp&gt;::type _RawYp;</span><br><span class="line">            <span class="keyword">if</span> (__e &amp;&amp; __e-&gt;__weak_this_.expired())</span><br><span class="line">            &#123;</span><br><span class="line">                __e-&gt;__weak_this_ = <span class="built_in">shared_ptr</span>&lt;_RawYp&gt;(*<span class="keyword">this</span>,</span><br><span class="line">                    <span class="keyword">const_cast</span>&lt;_RawYp*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> _Yp*&gt;(__ptr)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY <span class="keyword">void</span> __enable_weak_this(...) _NOEXCEPT &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt; <span class="title">friend</span> <span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt; <span class="title">friend</span> <span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">weak_ptr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p><code>share_ptr</code>的关键点在于使用了引用计数，<code>__shared_weak_count</code>是一个计数器类，使用<code>__shared_weak_count</code>指针cntrl进行引用计数，当一个<code>share_ptr</code>被赋值给另一个<code>share_ptr</code>时，cntrl的指针传递，并调用cntrl指针所指向的对象的shared引用自增操作(另外还有weak自增)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span>&lt;class _Yp&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;_Tp&gt;:</span>:<span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp; __r, element_type *__p) _NOEXCEPT</span><br><span class="line">    : __ptr_(__p),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然是指针的包装类，让我们看看原生指针在<code>share_ptr</code>里是如何表达的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"><span class="title">typedef</span> _<span class="title">Tp</span> <span class="title">element_type</span>;</span></span><br><span class="line">element_type*      __ptr_;</span><br></pre></td></tr></table></figure></p><p>析构时，在macos的源码里则是调用引用计数器的release_shared()方法进行析构处理。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;_Tp&gt;:</span>:~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__release_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里并没有直接做析构处理，而是使用<code>__release_shared()</code>去执行，最后如果指针需要被释放，会交给<code>__on_zero_shared()</code>这样一个虚函数去执行，并且使用空间配置器将空间回收。</p><h2 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h2><p>令一个类继承<code>enable_shared_from_this&lt;_Tp&gt;</code>，即可获得<code>shared_from_this()</code>函数，它的作用时获取当前类对象的<code>shared_ptr</code>对象。</p><p>当然，前提是这个类对象由<code>shared_ptr</code>所构造，如果直接对一个普通类对象使用该函数获取智能指针，会因为引用计数<code>cntrl.__shared_count == 0</code>而抛出异常。</p><p>下面是一段代码的示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Test&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">  Test();</span><br><span class="line">  ~Test();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Test&gt; getShared()&#123;</span><br><span class="line">    <span class="keyword">return</span> shared_from_this();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，这里的<code>getShared()</code>不可使用<code>return shared_ptr&lt;Test&gt;(this)</code>，原因是，当<code>getShared()</code>被执行两次以上时，显然返回的<code>shared_ptr</code>没有任何关联性，它们的<code>use_count()</code>都将返回1。最后，这些相互独立的智能指针，释放了同一个原生指针，导致异常的产生。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>shared_ptr 不支持数组, 如果使用数组, 需要自定义删除器, 如下是一个利用 lambda 实现的删除器:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sps(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], </span><br><span class="line">    [](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span>[] p;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>多线程使用<code>shared_ptr</code>可能会降低效率，由于存在互斥等竞争关系，而使用重量级的锁，因为shared_ptr需要维护引用计数而造成频繁的上下文切换的开销。</p></li><li>避免<code>shared_ptr</code>的循环引用，比如类A使用了一个<code>shared_ptr&lt;B&gt;</code>指向b对象，而b中又含有一个<code>shared_ptr&lt;A&gt;</code>指向a对象，</li><li><code>shared_ptr</code>常与<code>weak_ptr</code>配合使用，但在使用<code>weak_ptr</code>前，需要对<code>weak_ptr</code>的资源可用情况进行检查。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; sptr(<span class="keyword">new</span> A);</span><br><span class="line">weak_ptr&lt;A&gt; wptr = sptr;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; sptr2 = wptr.lock();</span><br><span class="line"><span class="comment">// if wp.expired() == true then the pointer `sptr2` would get a null value.</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="weak-ptr的实现"><a href="#weak-ptr的实现" class="headerlink" title="weak_ptr的实现"></a>weak_ptr的实现</h1><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><blockquote><p>以下代码摘自MacOS</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">weak_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*        __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    _<span class="function">LIBCPP_CONSTEXPR <span class="title">weak_ptr</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt; _<span class="title">LIBCPP_INLINE_VISIBILITY</span> <span class="title">weak_ptr</span>(<span class="title">shared_ptr</span>&lt;_Yp&gt; <span class="title">const</span>&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, _Tp*&gt;::value, __nat*&gt;:</span>:type = <span class="number">0</span>)</span><br><span class="line">                        _NOEXCEPT;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    weak_ptr(weak_ptr <span class="keyword">const</span>&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt; _<span class="title">LIBCPP_INLINE_VISIBILITY</span> <span class="title">weak_ptr</span>(<span class="title">weak_ptr</span>&lt;_Yp&gt; <span class="title">const</span>&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, _Tp*&gt;::value, __nat*&gt;:</span>:type = <span class="number">0</span>)</span><br><span class="line">                         _NOEXCEPT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    weak_ptr(weak_ptr&amp;&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt; _<span class="title">LIBCPP_INLINE_VISIBILITY</span> <span class="title">weak_ptr</span>(<span class="title">weak_ptr</span>&lt;_Yp&gt;&amp;&amp; __<span class="title">r</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">typename</span> <span class="title">enable_if</span>&lt;is_convertible&lt;_Yp*, _Tp*&gt;::value, __nat*&gt;:</span>:type = <span class="number">0</span>)</span><br><span class="line">                         _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line">    ~weak_ptr();</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr <span class="keyword">const</span>&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            weak_ptr&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(weak_ptr&lt;_Yp&gt; <span class="keyword">const</span>&amp; __r) _NOEXCEPT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&amp;&amp; __r) _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            weak_ptr&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) _NOEXCEPT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_RVALUE_REFERENCES</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yp</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">typename</span> <span class="title">enable_if</span></span></span><br><span class="line"><span class="class">        &lt;</span></span><br><span class="line"><span class="class">            is_convertible&lt;_Yp*, element_type*&gt;::value,</span></span><br><span class="line"><span class="class">            weak_ptr&amp;</span></span><br><span class="line"><span class="class">        &gt;:</span>:type</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="built_in">shared_ptr</span>&lt;_Yp&gt; <span class="keyword">const</span>&amp; __r) _NOEXCEPT;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(weak_ptr&amp; __r)</span> _NOEXCEPT</span>;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> __cntrl_ ? __cntrl_-&gt;use_count() : <span class="number">0</span>;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> __cntrl_ == <span class="number">0</span> || __cntrl_-&gt;use_count() == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;_Tp&gt; lock() <span class="keyword">const</span> _NOEXCEPT;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">bool</span> <span class="title">owner_before</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Up&gt;&amp; __<span class="title">r</span>) <span class="title">const</span> _<span class="title">NOEXCEPT</span></span></span><br><span class="line"><span class="class">        &#123;</span><span class="keyword">return</span> __cntrl_ &lt; __r.__cntrl_;&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">bool</span> <span class="title">owner_before</span>(<span class="title">const</span> <span class="title">weak_ptr</span>&lt;_Up&gt;&amp; __<span class="title">r</span>) <span class="title">const</span> _<span class="title">NOEXCEPT</span></span></span><br><span class="line"><span class="class">        &#123;</span><span class="keyword">return</span> __cntrl_ &lt; __r.__cntrl_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt; <span class="title">friend</span> <span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">weak_ptr</span>;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Up</span>&gt; <span class="title">friend</span> <span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剖析-1"><a href="#剖析-1" class="headerlink" title="剖析"></a>剖析</h2><p>在<code>weak_ptr</code>类中，一样持有<code>__shared_weak_count</code>的指针，但区别在于构造函数的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">weak_ptr</span>&lt;_Tp&gt;:</span>:weak_ptr(weak_ptr <span class="keyword">const</span>&amp; __r) _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_weak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造函数中，引用计数器不采用<code>__add_shared()</code>操作，而采用的是<code>__add_weak()</code></p><p>并且，weak_ptr增加了expired()用于判断指针是否释放已经被释放。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __cntrl_ == <span class="number">0</span> || __cntrl_-&gt;use_count() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>weak_ptr</code>还有一个重要函数<code>lock()</code>，其作用是可以获得对应指针一个可用的<code>shared_ptr</code>资源，如果<code>weak_ptr</code>的<code>expired()</code>返回为true，那么<code>lock()</code>函数将返回一个存储空指针的<code>shared_ptr</code>对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;_Tp&gt;</span></span><br><span class="line"><span class="class"><span class="title">weak_ptr</span>&lt;_Tp&gt;:</span>:lock() <span class="keyword">const</span> _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;_Tp&gt; __r;</span><br><span class="line">    __r.__cntrl_ = __cntrl_ ? __cntrl_-&gt;lock() : __cntrl_;</span><br><span class="line">    <span class="keyword">if</span> (__r.__cntrl_)</span><br><span class="line">        __r.__ptr_ = __ptr_;</span><br><span class="line">    <span class="keyword">return</span> __r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也有其他的版本，在此处使用了<code>shared_from_this()</code>来实现<code>lock()</code>函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是智能指针？&quot;&gt;&lt;a href=&quot;#什么是智能指针？&quot; class=&quot;headerlink&quot; title=&quot;什么是智能指针？&quot;&gt;&lt;/a&gt;什么是智能指针？&lt;/h1&gt;&lt;p&gt;智能指针是代替用户自动去管理的指针的创建于释放的类，是在c++11以后相当常用的类，它使得用
      
    
    </summary>
    
      <category term="cpp" scheme="https://jobscn.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://jobscn.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】使用telnet进行HTTP实验</title>
    <link href="https://jobscn.github.io/network/http/http-test-telnet.html"/>
    <id>https://jobscn.github.io/network/http/http-test-telnet.html</id>
    <published>2019-01-24T05:57:00.000Z</published>
    <updated>2019-07-08T02:37:23.246Z</updated>
    
    <content type="html"><![CDATA[<p>telnet是建立TCP连接的一种手段，我们可以用来测试HTTP报文。</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><blockquote><p>telnet <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 80</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: baidu.com</span><br></pre></td></tr></table></figure><p>即可收到报文响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML ...--&gt;</span><br></pre></td></tr></table></figure><h2 id="尝试对报文使用内容编码"><a href="#尝试对报文使用内容编码" class="headerlink" title="尝试对报文使用内容编码"></a>尝试对报文使用内容编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: baidu.com</span><br><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Bdpagetype: 1</span><br><span class="line">Bdqid: 0xd80316f4000ab7de</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">...省略若干字段</span><br><span class="line"></span><br><span class="line">...省略被编码的主体</span><br></pre></td></tr></table></figure><p>可以看到，主体已经成功的进行了内容编码，响应报文中指定为gzip，并且采用了分块传输编码chunked。</p><blockquote><p>经过尝试的同学应该发现，telnet在得到响应后，并没有断开连接，依然在等待输入状态，这时候若直接敲击2下回车，会得到<code>400 bad request</code>响应。这时因为，HTTP/1.1默认使用了长连接(Connection: keep-alive)，因此在一个请求结束时，并不会断开TCP连接，并且继续等待下一个请求的到来，直到得到<code>Connection: close</code>或心跳失败后断开连接。</p></blockquote><h2 id="单独进行chunked的效果"><a href="#单独进行chunked的效果" class="headerlink" title="单独进行chunked的效果"></a>单独进行chunked的效果</h2><p>通常，采用内容编码后，会结合chunked进行再分块，因此在这里无法单独对百度页面测试chunked编码。</p><p>chunked常使用在动态页面解析技术驱动的页面下，因为动态解析的页面往往无法确定最终的长度。</p><p>由于支持HTTP/1.1的接收方，一定支持chunked编码，不需要特意指定Te: chunked</p><p>可以尝试GET以下资源</p><blockquote><p><a href="http://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx" target="_blank" rel="noopener">http://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /httpgallery/chunked/chunkedimage.aspx HTTP/1.1</span><br><span class="line">Host: www.httpwatch.com</span><br></pre></td></tr></table></figure><p>该资源使用chunked传输编码，收到的报文主体类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400</span><br><span class="line">xxxxx...(400字节)</span><br><span class="line">30</span><br><span class="line">xxxx...(30字节)</span><br><span class="line">0(结束)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;telnet是建立TCP连接的一种手段，我们可以用来测试HTTP报文。&lt;/p&gt;
&lt;h2 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; class=&quot;headerlink&quot; title=&quot;简单示例&quot;&gt;&lt;/a&gt;简单示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;telnet
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
    
      <category term="HTTP" scheme="https://jobscn.github.io/tags/HTTP/"/>
    
      <category term="telnet" scheme="https://jobscn.github.io/tags/telnet/"/>
    
      <category term="chunked" scheme="https://jobscn.github.io/tags/chunked/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】关于首部字段via</title>
    <link href="https://jobscn.github.io/network/http/header/http-head-via.html"/>
    <id>https://jobscn.github.io/network/http/header/http-head-via.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:59:25.947Z</updated>
    
    <content type="html"><![CDATA[<p>Via属于通用首部字段，即请求与响应均可持有的字段。</p><h1 id="Via字段使用在哪里"><a href="#Via字段使用在哪里" class="headerlink" title="Via字段使用在哪里"></a>Via字段使用在哪里</h1><p>使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p><p>报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。这个做法和traceroute及电子邮件的Received首部工作机制很类似。</p><h1 id="使用Via字段的意义"><a href="#使用Via字段的意义" class="headerlink" title="使用Via字段的意义"></a>使用Via字段的意义</h1><p>使用首部字段，可以避免请求回环的发生，必须在经过代理时附加该首部字段内容。</p><p>客户端发出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure></p><p>代理1接收并发出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Via: 1.0 gw.hackr.jp( Squid/3.1)</span><br></pre></td></tr></table></figure></p><p>代理2接收并发出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Via: 1.0 gw.hackr.jp( Squid/3.1 ),</span><br><span class="line">1.1 a1.example.com( Squid/2.7 )</span><br></pre></td></tr></table></figure></p><p>最终由源服务器收到上述报文。</p><p>行头1.0表示接收请求的服务器上所应用的HTTP协议版本，在经过代理服务器B时，同样会写入这些信息。</p><p>Via首部是为了追踪传输路径，所以常会与TRACE方法放在一起使用。比如，代理服务器收到TRACE方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能转发该请求。并将自身的信息附加到Via首部后，返回该请求响应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Via属于通用首部字段，即请求与响应均可持有的字段。&lt;/p&gt;
&lt;h1 id=&quot;Via字段使用在哪里&quot;&gt;&lt;a href=&quot;#Via字段使用在哪里&quot; class=&quot;headerlink&quot; title=&quot;Via字段使用在哪里&quot;&gt;&lt;/a&gt;Via字段使用在哪里&lt;/h1&gt;&lt;p&gt;使用首部
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
      <category term="header" scheme="https://jobscn.github.io/categories/network/http/header/"/>
    
    
      <category term="http" scheme="https://jobscn.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】实体首部字段</title>
    <link href="https://jobscn.github.io/network/http/header/http-head-body.html"/>
    <id>https://jobscn.github.io/network/http/header/http-head-body.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:45:41.891Z</updated>
    
    <content type="html"><![CDATA[<p>实体部分所使用的首部字段，用于补充内容的更新时间或实体相关信息等。</p><h1 id="1-Allow"><a href="#1-Allow" class="headerlink" title="1.Allow"></a>1.Allow</h1><p>用于通知客户端能够支持的Request-URI指定资源的所有HTTP方法。</p><p>当收到不支持的HTTP方法时，会返回405 Method Not Allowed作为响应，并把所有能支持的HTTP方法写入首部字段Allow后返回。</p><h1 id="2-Content-Encoding"><a href="#2-Content-Encoding" class="headerlink" title="2.Content-Encoding"></a>2.Content-Encoding</h1><p>会告知客户端，服务器选用的主体的内容编码方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p><h1 id="3-Content-Length"><a href="#3-Content-Length" class="headerlink" title="3.Content-Length"></a>3.Content-Length</h1><p>表明实体部分的大小，<strong><em>对实体主体进行内容编码传输时，不能再使用该字段！(Transfer-Encoding)</em></strong></p><blockquote><p>Content-Encoding: gzip 输出时，先把整个压缩后的数据写到一个很大的字节数组里(如 ByteArrayOutputStream)，然后得到数组大小 -&gt; Content-Length。</p></blockquote><blockquote><p>如果结合Transfer-Encoding: chunked使用，就不必申请一个很大的字节数组了，可以一块一块的输出，更科学，占用资源更少。</p></blockquote><h1 id="4-Content-Location"><a href="#4-Content-Location" class="headerlink" title="4.Content-Location"></a>4.Content-Location</h1><p>给出报文主体部分对应的URI，和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI。</p><p>比如，对于使用Accept-Language驱动的请求，当返回页面内容与实际请求的对象不同时，首部字段会写明URI。(访问<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>返回的对象确实<a href="http://www.baidu.com/index-cn.html" target="_blank" rel="noopener">http://www.baidu.com/index-cn.html</a>)</p><h1 id="5-Content-MD5"><a href="#5-Content-MD5" class="headerlink" title="5.Content-MD5"></a>5.Content-MD5</h1><p>报文主体-&gt;MD5-&gt;Base64</p><p>客户端会对接收的报文执行相同的MD5算法，然后与首部字段Content-MD5的字段值做比较。</p><p>一般用于检验传输过程主体是否保持完整。</p><p>若内容被恶意篡改，且Content-MD5也被重新计算而后篡改，那么其实无从得知报文是否被人恶意篡改过。</p><h1 id="6-Content-Range"><a href="#6-Content-Range" class="headerlink" title="6.Content-Range"></a>6.Content-Range</h1><p>针对范围请求，响应一个范围响应，并将报文主体对应的范围写入该字段内。</p><h1 id="7-Content-Type"><a href="#7-Content-Type" class="headerlink" title="7.Content-Type"></a>7.Content-Type</h1><p>用于指定实体内容的媒体类型，与Accept一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure></p><p>参数charset表示字符集。</p><h1 id="8-Expires"><a href="#8-Expires" class="headerlink" title="8.Expires"></a>8.Expires</h1><p>告知客户端资源失效的日期，缓存服务器收到该响应后，会以缓存来应答请求，并在指定日期前保存响应的副本。超过指定时间后，会转为向源服务器请求资源。</p><p>源服务器不希望缓存服务器对资源缓存时，最好在Expires内写入与Date相同的时间值。</p><p>比起Expires，会更优先处理Cache-Control的max-age指令。</p><h1 id="9-Last-Modified"><a href="#9-Last-Modified" class="headerlink" title="9.Last-Modified"></a>9.Last-Modified</h1><p>该资源最终修改时间，若使用CGI脚本进行动态数据处理，该值可能变成数据最终修改时的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实体部分所使用的首部字段，用于补充内容的更新时间或实体相关信息等。&lt;/p&gt;
&lt;h1 id=&quot;1-Allow&quot;&gt;&lt;a href=&quot;#1-Allow&quot; class=&quot;headerlink&quot; title=&quot;1.Allow&quot;&gt;&lt;/a&gt;1.Allow&lt;/h1&gt;&lt;p&gt;用于通知客户端能够
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
      <category term="header" scheme="https://jobscn.github.io/categories/network/http/header/"/>
    
    
      <category term="HTTP" scheme="https://jobscn.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】响应首部字段</title>
    <link href="https://jobscn.github.io/network/http/header/http-head-response.html"/>
    <id>https://jobscn.github.io/network/http/header/http-head-response.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:45:36.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Accept-Ranges"><a href="#1-Accept-Ranges" class="headerlink" title="1.Accept-Ranges"></a>1.Accept-Ranges</h1><p>告知客户端能否处理范围请求，只有两个值</p><p>bytes：能处理<br><br>none：不能处理范围请求</p><h1 id="2-Age"><a href="#2-Age" class="headerlink" title="2.Age"></a>2.Age</h1><p>代理创建响应时，必须加上Age字段。</p><p>用于缓存服务器告知客户端，即将返回的响应是在多久前被源服务器所创建的。</p><h1 id="3-ETag"><a href="#3-ETag" class="headerlink" title="3.ETag"></a>3.ETag</h1><p>首部字段ETag能告知客户端实体标识，服务器会对每份资源分配对应的ETag值。</p><p>另外，当资源更新时，ETag值也需要被更新。它没有统一的算法，仅仅由服务器来分配。</p><h2 id="3-1-强ETag值"><a href="#3-1-强ETag值" class="headerlink" title="3.1 强ETag值"></a>3.1 强ETag值</h2><p>不论实体发生多么席位的变化，都会改变ETag值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;352b-540b1498e39c0&quot;</span><br></pre></td></tr></table></figure><h2 id="3-2-弱ETag值"><a href="#3-2-弱ETag值" class="headerlink" title="3.2 弱ETag值"></a>3.2 弱ETag值</h2><p>只用于提示资源是否相同，只有资源发生了根本改变，产生差异时，才会改变ETag值。会在字段值最开始处附加W/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: W/&quot;352b-540b1498e39c0&quot;</span><br></pre></td></tr></table></figure><h1 id="4-Location-302-Redirect"><a href="#4-Location-302-Redirect" class="headerlink" title="4.Location(302 Redirect)"></a>4.Location(302 Redirect)</h1><p>通常在请求时，若发生重定向，则会附带Location字段表明重定向后的资源URI</p><p>请求时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /sample.htm</span><br></pre></td></tr></table></figure></p><p>若资源已被临时转移，则返回<br><br><code>302 Redirect</code><br><br><code>Location: http://www.test.com/sample.htm</code></p><p>再次向新的URI请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /smaple.html</span><br></pre></td></tr></table></figure></p><p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br></pre></td></tr></table></figure></p><h1 id="5-Proxy-Authenticate-WWW-Authenticate"><a href="#5-Proxy-Authenticate-WWW-Authenticate" class="headerlink" title="5.Proxy-Authenticate/WWW-Authenticate"></a>5.Proxy-Authenticate/WWW-Authenticate</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该字段将代理服务器所要求的认证信息发送给客户端。</p><p>该行为发生在客户端与代理之间。而WWW-Authorization发生在客户端与服务器之间。</p><p>realm字段的字符串是为了辨别请求URI指定资源所受到的保护策略。</p><h1 id="6-Retry-After"><a href="#6-Retry-After" class="headerlink" title="6.Retry-After"></a>6.Retry-After</h1><p>告知客户端应在多久后再次发送请求。主要配合<code>503 Service Unavailable</code>响应、<code>3xx Redirect</code>响应使用。</p><p>可以是创建后的秒数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 120</span><br></pre></td></tr></table></figure></p><p>也可以是具体时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: Wed, 04 Jul 2012 06: 34: 24 GMT</span><br></pre></td></tr></table></figure></p><h1 id="7-Server"><a href="#7-Server" class="headerlink" title="7.Server"></a>7.Server</h1><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure></p><h1 id="8-Vary"><a href="#8-Vary" class="headerlink" title="8.Vary"></a>8.Vary</h1><p>Vary字段指定一个字段，当代理服务器收到的请求包含被指定的字段时，如果请求中对应字段的值与响应中对应字段的值相同，那么直接从缓存服务器返回响应。反之从源服务器获取资源后作为响应返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure></p><p>请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample.html HTTP/1.1</span><br><span class="line">...</span><br><span class="line">Accept-Language: en-us</span><br></pre></td></tr></table></figure></p><p>源服务器响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /sample.html HTTP/1.1</span><br><span class="line">...</span><br><span class="line">Accept-Language: en-us</span><br><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure></p><p>那么代理服务器找到Vary所指定的字段Accept-Language后，并且将请求报文与响应报文重的Accept-Language值做对比，发现相同。代理服务器将直接返回缓存内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Accept-Ranges&quot;&gt;&lt;a href=&quot;#1-Accept-Ranges&quot; class=&quot;headerlink&quot; title=&quot;1.Accept-Ranges&quot;&gt;&lt;/a&gt;1.Accept-Ranges&lt;/h1&gt;&lt;p&gt;告知客户端能否处理范围请求，只有两个
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
      <category term="header" scheme="https://jobscn.github.io/categories/network/http/header/"/>
    
    
      <category term="http" scheme="https://jobscn.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】安全的HTTP -- HTTPS</title>
    <link href="https://jobscn.github.io/network/http/http-ssl.html"/>
    <id>https://jobscn.github.io/network/http/http-ssl.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:50:33.004Z</updated>
    
    <content type="html"><![CDATA[<p>在HTTP通信中，报文通常都以明文方式进行传输，如何保证报文的安全。<br><br>通常有两类加密方式可以保证数据的安全，一类是对称加密，一类是非对称加密。其中，对称加密由于需要共享一份相同的密钥，这份密钥的交换方式存在泄漏风险。而采用非对称加密却因为算法的复杂，导致频繁的加密解密使得效率下降。</p><h1 id="如何尽可能高效率的保证HTTP通信的安全-混合加密机制"><a href="#如何尽可能高效率的保证HTTP通信的安全-混合加密机制" class="headerlink" title="如何尽可能高效率的保证HTTP通信的安全(混合加密机制)"></a>如何尽可能高效率的保证HTTP通信的安全(混合加密机制)</h1><p>HTTPS(HTTP Secure)采用了混合加密机制，同时使用了共享密钥加密以及非对称加密两种方式，来保证报文尽可能的安全的前提下，加密解密的效率的提高。<br><br>在交换密钥缓解采用非对称加密方式，建立通信后在交换报文阶段则采用共享密钥加密方式。</p><p>见《图解HTTP》[7.2][p147]</p><p>但是，这种方式依然存在弊端，我们设想若发生以下场景</p><pre><code>1. 攻击者在中间篡改了服务端发送给客户端的公2. 客户端使用虚假公钥对数据进行加密并发送3. 处在中间的攻击者的使用私钥解密数据，...</code></pre><p>显然，单靠报文交换密钥，永远存在风险</p><h1 id="为了证明服务器所采用的数字证书"><a href="#为了证明服务器所采用的数字证书" class="headerlink" title="为了证明服务器所采用的数字证书"></a>为了证明服务器所采用的数字证书</h1><p>首先，需要了解什么是数字证书认证机构(CA)，CA就是一个第三方的受到通信双方信赖的机构。通常在个人电脑或浏览器内，都会自带一系列值得信赖的第三方CA所签发的根证书。</p><p>一个公钥向CA申请证书，CA对该公钥进行数字签名（使用私钥对摘要进行加密）。形成「公钥+数字签名」的数字证书，发放给客户端，客户端通过已有的对应签发机构的根证书（CA的未加密公钥）对传来的数字证书之中的数字签名进行验证，即可证明目标服务器的真假。</p><p>通常，只有服务器持有证书，客户端只需要验证目标服务器的真伪即可。但在某些情况下，客户端也需要持有数字证书，双方的真伪都需要进行验证，常在<code>网上银行</code>、<code>在线支付</code>等特殊场景下存在这一需求。</p><blockquote><p>如何确保网络文件的安全、完整性、来源可靠，通常也采用混合加密机制。<br><br>A向B传送文件：<br><br>1.A计算文件摘要，使用A私钥加密摘要（生成数字签名） <br><br>2.使用某一个对称密码加密文件内容<br> 3.使用B的公钥加密对称密码。<br><br>B从A接收文件：<br><br>1.使用B的私钥解密对称密码<br> 2.使用对称密码解密文件内容<br><br>3.生成内容摘要，使用A的公钥验证数字签名与摘要的一致性（这一步使得内容完整性以及文件来源得以认证）</p></blockquote><h1 id="一个HTTPS通信的完整流程"><a href="#一个HTTPS通信的完整流程" class="headerlink" title="一个HTTPS通信的完整流程"></a>一个HTTPS通信的完整流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. SSL Handshake:ClientHello</span><br><span class="line">(携带支持的SSL版本号等必要信息，生成随机明文1)</span><br><span class="line">2. SSL Handshake:ServerHello</span><br><span class="line">(表示收到，返回使用的版本号等必要信息，生成随机明文2)</span><br><span class="line">3. SSL Handshake:Server Certificate</span><br><span class="line">(服务器发送公钥证书报文)</span><br><span class="line">4. SSL Handshake:ServerHelloDone</span><br><span class="line">(第一阶段握手完成)</span><br><span class="line">----------------------------------</span><br><span class="line">(客户端验证证书通过)</span><br><span class="line">5. SSL Handshake:ClientKeyExchange</span><br><span class="line">(交换通信加密所使用的Pre-master secret随机密码串)</span><br><span class="line">6. Client ChangeCipherSpec</span><br><span class="line">    1) 使用随机明文1、2以及Pre-master生成对称密码。</span><br><span class="line">    2) 表示以后的通信都使用Pre-master secret生成的密钥来加密</span><br><span class="line">7. SSL Handshake:Client Finished</span><br><span class="line">encrypted_handshake_message包含先前所有握手消息的hash，可用于server验证握手过程是否被篡改</span><br><span class="line">8. Server ChangeCipherSpec</span><br><span class="line">    同6</span><br><span class="line">    1) 使用随机明文1、2以及Pre-master生成对称密码</span><br><span class="line">    2) 并告知客户端后续采用对称加密</span><br><span class="line">9. SSL Handshake:Server Finished</span><br><span class="line">(包含之前所有参数的hash，并解密客户端发来的encrypted_handshake_message，验证握手是否被篡改)</span><br><span class="line">10.Client Application Data</span><br><span class="line">( 经过master secret加密的HTTP请求 )</span><br><span class="line">11.Server Application Data</span><br><span class="line">( 经过master secret加密的HTTP响应 )</span><br><span class="line">12.Alert: warning, close notify</span><br><span class="line">( 通信结束 )</span><br></pre></td></tr></table></figure><p>具体通信数据二进制分析可参考<br><a href="https://blog.csdn.net/tterminator/article/details/50675540" target="_blank" rel="noopener">https://blog.csdn.net/tterminator/article/details/50675540</a></p><p>具体步骤详解可参考<br><a href="https://blog.csdn.net/xulujuncsdn/article/details/71320490" target="_blank" rel="noopener">https://blog.csdn.net/xulujuncsdn/article/details/71320490</a></p><p>同时，<code>Application Data</code>会附加一种叫做<code>MAC(Message Authentication Code)</code>的报文摘要，用以验证报文的完整性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在HTTP通信中，报文通常都以明文方式进行传输，如何保证报文的安全。&lt;br&gt;&lt;br&gt;通常有两类加密方式可以保证数据的安全，一类是对称加密，一类是非对称加密。其中，对称加密由于需要共享一份相同的密钥，这份密钥的交换方式存在泄漏风险。而采用非对称加密却因为算法的复杂，导致频繁的
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
    
      <category term="http" scheme="https://jobscn.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】请求首部字段</title>
    <link href="https://jobscn.github.io/network/http/header/http-head-request.html"/>
    <id>https://jobscn.github.io/network/http/header/http-head-request.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:45:30.115Z</updated>
    
    <content type="html"><![CDATA[<p>请求报文中所使用的字段，往往是用于补充请求信息、客户端信息，对响应内容的数据要求等。</p><h1 id="1-Accept"><a href="#1-Accept" class="headerlink" title="1.Accept"></a>1.Accept</h1><p>通常Accept使用<code>type/subtype</code>形式，一次可指定多种媒体类型，按优先顺序排列。</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/plain; q=0.3, text/html</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>类型</th><th>参数</th></tr></thead><tbody><tr><td>文本文件</td><td><code>text/html</code> <code>text/plain</code> <code>text/css</code> <code>applicaation/xhtml+xml</code> <code>application/xml</code></td></tr><tr><td>图片文件</td><td><code>image/jpeg</code> <code>image/gif</code> <code>image/png</code></td></tr><tr><td>视频文件</td><td><code>video/mpeg</code> <code>video/quicktime</code></td></tr><tr><td>应用程序</td><td><code>application/octet-stream</code> <code>application/zip</code></td></tr></tbody></table><p>比如，浏览器不支持处理png格式图片，那么就可以指定为<code>image/gif</code>与<code>image/jpeg</code>等类型。</p><p>若要给媒体类型增加显式优先级，那么可以使用<code>q=</code>来指定权重值，并使用<code>;</code>分割，权重值范围为0~1(可精确到小数点后3位)，不指定时，权重值默认为1.0.</p><p>服务器提供多种内容时，会优先提供并返回权重值最高的媒体类型。</p><h1 id="2-Accept-Charset"><a href="#2-Accept-Charset" class="headerlink" title="2.Accept-Charset"></a>2.Accept-Charset</h1><p>用来同志服务器用户代理支持的字符集，及优先使用的字符相对顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</span><br></pre></td></tr></table></figure><p>同样的，用q来表示权重。</p><p>该字段应用于内容协商机制的服务器驱动协商。</p><h1 id="3-Accept-Encoding"><a href="#3-Accept-Encoding" class="headerlink" title="3.Accept-Encoding"></a>3.Accept-Encoding</h1><p>用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。</p><table><thead><tr><th>编码</th><th>解释</th></tr></thead><tbody><tr><td>gzip</td><td>GNU zip编码格式(RFC1952)，采用LZ77算法及32位循环冗余校验</td></tr><tr><td>compress</td><td>由UNIX文件压缩程序compress生成的编码格式，采用LZW算法</td></tr><tr><td>deflate</td><td>组合使用zlib格式(RFC1950)及由deflate压缩算法(RFC1951)生成的编码格式</td></tr><tr><td>identity</td><td>不进行任何压缩</td></tr><tr><td>*</td><td>指定任意编码格式</td></tr></tbody></table><h1 id="4-Accept-Language"><a href="#4-Accept-Language" class="headerlink" title="4.Accept-Language"></a>4.Accept-Language</h1><p>告知服务器使用的语言集</p><h1 id="5-Authorization-对应前序状态401"><a href="#5-Authorization-对应前序状态401" class="headerlink" title="5.Authorization(对应前序状态401)"></a>5.Authorization(对应前序状态401)</h1><p>在客户端请求时，得到一个401 Unauthorized, WWW-Authenticate: Basic …报文时，需要继续请求并附带Authorization字段的认证报文给服务器。</p><h1 id="6-Expect-对应状态417"><a href="#6-Expect-对应状态417" class="headerlink" title="6.Expect(对应状态417)"></a>6.Expect(对应状态417)</h1><p>告知服务器，期望出现某种特定行为，若无法达成期望，会返回状态417 Expectation Failed。</p><p>HTTP/1.1只规定了100-continue，即指定Expect: 100-continue</p><h1 id="7-From"><a href="#7-From" class="headerlink" title="7.From"></a>7.From</h1><p>告知服务器使用用户代理的用户的电子邮箱地址，可能会因代理不同，记录在User-Agent字段内。</p><h1 id="8-Host"><a href="#8-Host" class="headerlink" title="8.Host"></a>8.Host</h1><p>指定请求资源所在处的互联网主机名及端口，该字段是<strong><em>唯一一个HTTP/1.1规定中必须包含在请求内的首部字段</em></strong></p><p>请求中，域名会被替换为IP来寻找服务器。当同一个IP中部署多台服务器时，Host字段用来辨别应是哪一台服务器接收这个请求。</p><h1 id="9-If-Match-对应状态412-Precondition-Failed"><a href="#9-If-Match-对应状态412-Precondition-Failed" class="headerlink" title="9.If-Match(对应状态412 Precondition Failed)"></a>9.If-Match(对应状态412 Precondition Failed)</h1><p>与资源实体标记(ETag)相关，只有当If-Match的值与ETag值匹配时，服务器才会接受请求。反之，返回状态412 Precondition Failed的响应。</p><p>还可使用*指定If-Match的值，针对这种情况，服务器将会忽略ETag的值，资源存在便去处理。</p><p>通常，资源在被更新后，ETag值都会改变。</p><h1 id="10-If-Modified-Since-304-Not-Modified"><a href="#10-If-Modified-Since-304-Not-Modified" class="headerlink" title="10.If-Modified-Since(304 Not Modified)"></a>10.If-Modified-Since(304 Not Modified)</h1><p>作用：若在指定日期后，资源发生了更新，则接受请求</p><p>失败返回：304 Not Modified</p><h1 id="11-If-None-Match"><a href="#11-If-None-Match" class="headerlink" title="11.If-None-Match"></a>11.If-None-Match</h1><p>作用：当ETag值不符合时接受请求，与If-Match正好相反。在使用GET、HEAD请求时，功能与If-Modified-Since类似</p><h1 id="12-If-Range-412-Precondition-Failed"><a href="#12-If-Range-412-Precondition-Failed" class="headerlink" title="12.If-Range(412 Precondition Failed)"></a>12.If-Range(412 Precondition Failed)</h1><p>作用：作为Range的附带条件，若If-Range指定的值等于资源的ETag值或资源的更新日期，则接受并做范围请求处理。反之，返回全部资源</p><p>原因：若使用If-Match来校验ETag值，Range请求在失败时将得到412的状态码，这时需要重新发起一次请求，去获取全部资源。一共使用了2个请求，才能完成一个目的，而If-Range正好去掉了这多余的一步。</p><h1 id="13-If-Unmodified-Since"><a href="#13-If-Unmodified-Since" class="headerlink" title="13.If-Unmodified-Since"></a>13.If-Unmodified-Since</h1><p>与If-Modified-Since作用正好相反，资源指定资源在指定日期后未更新则返回。</p><p>反之，返回412 Precondition Failed</p><h1 id="14-Max-Forwards"><a href="#14-Max-Forwards" class="headerlink" title="14.Max-Forwards"></a>14.Max-Forwards</h1><p>跳数，每次代理服务器转发就-1。当值为0时返回响应。</p><p>通常通过TRACE或OPTIONS方法，发送包含首部Max-Forwards的请求时，指定可经过服务器的最大数目，当值为0时不在转发，并直接响应。</p><p>有些时候，我们不能确定服务器传输线路中哪一台服务器发生了故障，而这个方法可以帮我们对此类问题展开调查，当字段值为0时，会立即返回，至少可以得知对应服务器的通信状态。</p><h1 id="15-Proxy-Authorization"><a href="#15-Proxy-Authorization" class="headerlink" title="15.Proxy-Authorization"></a>15.Proxy-Authorization</h1><p>客户端与服务器之间的认证使用Authorization。与此相似，而客户端与代理服务器之间的认证，使用该字段。</p><h1 id="16-Range"><a href="#16-Range" class="headerlink" title="16.Range"></a>16.Range</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure><p>设定范围请求，若成功，返回206 Partial Content响应，无法处理时，会返回200 OK以及资源全部内容。</p><h1 id="17-Referer"><a href="#17-Referer" class="headerlink" title="17.Referer"></a>17.Referer</h1><p>Referer字段会告知服务器，请求原始资源的URI，一般都会发送，但有时处于安全性考虑，也可以不发送该字段。（当原始资源URI的查询字符串中涉及ID及密码等）</p><p>注：正确拼法为Referrer，但大家一直沿用这种错误的拼写。</p><h1 id="18-TE"><a href="#18-TE" class="headerlink" title="18.TE"></a>18.TE</h1><p>首部字段TE会告知服务端客户端所能处理的传输编码以及优先级，与字段Accept-Encoding功能相似，但是用于传输编码。</p><p>与Transfer-Encoding是一对，Transfer-Encoding表明已指定的传输编码（如chunked）。</p><p>同时，可用于指定伴随trailers字段的分块传输编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: trailers</span><br></pre></td></tr></table></figure><h1 id="19-User-Agent"><a href="#19-User-Agent" class="headerlink" title="19.User-Agent"></a>19.User-Agent</h1><p>告知服务器创建请求时的浏览器和用户代理名称等信息。</p><p>需要知道的是，由网络爬虫发起的请求，可能会在字段内添加爬虫作者的电子邮箱。此外，若请求经过代理，也可能会被添加上代理服务器的名称</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cloud.tencent.com/developer/section/1190003" target="_blank" rel="noopener">腾讯云HTTP文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请求报文中所使用的字段，往往是用于补充请求信息、客户端信息，对响应内容的数据要求等。&lt;/p&gt;
&lt;h1 id=&quot;1-Accept&quot;&gt;&lt;a href=&quot;#1-Accept&quot; class=&quot;headerlink&quot; title=&quot;1.Accept&quot;&gt;&lt;/a&gt;1.Accept&lt;/h1
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
      <category term="header" scheme="https://jobscn.github.io/categories/network/http/header/"/>
    
    
      <category term="http" scheme="https://jobscn.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】关于首部字段Connection</title>
    <link href="https://jobscn.github.io/network/http/http-head-connection.html"/>
    <id>https://jobscn.github.io/network/http/http-head-connection.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:56:51.202Z</updated>
    
    <content type="html"><![CDATA[<p>Connection字段属于通用首部字段，即请求与响应均可持有的字段。</p><h1 id="Connection字段的作用"><a href="#Connection字段的作用" class="headerlink" title="Connection字段的作用"></a>Connection字段的作用</h1><ol><li>控制不再转发给代理的首部字段</li><li>管理持久连接</li></ol><h1 id="控制不再转发的首部字段"><a href="#控制不再转发的首部字段" class="headerlink" title="控制不再转发的首部字段"></a>控制不再转发的首部字段</h1><p>假设有这样一条数据转发流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 代理服务器 -&gt; 源服务器</span><br></pre></td></tr></table></figure></p><p>报文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: HTTP/1.1</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure></p><p>到达代理服务器后，Upgrade会被删除，并且报文变为再转发出去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure></p><p>传输到源服务器</p><h1 id="管理持久连接"><a href="#管理持久连接" class="headerlink" title="管理持久连接"></a>管理持久连接</h1><p>关闭连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p><p>启用持久连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Keep-Alive: timeout=10, max=500</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Connection字段属于通用首部字段，即请求与响应均可持有的字段。&lt;/p&gt;
&lt;h1 id=&quot;Connection字段的作用&quot;&gt;&lt;a href=&quot;#Connection字段的作用&quot; class=&quot;headerlink&quot; title=&quot;Connection字段的作用&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
    
      <category term="HTTP" scheme="https://jobscn.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【HTTP】Cookie首部字段</title>
    <link href="https://jobscn.github.io/network/http/header/http-head-cookie.html"/>
    <id>https://jobscn.github.io/network/http/header/http-head-cookie.html</id>
    <published>2019-01-24T05:54:00.000Z</published>
    <updated>2019-07-08T02:47:16.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set-Cookie-响应首部"><a href="#Set-Cookie-响应首部" class="headerlink" title="Set-Cookie(响应首部)"></a>Set-Cookie(响应首部)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>访问</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予Cookie的名字和值（必需项）</td></tr><tr><td>expires=DATE</td><td>有效期，默认为关闭浏览器前</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为cookie的使用对象，默认为文档所在目录</td></tr><tr><td>domain=域名</td><td>Cookie使用的域名，默认为创建cookie的服务器域名</td></tr><tr><td>Secure</td><td>仅在HTTPS通信时才会发送Cookie</td></tr><tr><td>HttpOnlly</td><td>使得Cookie不能被JS脚本访问</td></tr></tbody></table><h1 id="Cookie-请求首部"><a href="#Cookie-请求首部" class="headerlink" title="Cookie(请求首部)"></a>Cookie(请求首部)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure><p>首部字段Cookie告知服务器，当客户端向获得HTTP状态管理支持时，会在请求中包含从服务器接收到的单个或多个Cookie，</p><h1 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h1><p>由于HTTP是可扩展的，因此有一些常用的非标准首部字段。见《图解HTTP》6.8, p132</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Set-Cookie-响应首部&quot;&gt;&lt;a href=&quot;#Set-Cookie-响应首部&quot; class=&quot;headerlink&quot; title=&quot;Set-Cookie(响应首部)&quot;&gt;&lt;/a&gt;Set-Cookie(响应首部)&lt;/h1&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="network" scheme="https://jobscn.github.io/categories/network/"/>
    
      <category term="http" scheme="https://jobscn.github.io/categories/network/http/"/>
    
      <category term="header" scheme="https://jobscn.github.io/categories/network/http/header/"/>
    
    
      <category term="http" scheme="https://jobscn.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【C++】关于new与delete的一些问题思考</title>
    <link href="https://jobscn.github.io/cpp/cpp-operator-question.html"/>
    <id>https://jobscn.github.io/cpp/cpp-operator-question.html</id>
    <published>2019-01-13T08:16:00.000Z</published>
    <updated>2019-07-08T03:42:16.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new何时产生构造行为？"><a href="#new何时产生构造行为？" class="headerlink" title="new何时产生构造行为？"></a>new何时产生构造行为？</h1><p>众所周知，new操作符做了两个阶段的工作，首先是内存的分配，其二，便是构造这片内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ctor function"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"dector function"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Test* p = <span class="keyword">new</span> Test;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"out"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">ctor function</span><br><span class="line">dector function</span><br><span class="line">out</span><br></pre></td></tr></table></figure></p><p>new的时候，进行构造。</p><p>同样地，delete时候析构并释放内存。</p><h1 id="new会构造基本数据类型吗？"><a href="#new会构造基本数据类型吗？" class="headerlink" title="new会构造基本数据类型吗？"></a>new会构造基本数据类型吗？</h1><p>基本数据类型并没有构造函数，那么new在这第二阶段做一些什么呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">32766</span><br></pre></td></tr></table></figure></p><p>显然，new还是有他的作用的，初始化内存为0。</p><h1 id="直接调用operator-new会怎样？"><a href="#直接调用operator-new会怎样？" class="headerlink" title="直接调用operator new会怎样？"></a>直接调用operator new会怎样？</h1><p>将最上面的例子改为使用operator new，同样的，配套使用operator delete。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Test* p = (Test*)::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Test));</span><br><span class="line">    </span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"out"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">out</span><br></pre></td></tr></table></figure><p>显然，operator new与delete仅仅是分配与释放了空间，并没有对空间进行构造。</p><p>那么如何构造这片使用operator new生成的内存呢。</p><h1 id="如何在operator-new生成的空间放置一个对象？"><a href="#如何在operator-new生成的空间放置一个对象？" class="headerlink" title="如何在operator new生成的空间放置一个对象？"></a>如何在operator new生成的空间放置一个对象？</h1><p>这里使用placement new,在《more effective C++》条款8中有介绍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Test* p = (Test*)::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Test));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span>(p) Test;</span><br><span class="line">    p-&gt;~Test();</span><br><span class="line"></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"out"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是operator delete只负责内存释放，并不负责析构，因此析构的工作，可能需要手动进行！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;new何时产生构造行为？&quot;&gt;&lt;a href=&quot;#new何时产生构造行为？&quot; class=&quot;headerlink&quot; title=&quot;new何时产生构造行为？&quot;&gt;&lt;/a&gt;new何时产生构造行为？&lt;/h1&gt;&lt;p&gt;众所周知，new操作符做了两个阶段的工作，首先是内存的分配，
      
    
    </summary>
    
      <category term="cpp" scheme="https://jobscn.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://jobscn.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【C++】运算符重载的进一步理解</title>
    <link href="https://jobscn.github.io/cpp/cpp-operator-reload.html"/>
    <id>https://jobscn.github.io/cpp/cpp-operator-reload.html</id>
    <published>2019-01-12T16:59:00.000Z</published>
    <updated>2019-07-08T03:29:17.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运算符重载时需要遵循的规则"><a href="#运算符重载时需要遵循的规则" class="headerlink" title="运算符重载时需要遵循的规则"></a>运算符重载时需要遵循的规则</h1><pre><code>1.不可重载的运算符：. .* :: sizeof ?:2.只能重载已有的运算符，不可自己创造3.运算符重载在实质上属于函数重载，遵循函数重载的规则4.重载运算符并不改变运算符的优先级、也不能改变运算符的操作数个数及语法结构</code></pre><h1 id="双目运算符如何控制左右顺序"><a href="#双目运算符如何控制左右顺序" class="headerlink" title="双目运算符如何控制左右顺序"></a>双目运算符如何控制左右顺序</h1><p>使用友元函数即可编写任意顺序的运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator + version1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> b, A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator + version2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    </span><br><span class="line">    a+<span class="number">1</span>;</span><br><span class="line">    <span class="number">1</span>+a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自增运算符在重载时，如何区分前置后置情况？"><a href="#自增运算符在重载时，如何区分前置后置情况？" class="headerlink" title="自增运算符在重载时，如何区分前置后置情况？"></a>自增运算符在重载时，如何区分前置后置情况？</h1><h2 id="以-为例"><a href="#以-为例" class="headerlink" title="以++为例"></a>以++为例</h2><p>前置++不带参数，返回左值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>++();</span><br></pre></td></tr></table></figure></p><p>后置++带int参数，返回右值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>同样的，可以使用友元函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span>++(A&amp; a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator++ version1: "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span>++(A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator++ version2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    </span><br><span class="line">    a++;</span><br><span class="line">    ++a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator++ version1: 0</span><br><span class="line">operator++ version2</span><br></pre></td></tr></table></figure></p><p>或直接编写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>++(<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator++ version1: "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator++ version2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果完全相同</p><p>在不使用友元函数时，成员函数就像自带了一个关于自身应用的参数一样。因为它隶属于class，必然拥有this，因此节省了一个参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运算符重载时需要遵循的规则&quot;&gt;&lt;a href=&quot;#运算符重载时需要遵循的规则&quot; class=&quot;headerlink&quot; title=&quot;运算符重载时需要遵循的规则&quot;&gt;&lt;/a&gt;运算符重载时需要遵循的规则&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1.不可重载的运算符：. .* ::
      
    
    </summary>
    
      <category term="cpp" scheme="https://jobscn.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://jobscn.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【C++】关于std::move与右值引用</title>
    <link href="https://jobscn.github.io/cpp/cpp-std-move.html"/>
    <id>https://jobscn.github.io/cpp/cpp-std-move.html</id>
    <published>2019-01-12T16:43:00.000Z</published>
    <updated>2019-07-08T03:38:56.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是std-move"><a href="#什么是std-move" class="headerlink" title="什么是std::move"></a>什么是std::move</h1><p>c++11的vector的push_back是支持右值引用传参的，因此我们可以使用std::move将一个左值转换为一个右值引用，这样就可以减少push_back的一次无意义的拷贝构造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">v.push_back(str);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After copy, str is \""</span> &lt;&lt; str &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line"><span class="comment">//调用移动构造函数，掏空str，掏空后，最好不要使用str</span></span><br><span class="line">v.push_back(<span class="built_in">std</span>::move(str));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After move, str is \""</span> &lt;&lt; str &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of the vector are \""</span> &lt;&lt; v[<span class="number">0</span>]</span><br><span class="line">&lt;&lt; <span class="string">"\", \""</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于str作为临时变量传参给了vector，因此，str的值被清空，这时候最好不要再去使用这个str变量。</p><p>让我们先来了解一下左值和右值，右值就是临时使用的，在表达式结束后就将销毁的值，左值是可以取到地址的，在一定范围内被长时间持有的值。</p><h1 id="c-98-c-03产生的问题-右值引用"><a href="#c-98-c-03产生的问题-右值引用" class="headerlink" title="c++98/c++03产生的问题(右值引用)"></a>c++98/c++03产生的问题(右值引用)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = getVar();</span><br></pre></td></tr></table></figure><p>　　上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。</p><p>　　所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>　　在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;;</span><br></pre></td></tr></table></figure></p><p>　　上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。</p><p>　　通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。</p><h1 id="右值引用的作用"><a href="#右值引用的作用" class="headerlink" title="右值引用的作用"></a>右值引用的作用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp;&amp; k = getVar();</span><br></pre></td></tr></table></figure><p>　　第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。</p><p>右值引用的第一个特点</p><p>　　通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。<br>　　<br>　　<br>示例代码</p><p>使用<code>g++ move.cpp --std=c++11 -fno-elide-constructors</code></p><p><code>-fno-elide-constructors</code>用于关闭编译器的返回值优化功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A Constructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">A(<span class="keyword">const</span> A&amp; src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"copy constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"destory"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a = test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"return main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A Constructor</span><br><span class="line">copy constructor</span><br><span class="line">destory</span><br><span class="line">copy constructor</span><br><span class="line">destory</span><br><span class="line">return main</span><br><span class="line">destory</span><br></pre></td></tr></table></figure></p><p>在函数返回时，发生一次右值拷贝，在临时值赋给a时，又发生了一次右值拷贝。</p><p>我们如何避免这种频繁的拷贝呢，那自然是用右值引用延长临时值的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A Constructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">A(<span class="keyword">const</span> A&amp; src)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"copy constructor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"destory"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A&amp;&amp; a = test();<span class="comment">// 延长临时值生命，减少多余拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"return main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A Constructor</span><br><span class="line">copy constructor</span><br><span class="line">destory</span><br><span class="line">return main</span><br><span class="line">destory</span><br></pre></td></tr></table></figure></p><p>可见，通过右值引用变量，我们减少一次没有必要的右值拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：</span><br><span class="line"></span><br><span class="line">　　const A&amp; a = GetA();</span><br><span class="line"></span><br><span class="line">　　输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：</span><br><span class="line"></span><br><span class="line">　　A&amp; a = GetA();</span><br><span class="line"></span><br><span class="line">　　上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。</span><br></pre></td></tr></table></figure><p>右值引用的第二个特点是</p><p>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; var1 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。</p><p>关于右值引用一个有意思的问题是：T&amp;&amp;是什么，一定是右值吗？让我们来看看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">10</span>); <span class="comment">//t是右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">f(x); <span class="comment">//t是左值</span></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，T&amp;&amp;表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。</p><p>右值引用的第三个特点</p><p>　　T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。<br>　　<br>　　我们再回过头看上面的代码，对于函数template<typename t>void f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子：</typename></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">Test(Test&amp;&amp; rhs); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://www.cnblogs.com/qicosmos/p/4283455.html" target="_blank" rel="noopener">https://www.cnblogs.com/qicosmos/p/4283455.html</a></p><h1 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Test(<span class="keyword">const</span> Test&amp; test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"reference copy ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Test(<span class="keyword">const</span> Test&amp;&amp; test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"rvalue reference copy ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> =(<span class="keyword">const</span> Test&amp; test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"reference operator= ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> =(<span class="keyword">const</span> Test&amp;&amp; test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"rvalue reference operator= ctor"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"dector"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test&amp;&amp; <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&amp;&amp; test1 = test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里编译三个版本并展示输出内容</p><h2 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test1 = test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctor</span><br><span class="line">rvalue reference copy ctor</span><br><span class="line">dector</span><br><span class="line">rvalue reference copy ctor</span><br><span class="line">dector</span><br><span class="line">dector</span><br></pre></td></tr></table></figure></p><h2 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h2><p>延长返回值生命周期</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test&amp;&amp; <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test1 = test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctor</span><br><span class="line">dector</span><br><span class="line">rvalue reference copy ctor</span><br><span class="line">dector</span><br></pre></td></tr></table></figure></p><h4 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h4><p>延长右值生命周期</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test&amp;&amp; <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&amp;&amp; test1 = test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctor</span><br><span class="line">dector</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是std-move&quot;&gt;&lt;a href=&quot;#什么是std-move&quot; class=&quot;headerlink&quot; title=&quot;什么是std::move&quot;&gt;&lt;/a&gt;什么是std::move&lt;/h1&gt;&lt;p&gt;c++11的vector的push_back是支持右值引用传参的
      
    
    </summary>
    
      <category term="cpp" scheme="https://jobscn.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://jobscn.github.io/tags/cpp/"/>
    
  </entry>
  
</feed>
